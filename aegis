#! /bin/sh
# ----------- ENVIRONMENT VARIABLES -----------
# CAN BE SOURCED INTO UTILS USING AEGIS -------
# USING: eval "$(aegis _env)" -----------------
if [ "$1" = '_env' ]; then IFS=; while read -r L
  do case "$L" in ': ENV START') E=1;; ': ENV STOP') E=;; ': ENV EOF') break;; *) [ $E ] && echo "$L";; esac
done<$0; exit; fi
# ---------------------------------------------
: ENV START
# ---------------------------------------------
command -v iptables>/dev/null 2>&1 || export PATH=/bin:/sbin:/usr/bin:/usr/sbin
! command -v iprange>/dev/null 2>&1 && [ -e /root/.profile ] && source /root/.profile
SC_VERS="1.4.0"
SC_NAME="aegis"
SC_ABR="aegis"
IPR_BIN="$(/usr/bin/which iprange)"
IPT_COM='iptables'
IPT_BIN="/usr/sbin/$IPT_COM"
IPTBL_SRC="${SC_ABR}_src"
IPTBL_DST="${SC_ABR}_dst"
IPSET_BL_NAME="${SC_ABR}_bl"
IPSET_WL_NAME="${SC_ABR}_wl"
IPSET_TMP="${IPSET_BL_NAME}_tmp"
ROOT_DIR="/opt/bolemo"
BL_FILE="$ROOT_DIR/etc/${SC_NAME}-bl.netset"
WL_FILE="$ROOT_DIR/etc/${SC_NAME}-wl.netset"
INFO_FILE="/tmp/${SC_ABR}_status"
ifconfig ppp0 >/dev/null 2>/dev/null && WAN_IF='ppp0' || WAN_IF="$(/bin/nvram get wan_ifname)"
# VPN tunnel detection
if ifconfig wg0 >/dev/null 2>/dev/null; then
  # WireGuard
  TUN_IF='wg0'
else
  TUN_IF="$(ps -w|/bin/grep -F -- '/usr/sbin/openvpn --dev'|/bin/grep -vE 'grep|server_tap|server_tun')"
  [ "$TUN_IF" ] && TUN_IF=${TUN_IF##* --dev } && TUN_IF=${TUN_IF%% *} # Open VPN client or no tunneling
fi

# INFO FROM (2 bits)
INFO_FROM_MASK=3
INFO_FROM_FWS=1       # _ x
INFO_FROM_PM=2        # x _
INFO_FROM_SC=3        # x x

# INFO IPSET (7 bits)
INFO_IPS_SHIFT=2
INFO_IPS_MASK=127
                      # . . . . . _ _  PBM, BL FILE MISSING
INFO_IPS_BL_SAME=1    # . . . . . _ x  KEEP
INFO_IPS_BL_MISS=2    # . . . . . x _  KEEP
INFO_IPS_BL_LOAD=3    # . . . . . x x
INFO_IPS_BL_MASK=3    # . . . . . x x
INFO_IPS_WL_SAME=4    # . . _ . x . .  SAME => KEEP
INFO_IPS_WL_KEEP=8    # . . _ x . . .  KEEP
INFO_IPS_WL_LOAD=16   # . . x _ _ . .
INFO_IPS_WL_SWAP=20   # . . x _ x . . = RELOAD
INFO_IPS_WL_DEL=24    # . . x x _ . . => was there, was deleted
                      # . . _ _ _ . . => was not there, was not loaded
INFO_IPS_WL_MASK=28   # . . x x x . .
INFO_IPS_WB_NDD=32    # . x . . . . .
INFO_IPS_TB_NDD=64    # x . . . . . .

# INFO IPTABLES (18 bits)
INFO_IPT_SHIFT=9
INFO_IPT_MASK=262143
INFO_IPT_SRC_KEEP=1        # . . . . . . . . . . . . . . . . . x (or NEW)
INFO_IPT_DST_KEEP=2        # . . . . . . . . . . . . . . . . x . (or NEW)

INFO_IPT_IB_PBM=4          # . . . . . . . . . . . . . . . x . .

INFO_IPT_IB_SRC_NEW=1 # . x
INFO_IPT_IB_DST_NEW=2 # x .

INFO_IPT_WB_SHIFT=3
INFO_IPT_WB_SRC_NEW=8      # . . . . . . . . . . . . . . x . . . (or KEEP)
INFO_IPT_WB_DST_NEW=16     # . . . . . . . . . . . . . x . . . . (or KEEP)

INFO_IPT_TB_SHIFT=5
INFO_IPT_TB_SRC_NEW=32     # . . . . . . . . . . . . x . . . . . (or KEEP)
INFO_IPT_TB_DST_NEW=64     # . . . . . . . . . . . x . . . . . . (or KEEP)

INFO_IPT_WL=128            # . . . . . . . . . . x . . . . . . .
INFO_IPT_WL_SRC_NEW=256    # . . . . . . . . . x . . . . . . . . (or KEEP)
INFO_IPT_WL_DST_NEW=512    # . . . . . . . . x . . . . . . . . . (or KEEP)
INFO_IPT_LOG=1024          # . . . . . . . x . . . . . . . . . .
INFO_IPT_LOG_SRC_NEW=2048  # . . . . . . x . . . . . . . . . . . (or KEEP)
INFO_IPT_LOG_DST_NEW=4096  # . . . . . x . . . . . . . . . . . . (or KEEP)

INFO_IPT_IF_NEW=1  # _ x
INFO_IPT_IF_KEEP=2 # x _
INFO_IPT_IF_PBM=3  # x x

INFO_IPT_WAN_SHIFT=13
INFO_IPT_WAN_NEW=8192      # . . . _ x . . . . . . . . . . . . .
INFO_IPT_WAN_KEEP=16384    # . . . x _ . . . . . . . . . . . . .
INFO_IPT_WAN_PBM=24576     # . . . x x . . . . . . . . . . . . .

INFO_IPT_TUN_SHIFT=15
INFO_IPT_TUN_NEW=32768     # . _ x . . . . . . . . . . . . . . .
INFO_IPT_TUN_KEEP=65536    # . x _ . . . . . . . . . . . . . . .
INFO_IPT_TUN_PBM=98304     # . x x . . . . . . . . . . . . . . .

INFO_IPT_IFO_PBM=131072    # x . . . . . . . . . . . . . . . . .

# --------------- ENV FUNCTIONS ---------------

sc_conf() { [ -z "$2" ] && _OPT= || _OPT=".$2" ;/sbin/uci -qc $ROOT_DIR/etc/config $1 $SC_ABR$_OPT; return $?; }

get_ipt() { _IPT="$($IPT_BIN -S 2>/dev/null|/bin/grep -F "$SC_ABR")"; }

inet_for_if() {
  _IP="$(/usr/sbin/ip -4 addr show $1|/usr/bin/awk 'NR==2 {print $2;exit}')"
  if [ "$IPR_BIN" ]
    then echo $_IP|iprange -
    else _IP=$(/bin/ipcalc.sh $_IP|/usr/bin/awk -F= '/NETWORK|PREFIX/ {ORS="/";print $2}');echo ${_IP%?}
  fi
}

# ---------------------------------------------
: ENV STOP
# ---------------------------------------------

# ------------- CIPSET FUNCTIONS --------------
# Copy ipset in /tmp to work on it
# ---------------------------------------------
_cipset_init() { _CIPSET_DIR=$(/bin/mktemp -d "/tmp/${SC_ABR}_XXXXXX"); }
_cipset_end() { [ -d "$_CIPSET_DIR" ] && /bin/rm -r $_CIPSET_DIR; }
_cipset_copy_set() { return $({ { ipset -q -L "$1" 3>&1; echo $? >&3; }|/usr/bin/awk 'NR==1,/Members:/ {next};NF' >"$_CIPSET_DIR/$1"; } 3>&1); }
_cipset_diff_set_file() {
  [ "$IPR_BIN" ] && iprange --quiet "$_CIPSET_DIR/$1" --diff "$2" || /usr/bin/sort|diff -q "$_CIPSET_DIR/$1" "$2" >/dev/null
  return $?
}
_cipset_swap_set_file() {
  cat $2 >$_CIPSET_DIR/$1
  echo -e "create $IPSET_TMP hash:net family inet maxelem $(/usr/bin/wc -l < "$_CIPSET_DIR/$1")\n$(/bin/sed "s/^/add $IPSET_TMP /" $_CIPSET_DIR/$1)" | ipset restore
  ipset swap "$1" "$IPSET_TMP"
  ipset destroy $IPSET_TMP
}
_cipset_create_set_file() {
  cat $2 >$_CIPSET_DIR/$1
  echo -e "create $1 hash:net family inet maxelem $(/usr/bin/wc -l < "$_CIPSET_DIR/$1")\n$(/bin/sed "s/^/add $1 /" "$_CIPSET_DIR/$1")" | ipset restore
}
_cipset_inet_in_bl() {
  [ -z "$IPR_BIN" ] && return 0 # we return true because without iprange, we are not checking thus we want the BP
  [ -z "$(echo "$1" | iprange "$_CIPSET_DIR/$IPSET_BL_NAME" --common - )" ] && return 1 || return 0
}
_cipset_count_set() {
  [ "$IPR_BIN" ] && { $IPR_BIN "$_CIPSET_DIR/$1" -C|/usr/bin/cut -d, -f2; return; }
  /bin/grep -oE '(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\/([0-9]{1,2})' "$_CIPSET_DIR/$1"|/usr/bin/awk -F / '{ count[$2]++ } END { for (mask in count) total+=count[mask]*2^(32-mask); print total }'
}

###############################################
#
#    ENGINE-START
#
###############################################

_set_ipt_bypass_for_if_inet_pos() { # Bypass for interface inet $1=iface, $2=inet, $3=pos
  _RET=0
  _BP_POS="$(echo "$_IPT_SRC"|/bin/grep -nF -- "-s $2 -i $1 -m comment --comment \"$SC_ABR inet bypass\""|cut -d: -f1)"
  if [ "$_BP_POS" != "$3" ]; then
    echo "$_IPT_SRC"|/bin/grep -F -- "-i $1 -j RETURN"|/bin/sed "s/^-A/$IPT_COM -D/"|while read _CMD; do eval "$_CMD 2>/dev/null"; done
    $IPT_BIN -I "$IPTBL_SRC" $3 -s $2 -i $1 -m comment --comment "$SC_ABR inet bypass" -j RETURN
    _RET=$INFO_IPT_IB_SRC_NEW
  fi
  _BP_POS="$(echo "$_IPT_DST"|/bin/grep -nF -- "-d $2 -o $1 -m comment --comment \"$SC_ABR inet bypass\""|cut -d: -f1)"
  if [ "$_BP_POS" != "$3" ]; then
    echo "$_IPT_DST"|/bin/grep -F -- "-o $1 -j RETURN"|/bin/sed "s/^-A/$IPT_COM -D/"|while read _CMD; do eval "$_CMD 2>/dev/null"; done
    $IPT_BIN -I "$IPTBL_DST" $3 -d $2 -o $1 -m comment --comment "$SC_ABR inet bypass" -j RETURN
    _RET=$((_RET+INFO_IPT_IB_DST_NEW))
  fi
  return $_RET
}

_set_ipt_for_if_pos() {
  _IF="$1"
  _POS=$2
  _CT=$(echo "$_IPT"|/bin/grep -cF -- "$_IF -m set --match-set $IPSET_BL_NAME")
  if [ "$_CT" -ne 4 ]; then
    if [ "$_CT" ] && [ "$_CT" -ne 0 ]; then
      # something is messed up with rules; deleting what is left
      echo "$_IPT"|/bin/grep -F -- "$_IF -m set --match-set $IPSET_BL_NAME"|/bin/sed "s/^-A/$IPT_COM -D/"|while read _CMD; do eval "$_CMD 2>/dev/null"; done
      _RET=$INFO_IPT_IF_PBM
    else
      _RET=$INFO_IPT_IF_NEW
    fi
    $IPT_BIN -I INPUT $_POS -i $_IF -m set --match-set "$IPSET_BL_NAME" src -m comment --comment "incoming in $SC_ABR blacklist" -j "$IPTBL_SRC"
    $IPT_BIN -I OUTPUT $_POS -o $_IF -m set --match-set "$IPSET_BL_NAME" dst -m comment --comment "outgoing in $SC_ABR blacklist" -j "$IPTBL_DST"
    $IPT_BIN -I FORWARD $_POS -i $_IF -m set --match-set "$IPSET_BL_NAME" src -m comment --comment "incoming in $SC_ABR blacklist" -j "$IPTBL_SRC"
    $IPT_BIN -I FORWARD $((_POS*2)) -o $_IF -m set --match-set "$IPSET_BL_NAME" dst -m comment --comment "outgoing in $SC_ABR blacklist" -j "$IPTBL_DST"
  else
    _RET=$INFO_IPT_IF_KEEP
  fi
  return $_RET
}

engine_start() {
  NFO_FROM=$1
  [ $NFO_FROM = $INFO_FROM_SC ] && _RELOAD_WTD=1

  NFO_IPS=0; NFO_IPT=0;
  _cipset_init
  # creating ipset blocklist if needed
  if _cipset_copy_set $IPSET_BL_NAME; then
    # an ipset blocklist is already loaded
    if [ -r "$BL_FILE" ]; then
      [ "$_RELOAD_WTD" ] && _RELOAD=1
      # checking if ipset and file are identical
      if _cipset_diff_set_file $IPSET_BL_NAME $BL_FILE
        then _RELOAD=''; NFO_IPS=$((NFO_IPS+INFO_IPS_BL_SAME))
        else _RELOAD=1
      fi
    else
      # blocklist file is missing!
      _RELOAD=''
      NFO_IPS=$((NFO_IPS+INFO_IPS_BL_MISS))
    fi
    if [ "$_RELOAD" ]; then
    # reload is asked for; so need to swap ipset
      _cipset_swap_set_file $IPSET_BL_NAME $BL_FILE
      NFO_IPS=$((NFO_IPS+INFO_IPS_BL_LOAD))
    # else keeping existing blocklist
    fi
  else
    if [ -r "$BL_FILE" ]; then
    # netset file exists, so creating blocklist ipset from it
      _cipset_create_set_file $IPSET_BL_NAME $BL_FILE
      NFO_IPS=$((NFO_IPS+INFO_IPS_BL_LOAD))
    else
    # no netset file, exiting with _IPS=0
      exit 1
    fi
  fi
  
  # creating ipset whitelist if needed
  if _cipset_copy_set $IPSET_WL_NAME; then
    # ipset whitelist is already in place
    if [ -r "$WL_FILE" ]; then
      _WL=1
      [ "$_RELOAD_WTD" ] && _RELOAD=1 || _RELOAD=''
      # checking if ipset and file are identical
      if _cipset_diff_set_file $IPSET_WL_NAME $WL_FILE
        then _RELOAD=''; NFO_IPS=$((NFO_IPS+INFO_IPS_WL_SAME))
        else _RELOAD=1
      fi
      if [ "$_RELOAD" ]; then
      # reload is asked for; so need to swap ipset
        _cipset_swap_set_file $IPSET_WL_NAME $WL_FILE
        NFO_IPS=$((NFO_IPS+INFO_IPS_WL_SWAP))
      else
      # else we want to keep it
        NFO_IPS=$((NFO_IPS+INFO_IPS_WL_KEEP))
      fi
    #else it will be destroyed later
    fi
  else
    if [ -r "$WL_FILE" ]; then
      # netset file exists, so creating whitelist ipset from it
      _WL=1
      _cipset_create_set_file $IPSET_WL_NAME $WL_FILE
      NFO_IPS=$((NFO_IPS+INFO_IPS_WL_LOAD))
    fi
  fi

  get_ipt
  #Define grep to find inaccurate ifaces (used for clean-ups)
  [ "$TUN_IF" ] && _GREP="/bin/grep -v '\($WAN_IF\|$TUN_IF\)'" || _GREP="/bin/grep -vF '$WAN_IF'"
  #Creating our iptables chains if not already set
  _IPT_SRC="$(echo "$_IPT"|/bin/grep -F -- "-A $IPTBL_SRC")"
  [ "$_IPT_SRC" ] && NFO_IPT=$((NFO_IPT+INFO_IPT_SRC_KEEP)) || $IPT_BIN -N "$IPTBL_SRC" 2>/dev/null
  _IPT_DST="$(echo "$_IPT"|/bin/grep -F -- "-A $IPTBL_DST")"
  [ "$_IPT_DST" ] && NFO_IPT=$((NFO_IPT+INFO_IPT_DST_KEEP)) || $IPT_BIN -N "$IPTBL_DST" 2>/dev/null

  WAN_INET=$(inet_for_if $WAN_IF)
  [ "$TUN_IF" ] && TUN_INET=$(inet_for_if $TUN_IF)
  # checking and cleaning any bypass that is not WAN_IF or TUN_IF (+ WAN_IF and TUN_IF if not needed) in SRC/DST chains
  if _cipset_inet_in_bl $WAN_INET; then _EXCL_IF=$WAN_IF; NFO_IPS=$((NFO_IPS+INFO_IPS_WB_NDD)); else WAN_INET=''; fi
  if _cipset_inet_in_bl $TUN_INET; then [ "$_EXCL_IF" ] && _EXCL_IF="\($WAN_IF\|$TUN_IF\)" || _EXCL_IF=$WAN_IF; NFO_IPS=$((NFO_IPS+INFO_IPS_TB_NDD)); else TUN_INET=''; fi
  [ "$_EXCL_IF" ] && _IPT_UCH="$(echo "$_IPT"|/bin/grep -v $_EXCL_IF|/bin/grep -F -- "-m comment --comment \"$SC_ABR inet bypass\" -j RETURN")" \
                  || _IPT_UCH="$(echo "$_IPT"|/bin/grep -F -- "-m comment --comment \"$SC_ABR inet bypass\" -j RETURN")"
  if [ "$_IPT_UCH" ]; then
    # we have some unwanted rules (likely old WAN_IF or TUN_IF)
    echo "$_IPT_UCH"|/bin/sed "s/^-A/$IPT_COM -D/"|while read _CMD; do eval "$_CMD 2>/dev/null"; done
    NFO_IPT=$((NFO_IPT+INFO_IPT_IB_PBM))
  fi

  _POS=0
  # Applying WAN Network Range Bypass if needed and not skipped
  sc_conf get wan.no_bypass >/dev/null || [ "$WAN_INET" ] && { _POS=$((1+_POS)); _set_ipt_bypass_for_if_inet_pos $WAN_IF $WAN_INET $_POS; NFO_IPT=$((NFO_IPT+($?<<INFO_IPT_WB_SHIFT))); }
  # Applying TUN Network Range Bypass (if applicable, needed and not skipped)
  sc_conf get tun.no_bypass >/dev/null || [ "$TUN_INET" ] && { _POS=$((1+_POS)); _set_ipt_bypass_for_if_inet_pos $TUN_IF $TUN_INET $_POS; NFO_IPT=$((NFO_IPT+($?<<INFO_IPT_TB_SHIFT))); }

  if [ "$_WL" ]; then
    # apply whitelist
    _POS=$((1+_POS)) 
    _WL_POS="$(echo "$_IPT_SRC"|/bin/sed -n "/$IPSET_WL_NAME/=")"
    if [ "$_WL_POS" != "$_POS" ]; then
      [ "$_WL_POS" ] && echo "$_IPT_SRC"|/bin/grep -F -- "$IPSET_WL_NAME"|/bin/sed "s/^-A/$IPT_COM -D/"|while read _CMD; do eval "$_CMD 2>/dev/null"; done
      $IPT_BIN -I "$IPTBL_SRC" $_POS -m set --match-set "$IPSET_WL_NAME" src -m comment --comment "in $SC_ABR whitelist" -j RETURN
      NFO_IPT=$((NFO_IPT+INFO_IPT_WL_SRC_NEW))
    fi
    _WL_POS="$(echo "$_IPT_DST"|/bin/sed -n "/$IPSET_WL_NAME/=")"
    if [ "$_WL_POS" != "$_POS" ]; then
      [ "$_WL_POS" ] && echo "$_IPT_DST"|/bin/grep -F -- "$IPSET_WL_NAME"|/bin/sed "s/^-A/$IPT_COM -D/"|while read _CMD; do eval "$_CMD 2>/dev/null"; done
      $IPT_BIN -I "$IPTBL_DST" $_POS -m set --match-set "$IPSET_WL_NAME" dst -m comment --comment "in $SC_ABR whitelist" -j RETURN
      NFO_IPT=$((NFO_IPT+INFO_IPT_WL_DST_NEW))
    fi
    NFO_IPT=$((NFO_IPT+INFO_IPT_WL))
  else
    #Removing any trace of whitelist if any
    echo "$_IPT"|/bin/grep -F -- "$IPSET_WL_NAME"|/bin/sed "s/^-A/$IPT_COM -D/"|while read _CMD; do eval "$_CMD 2>/dev/null"; done
    ipset -q destroy "$IPSET_WL_NAME" && NFO_IPS=$((NFO_IPS+INFO_IPS_WL_DEL))
  fi

  if sc_conf get log >/dev/null; then
    _POS=$((1+_POS))
    _LOG_POS="$(echo "$_IPT_SRC"|/bin/sed -n "/-j LOG/=")"
    if [ "$_LOG_POS" != "$_POS" ]; then
      [ "$_LOG_POS" ] && $IPT_BIN -D "$IPTBL_SRC" -j LOG --log-prefix "[$SC_NAME] " 2>/dev/null
      $IPT_BIN -I "$IPTBL_SRC" $_POS -j LOG --log-prefix "[$SC_NAME] "
      NFO_IPT=$((NFO_IPT+INFO_IPT_LOG_SRC_NEW))
    fi
    _LOG_POS="$(echo "$_IPT_DST"|/bin/sed -n "/-j LOG/=")"
    if [ "$_LOG_POS" != "$_POS" ]; then
      [ "$_LOG_POS" ] && $IPT_BIN -D "$IPTBL_DST" -j LOG --log-prefix "[$SC_NAME] " 2>/dev/null
      $IPT_BIN -I "$IPTBL_DST" $_POS -j LOG --log-prefix "[$SC_NAME] "
      NFO_IPT=$((NFO_IPT+INFO_IPT_LOG_DST_NEW))
    fi
    NFO_IPT=$((NFO_IPT+INFO_IPT_LOG))
  else
    $IPT_BIN -D "$IPTBL_SRC" -j LOG --log-prefix "[$SC_NAME] " 2>/dev/null
    $IPT_BIN -D "$IPTBL_DST" -j LOG --log-prefix "[$SC_NAME] " 2>/dev/null
  fi
  _POS=$((1+_POS))
  _DROP_POS="$(echo "$_IPT_SRC"|/bin/sed -n "/-j DROP/=")"
  if [ "$_DROP_POS" != "$_POS" ]; then
    [ "$_DROP_POS" ] && echo "$_IPT_SRC"|/bin/grep -F -- "-j DROP"|/bin/sed "s/^-A/$IPT_COM -D/"|while read _CMD; do eval "$_CMD 2>/dev/null"; done
    $IPT_BIN -I "$IPTBL_SRC" $_POS -m comment --comment "$SC_ABR drop incoming" -j DROP
  fi
  _DROP_POS="$(echo "$_IPT_DST"|/bin/sed -n "/-j REJECT/=")"
  if [ "$_DROP_POS" != "$_POS" ]; then
    [ "$_DROP_POS" ] && echo "$_IPT_DST"|/bin/grep -F -- "-j REJECT"|/bin/sed "s/^-A/$IPT_COM -D/"|while read _CMD; do eval "$_CMD 2>/dev/null"; done
    $IPT_BIN -I "$IPTBL_DST" $_POS -m comment --comment "$SC_ABR reject outgoing" -j REJECT --reject-with icmp-admin-prohibited
  fi
  
  # checking and cleaning anything that is not WAN_IF or TUN_IF in IFO chains
  _IPT_IFO="$(echo "$_IPT"|/bin/grep -F -- "-m set --match-set $IPSET_BL_NAME"|eval $_GREP)"
  if [ "$_IPT_IFO" ]; then
    # we have some unwanted rules (likely old WAN_IF or TUN_IF)
    echo "$_IPT_IFO"|/bin/sed "s/^-A/$IPT_COM -D/"|while read _CMD; do eval "$_CMD 2>/dev/null"; done
    NFO_IPT=$((NFO_IPT+INFO_IPT_IFO_PBM))
  fi
  
  # creating the required iptables rules for wan interface
  _set_ipt_for_if_pos "$WAN_IF" 1
  NFO_IPT=$((NFO_IPT+($?<<INFO_IPT_WAN_SHIFT)))
  
  # creating the required iptables rules for vpn tunnel interface (if needed)
  if [ "$TUN_IF" ]; then
    _set_ipt_for_if_pos "$TUN_IF" 2
    NFO_IPT=$((NFO_IPT+($?<<INFO_IPT_TUN_SHIFT)))
  fi
  
  _cipset_end
  
  echo -ne "$((NFO_FROM+(NFO_IPS<<INFO_IPS_SHIFT)+(NFO_IPT<<INFO_IPT_SHIFT))) $WAN_IF $TUN_IF" > "$INFO_FILE"
}

###############################################
#
#    CALLED FROM FIREWALL-START & POST-MOUNT
#
###############################################

#we are called from firewall_start.sh
if [ "$1" ] && [ "$1" = "_fws" ]; then
  engine_start "$INFO_FROM_FWS"
  exit 0
fi

#when called from post-mount.sh
_pm() {
  [ -d /opt/bolemo ] || /bin/ln -sfn /tmp/mnt/$2/bolemo /opt/bolemo
  pre_init
  init
  engine_start "$INFO_FROM_PM"
  exit 0
}

###############################################
#
#    ADDITIONNAL GLOBALS NEEDED WHEN NOT CALLED FROM FIREWALL-START
#
###############################################
# ---------------------------------------------
: ENV START
# ---------------------------------------------
SC_NICEPATH="$ROOT_DIR/scripts/$SC_NAME"
SC_PATH="$(cd "$ROOT_DIR/scripts/">/dev/null 2>&1; pwd -P)"
SRC_LIST="$ROOT_DIR/etc/$SC_NAME.sources"
CUST_BL_FILE="$ROOT_DIR/etc/${SC_NAME}*.blacklist"
CUST_WL_FILE="$ROOT_DIR/etc/${SC_NAME}*.whitelist"
TMP_FILE="/tmp/$SC_NAME.tmp"
TMP_HTML="/tmp/$SC_NAME-html.tmp"
WWW_PATH="$ROOT_DIR/www"
FWS_DIR="/opt/scripts"
FWS_FILE="$FWS_DIR/firewall-start.sh"
# Check if script is installed on USB
if [ -z "${SC_PATH##/tmp/mnt/*}" ]; then
  PM_DIR="${SC_PATH%${SC_PATH#/tmp/mnt/*/}}autorun/scripts"
  PM_FILE="$PM_DIR/post-mount.sh"
  EXT_DRIVE=1
else
  EXT_DRIVE=''
fi
# ---------------------------------------------
: ENV STOP
# ---------------------------------------------

###############################################
#
#    DEALING WITH EXTERNAL SCRIPTS/CONFS
#    check, set, clean
#
###############################################

# SCRIPT: firewall-start.sh ###################
check_firewall_start() {
  [ -x "$FWS_FILE" ] || return 1
  [ "$(/bin/sed 's/[[:space:]]\+/ /g' "$FWS_FILE"|/bin/grep -c -- "\[ -x $SC_NICEPATH \] && $SC_NICEPATH _fws")" = 1 ] || return 1
  return 0
}

set_firewall_start() {
  [ -d "$FWS_DIR" ] || /bin/mkdir -p "$FWS_DIR"
  [ -e "$FWS_FILE" ] && /bin/sed -i "/$SC_NAME/d" "$FWS_FILE"
  echo -e "# Bolemo $SC_NAME\n[ -x $SC_NICEPATH ] && $SC_NICEPATH _fws" >> "$FWS_FILE"
  [ -x "$FWS_FILE" ] || /bin/chmod +x "$FWS_FILE"
}

clean_firewall_start() {
  if [ -e "$FWS_FILE" ]; then
    if [ "$(/bin/grep -Fv "$SC_NAME" "$FWS_FILE"|/bin/sed '/^[[:space:]]*$/d')" ]; then
      /bin/sed -i "/$SC_NAME/d" "$FWS_FILE"
      [ "$VERBOSE" ] && echo "- 'firewall-start.sh' has some other rules; removed only our rules."
    else
      /bin/rm "$FWS_FILE" 2>/dev/null
      [ "$VERBOSE" ] && echo "- 'firewall-start.sh' had no other rules; removed it."
    fi
  fi
}

# SCRIPT: post-mount.sh ########################
check_postmount() {
  [ -x "$PM_FILE" ] || return 1
  [ "$(/bin/sed 's/[[:space:]]\+/ /g' "$PM_FILE"|/bin/grep -cF -- "[ -x $SC_NICEPATH ] && $SC_NICEPATH _pm \$1")" = 1 ] || return 1
  return 0
}

set_postmount() {
  [ "$EXT_DRIVE" ] || return 1
  [ -d "$PM_DIR" ] || /bin/mkdir -p "$PM_DIR"
  [ -e "$PM_FILE" ] && /bin/sed -i "/$SC_NAME/d" "$PM_FILE"
  echo -e "# Bolemo $SC_NAME\n[ -x $SC_NICEPATH ] && $SC_NICEPATH _pm \$1" >> "$PM_FILE"
  [ -x "$PM_FILE" ] || /bin/chmod +x "$PM_FILE"
}

clean_postmount() {
  if [ "$EXT_DRIVE" ] && [ -e "$PM_FILE" ]; then
    if [ "$(/bin/grep -Fv "$SC_NAME" "$PM_FILE"|/bin/sed '/^[[:space:]]*$/d')" ]; then
      /bin/sed -i "/$SC_NAME/d" "$PM_FILE"
      [ "$VERBOSE" ] && echo "- 'post-mount.sh' has some other code; removed only our code."
    else
      /bin/rm "$PM_FILE" 2>/dev/null
      [ "$VERBOSE" ] && echo "- 'post-mount.sh' had no other code; removed it."
    fi
  fi
}

# SYMLINK: /usr/bin/SELF ######################
check_path() {
  command -v "$SC_NAME" > /dev/null && return 0 || return 1
}

set_path() {
  [ -e "/usr/bin/$SC_NAME" ] || /bin/ln -s "$SC_NICEPATH" "/usr/bin/$SC_NAME"
}

clean_path() {
  if [ -e "/usr/bin/$SC_NAME" ]; then
    /bin/rm "/usr/bin/$SC_NAME" 2>/dev/null
    [ "$VERBOSE" ] && echo "- '/usr/bin' symlink was removed."
  fi
}

check_conf() {
  [ -d "$ROOT_DIR/etc/config" ] || return 1
  sc_conf get >/dev/null || return 1
  sc_conf get wan >/dev/null || return 1
  sc_conf get tun >/dev/null || return 1
  return 0
}

set_conf() {
  [ -d "$ROOT_DIR/etc/config" ] || /bin/mkdir -p "$ROOT_DIR/etc/config" 2>/dev/null
  uci -qc $ROOT_DIR/etc/config import $SC_ABR << EOF
package $SC_ABR
config net-iface 'wan'
config net-iface 'tun'
EOF
  sc_conf commit
}

clean_conf() {
  /bin/rm "$ROOT_DIR/etc/config/$SC_ABR" 2>/dev/null
  sc_conf commit
  [ "$VERBOSE" ] && echo "- '$SC_NAME' configuration file was removed."
}

###############################################
#
#    FUNCTIONS DEPENDING ON BOLEMO GIT REPO
#
###############################################
# ---------------------------------------------
: ENV START
# ---------------------------------------------
BOLEMO_GIT_REPO='https://raw.githubusercontent.com/bolemo'
SC_BASE_REPO="$BOLEMO_GIT_REPO/$SC_NAME"
SC_MAIN_REPO="$SC_BASE_REPO/master"
SC_DEV_REPO="$SC_BASE_REPO/dev"

last_avail_version() {
  [ "$DEVMODE" ] && VERSION_URL="$SC_DEV_REPO/version" || VERSION_URL="$SC_MAIN_REPO/version"
  /usr/bin/wget -qO- "$VERSION_URL"
}

# ---------------------------------------------
: ENV STOP
# ---------------------------------------------

do_upgrade() {
echo "- Downloading:"
  DL_PATH="/tmp/$SC_NAME.dl"
  _PROG='--show-progress';
  [ "$DEVMODE" ] && _PROG="--no-cache $_PROG"
  echo -ne "\033[35m"
  if /usr/bin/wget -qO "$DL_PATH" $_PROG "$UPGRADE_URL"; then
    /bin/sed -i 's/^[[:space:]]*// ; 1!{/^#/d;s/#[^"\}'\'']*$//;} ; s/[[:space:]]*$// ; /^$/d ; s/   *\([^"'\'']*\)$/ \1/ ; s/^\(\([^"'\'' ]\+ \)*\) \+/\1/' "$DL_PATH"
    \/bin/mv "$DL_PATH" "$SC_NICEPATH"
    /bin/chmod +x "$SC_NICEPATH"
    echo -e "\033[0m- Script installed to $SC_NICEPATH"
  else
    echo -ne "\033[0m"
    >&2 echo -e "\033[31m! Wget error code $?! Could not download $DL_PATH\033[0m"
    /bin/rm -f "$DL_PATH"
    exit 1
  fi
  check_web && install_web
  exit 0
}

_upgrade() {
  UPGRADE_URL="$SC_MAIN_REPO/$SC_NAME"; UPGRADE_VER="$SC_LAST_VERS"
  do_upgrade
}

upgrade() {
  echo -e "\033[1;36mUpgrading:\033[0m"
  echo "- Version installed: $SC_VERS"
  if [ "$DEVMODE" ]; then
    echo "- Devmode on, force downloading from '$SC_DEV_REPO'..."
    UPGRADE_URL="$SC_DEV_REPO/$SC_NAME"
    UPGRADE_VER=$(/usr/bin/wget -qO- "$SC_DEV_REPO/version")
    [ -z "$UPGRADE_VER" ] && { >&2 echo -e "\033[31m! Could not get version!\033[0m";exit 1; }
  else
    echo -ne "- Checking latest available version...\r"
    SC_LAST_VERS="$(last_avail_version)"
    if [ "$SC_LAST_VERS" ]; then
      _LOC_VERS=$(echo "$SC_VERS"|/bin/sed 's/[^[:digit:]]//g')
      _REM_VERS=$(echo "$SC_LAST_VERS"|/bin/sed 's/[^[:digit:]]//g')
      if [ $_LOC_VERS -eq $_REM_VERS ]; then echo "- This is already the last version.            "; exit 0
      elif [ $_LOC_VERS -lt $_REM_VERS ]; then echo "- New version available: $SC_LAST_VERS         "
      else echo -e "\033[35m- This version is higher than than the one available: $SC_LAST_VERS         \033[0m"
      fi
    else
      >&2 echo -e "\033[31m! Could not check what is the last version online!\033[0m"
      exit 1
    fi
    UPGRADE_URL="$SC_MAIN_REPO/$SC_NAME"
    UPGRADE_VER="$SC_LAST_VERS"
  fi
  if [ ! "$DEVMODE" ]; then
    echo -n "? Do you want to upgrade from $SC_VERS to $SC_LAST_VERS (y/n)? "
    case "$(i=0;while [ $i -lt 2 ];do i=$((i+1));read -p '' YN </dev/tty;[ -n "$YN" ] && echo "$YN" && break;done)" in Y|y|yes|Yes|YES) : ;; *) exit 0 ;; esac
  fi
  do_upgrade
}

# get default sources list (from bolemo github)
get_def_srclst() {
  if [ ! -e "$SRC_LIST" ]; then
    [ "$VERBOSE" ] && echo -e "! $SRC_LIST is missing!"
    SRC_LIST_URL="$SC_MAIN_REPO/$SC_NAME.sources"
    if /usr/bin/wget -qO "$SRC_LIST" "$SRC_LIST_URL"; then
      [ "$VERBOSE" ] && echo -e "- Default list was downloaded."
    else
      >&2 echo -e "\033[31m! Wget error code $?! Could not download $SRC_LIST_URL\033[0m"
      /bin/rm -f "$SRC_LIST"
      exit 1
    fi
  fi
}

###############################################
#
#    WEB COMPANION RELATED FUNCTIONS
#
###############################################
WEB_NAME='Web Companion'
check_web() {
  [ -L "/www/bolemo" ] || return 1
  [ -e "/www/bolemo/aegis.htm" ] || return 1
  [ -x "/www/bolemo/cgi-bin/aegis_web.cgi" ] || return 1
  return 0
}

install_web() {
  [ -d "$WWW_PATH" ] || /bin/mkdir "$WWW_PATH" 2>/dev/null
  [ -d "$WWW_PATH/cgi-bin" ] || mkdir "$WWW_PATH/cgi-bin"
  if [ -z "$UPGRADE_URL" ]; then
    if [ "$DEVMODE" ]; then
      echo "- Devmode on, force downloading from '$SC_DEV_REPO'..."
      UPGRADE_URL="$SC_DEV_REPO/$SC_NAME"
    else
      UPGRADE_URL="$SC_MAIN_REPO/$SC_NAME"
    fi
  fi
  echo "- Downloading $WEB_NAME:"
  DL_PATH="/tmp/$SC_NAME.dl"
  _PROG='--show-progress';
  [ "$DEVMODE" ] && _PROG="--no-cache $_PROG"
  echo -ne "\033[35m"
  if /usr/bin/wget -qO "$DL_PATH" $_PROG "${UPGRADE_URL}.htm"; then
    \/bin/mv "$DL_PATH" "$WWW_PATH/$SC_NAME.htm"
    echo -e "\033[0m- $WEB_NAME htm file installed to $WWW_PATH/$SC_NAME.htm"
  else
    echo -ne "\033[0m"
    >&2 echo -e "\033[31m! Wget error code $?! Could not download $DL_PATH\033[0m"
    /bin/rm -f "$DL_PATH"
    exit 1
  fi
  echo -ne "\033[35m"
  if /usr/bin/wget -qO "$DL_PATH" $_PROG "${UPGRADE_URL}_web.cgi"; then
    \/bin/mv "$DL_PATH" "$WWW_PATH/cgi-bin/${SC_NAME}_web.cgi"
    /bin/chmod +x "$WWW_PATH/cgi-bin/${SC_NAME}_web.cgi"
    echo -e "\033[0m- $WEB_NAME cgi file installed to $WWW_PATH/cgi-bin/${SC_NAME}_web.cgi"
  else
    echo -ne "\033[0m"
    >&2 echo -e "\033[31m! Wget error code $?! Could not download $DL_PATH\033[0m"
    /bin/rm -f "$DL_PATH"
    exit 1
  fi
  if ! check_web; then
    /bin/rm -f "/www/bolemo" 2>/dev/null
    /bin/ln -sfn "$WWW_PATH" '/www/bolemo' 2>/dev/null
    echo "- $WEB_NAME paths were repaired."
  fi
  exit 0
}

clean_web() {
  /bin/rm -f "$WWW_PATH/$SC_NAME.htm" 2>/dev/null
  eval "$WWW_PATH/cgi-bin/${SC_NAME}_web.cgi uninstall" 2>/dev/null
  /bin/rm -f "$WWW_PATH/cgi-bin/${SC_NAME}_web.cgi" 2>/dev/null
  [ "$VERBOSE" ] && echo "- $WEB_NAME was removed."
}

###############################################
#
#    UTILITY FUNCTIONS
#
###############################################

name_from_ip() {
  _NAME="$(/usr/bin/awk 'match($0,/'$1' /) {print $3;exit}' /tmp/netscan/attach_device 2>/dev/null)"
  [ -z "$_NAME" ] && _NAME="$(/usr/bin/awk 'match($0,/'$1' /) {print $NF;exit}' /tmp/dhcpd_hostlist /tmp/hosts 2>/dev/null)"
  [ -z "$_NAME" ] && echo "$1" || echo "$_NAME ($1)"
}

###############################################
#
#    INIT FUNCTIONS
#    script init & when using firewall init
#
###############################################

pre_init() {
  check_path || set_path
  [ -d "$ROOT_DIR/etc" ] || /bin/mkdir "$ROOT_DIR/etc" 2>/dev/null
  check_conf || set_conf
  [ -d "$WWW_PATH" ] || /bin/mkdir "$WWW_PATH" 2>/dev/null		
  [ -d '/www/bolemo' ] || /bin/ln -sfn "$WWW_PATH" '/www/bolemo' 2>/dev/null
}

init() {
  [ "$VERBOSE" ] && echo -e "\033[1;36mInitializing...\033[0m"
  ipset -q destroy $IPSET_TMP
  if check_conf
    then [ "$VERBOSE" ] && echo "- Configuration file is set."
    else { >&2 echo -e "\033[31m! Problem with the configuration system!\033[0m"; exit 1; }
  fi
  if check_firewall_start; then
    [ "$VERBOSE" ] && echo "- 'firewall-start.sh' is in place and ok."
  else
    set_firewall_start
    check_firewall_start || { >&2 echo -e "\033[31m! Problem with $FWS_FILE!\033[0m"; exit 1; }
    [ "$VERBOSE" ] && echo "- 'firewall-start.sh' was edited and is now ok."
  fi
  if [ "$EXT_DRIVE" ]; then
    [ "$VERBOSE" ] && echo "- '$SC_NAME' is installed on external drive."
    if check_postmount; then
      [ "$VERBOSE" ] && echo "- 'post-mount.sh' is in place and ok."
    else
      set_postmount
      check_postmount || { >&2 echo -e "\033[31m! Problem with $PM_FILE!\033[0m"; exit 1; }
      [ "$VERBOSE" ] && echo "- 'post-mount.sh' was edited and is now ok."
    fi
  else
    [ "$VERBOSE" ] && echo "- '$SC_NAME' is installed on internal drive."
  fi
}

fw_restart() {
  [ "$VERBOSE" ] && echo -e "\033[1;36mRestarting firewall...\033[0m"
  set_log_state
  /usr/sbin/net-wall restart > /dev/null
  [ "$VERBOSE" ] && echo "- Firewall restarted."
}

###############################################
#
#    FUNCTIONS FOR SCRIPT CMD ARGUMENTS
#
###############################################

print_log() {
  echo -e "\033[1;36mLog:\033[0m"
  echo -e "\033[35mIf the log is empty, to be sure it is enabled, use the \033[1mstatus\033[0;35m parameter.\033[0m"
  [ $1 ] && _TAIL=$1 || _TAIL=100
  _BT=$(( $(/bin/date +%s) - $(/usr/bin/cut -d. -f1 /proc/uptime) ))
  /bin/grep -F "$SC_NAME" /var/log/log-message | /usr/bin/tail -n$_TAIL | while IFS= read -r LINE; do
    _TS=$(echo $LINE|/usr/bin/cut -d: -f1)
    _PT="$(/bin/date -d $((_BT+_TS)) -D %s +"%F %T")"

    _1=${LINE#* SRC=}; _SRC=${_1%% *}
    _1=${LINE#* DST=}; _DST=${_1%% *}
    _1=${LINE#* PROTO=}; _PROTO=${_1%% *}; [ -z "${_PROTO##*[!0-9]*}" ] || _PROTO="[protocol $_PROTO]"
    _1=${LINE#* SPT=}; [ "$_1" = "$LINE" ] && _SPT='' || _SPT=":${_1%% *}"
    _1=${LINE#* DPT=}; [ "$_1" = "$LINE" ] && _DPT='' || _DPT=":${_1%% *}"

    case $LINE in
      *"IN=$WAN_IF OUT= "*) [ "$_DST" = '255.255.255.255' ] && _DNAME="broadcast" || _DNAME="router"
         echo -e "$_PT Blocked \\033[1;35mincoming\\033[0m $_PROTO packet from WAN: \\033[1;35m$_SRC$_SPT\\033[0m to $_DNAME: \\033[1;33m$_DST$_DPT\\033[0m" ;;
      *"IN=$WAN_IF"*) echo -e "$_PT Blocked \\033[1;35mincoming\\033[0m $_PROTO packet from WAN: \\033[1;35m$_SRC$_SPT\\033[0m to LAN: \\033[1;33m$(name_from_ip $_DST)$_DPT\\033[0m" ;;
      *"IN= OUT=$WAN_IF"*) echo -e "$_PT Blocked \\033[1;33moutgoing\\033[0m $_PROTO packet to WAN: \\033[1;35m$_DST$_DPT\\033[0m from router: \\033[1;33m$_SRC$_SPT\\033[0m" ;;
      *"OUT=$WAN_IF"*) echo -e "$_PT Blocked \\033[1;33moutgoing\\033[0m $_PROTO packet to WAN: \\033[1;35m$_DST$_DPT\\033[0m from LAN: \\033[1;33m$(name_from_ip $_SRC)$_SPT\\033[0m" ;;
      *"IN=$TUN_IF OUT= "*) [ "$_DST" = '255.255.255.255' ] && _DNAME="broadcast" || _DNAME="router"
         echo -e "$_PT Blocked \\033[1;35mincoming\\033[0m $_PROTO packet from VPN: \\033[1;35m$_SRC$_SPT\\033[0m to $_DNAME: \\033[1;33m$_DST$_DPT\\033[0m" ;;
      *"IN=$TUN_IF"*) echo -e "$_PT Blocked \\033[1;35mincoming\\033[0m $_PROTO packet from VPN: \\033[1;35m$_SRC$_SPT\\033[0m to LAN: \\033[1;33m$(name_from_ip $_DST)$_DPT\\033[0m" ;;
      *"IN= OUT=$TUN_IF"*) echo -e "$_PT Blocked \\033[1;33moutgoing\\033[0m $_PROTO packet to VPN: \\033[1;35m$_DST$_DPT\\033[0m from router: \\033[1;33m$_SRC$_SPT\\033[0m" ;;
      *"OUT=$TUN_IF"*) echo -e "$_PT Blocked \\033[1;33moutgoing\\033[0m $_PROTO packet to VPN: \\033[1;35m$_DST$_DPT\\033[0m from LAN: \\033[1;33m$(name_from_ip $_SRC)$_SPT\\033[0m" ;;
    esac
  done
}

set_log_state() { sc_conf get log >/dev/null && [ "$VERBOSE" ] && echo "- Enabling logging."; }

clean() {
  [ "$VERBOSE" ] && echo -e "\033[1;36mCleaning...\033[0m"
  clean_firewall_start
  clean_postmount
  [ "$RM_CONF" ] && check_conf && clean_conf
  [ "$RM_SYMLINK" ] && check_path && clean_path
  [ "$RM_WEB" ] && check_web && clean_web
  /bin/rm -f "$INFO_FILE"
  /usr/sbin/net-wall restart > /dev/null
  [ "$VERBOSE" ] && echo "- Built-in firewall restarted."
  ipset -q destroy "$IPSET_BL_NAME"
  ipset -q destroy "$IPSET_WL_NAME"
  ipset -q destroy "$IPSET_TMP"
  [ "$VERBOSE" ] && echo "- Cleaned ipsets."
  [ -e "$TMP_FILE" ] && /bin/rm -f "$TMP_FILE"
  [ "$VERBOSE" ] && echo -e "- Removed temporary files.\n- Cleaning done."
}

set_ipset() {
  [ -r "$BL_FILE" ] || { >&2 echo -e "\033[31m! $BL_FILE not readable!\033[0m"; exit 1; }
  [ "$VERBOSE" ] && echo -e "\033[1;36mLoading blocklist into engine:\033[0m"
  set_log_state
  [ "$VERBOSE" ] && echo "- Starting $SC_NAME engine, forcing reload of blocklist..."
  engine_start "$INFO_FROM_SC"
}

update_iplist() {
  [ "$VERBOSE" ] && echo -e "\033[1;36mUpdating blocklist from sources...\033[0m"
  [ -e "$SRC_LIST" ] || get_def_srclst

  :>"$TMP_FILE"
  # Process each source url
  [ "$VERBOSE" ] && echo "- Downloading lists defined in $SRC_LIST"
  [ "$VERBOSE" ] && WGET_OPTS='-qO- --show-progress' || WGET_OPTS='-qO-'
  _NBOK=0; _TOT=0;
  /bin/grep -v "^[[:space:]*\#]" "$SRC_LIST" | \
  { while read -r URL; do
      _TOT=$((_TOT+1))
      [ "$VERBOSE" ] && echo -e "$_TOT) $URL\033[35m"
      { { { { /usr/bin/wget $WGET_OPTS "$URL"; echo $? >&3; } |/bin/grep '^[0-9]'|/bin/sed 's/;.*//' >>"$TMP_FILE"; } 3>&1; } | { read _EC; exit $_EC; } }
      _EC=$?
      [ "$VERBOSE" ] && echo -e "\033[0m"
      [ $_EC = 0 ] && _NBOK=$((_NBOK+1)) || >&2 echo -e "\033[31m! Wget error code $_EC! Could not download $URL\033[0m"
    done
    [ $_NBOK = 0 ] && { >&2 echo -e "\033[31m! Could not get any list!\033[0m"; rm "$TMP_FILE"; exit 1; }
    [ $_NBOK = $_TOT ] || >&2 echo -e "\033[31m! Downloaded only $_NBOK / $_TOT list(s)!\033[0m"
  }
  if ( for F in $CUST_BL_FILE; do test -r $F || exit 1; done; ); then
    [ "$VERBOSE" ] && echo "- Adding netset from custom blacklist(s)..."
    /usr/bin/awk -F'[#;]' 'match($1,/^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+(\/[0-9]+)?$/) {print $1}' $CUST_BL_FILE >>"$TMP_FILE"
  fi
  if [ -x "$IPR_BIN" ]; then
    [ "$VERBOSE" ] && echo "- Optimizing and reducing netset (using iprange)..."
    $IPR_BIN --ipset-reduce 20 "$TMP_FILE" > "$BL_FILE"
  else
    [ "$VERBOSE" ] && echo -e "- iprange not installed, passing optimization and reduction process.\n- Removing duplicates..."
    /usr/bin/sort "$TMP_FILE"|/usr/bin/uniq > "$BL_FILE"
  fi
  /bin/rm -f "$TMP_FILE"
  [ "$VERBOSE" ] && echo "- Done."

  # processing whitelist if any
  if ( for F in $CUST_WL_FILE; do test -r $F || exit 1; done; ); then
    [ "$VERBOSE" ] && echo -e "\033[1;36mGenerating whitelist from custom list(s)...\033[0m"
    /usr/bin/awk -F'[#;]' 'match($1,/^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+(\/[0-9]+)?$/) {print $1}' $CUST_WL_FILE >>"$TMP_FILE"
    
    if [ -s "$TMP_FILE" ]; then
      if [ -x "$IPR_BIN" ]; then
        if [ "$($IPR_BIN --common "$BL_FILE" "$TMP_FILE")" ]; then
          [ "$VERBOSE" ] && echo "- Optimizing and reducing netset (using iprange)..."
          $IPR_BIN --ipset-reduce 20 "$TMP_FILE"  > "$WL_FILE"
        else
          echo '- No IP in common with blocklist, skipping whitelist.'
        fi
      else
        [ "$VERBOSE" ] && echo -e "- iprange not installed, passing optimization and reduction process.\n- Removing duplicates..."
        /usr/bin/sort "$TMP_FILE"|/usr/bin/uniq > "$WL_FILE"
      fi
      else echo '- No IP set found, custom whitelist is empty.'
    fi
    /bin/rm -f "$TMP_FILE"
    [ "$VERBOSE" ] && echo "- Done."
  else
    /bin/rm -f "$WL_FILE"
  fi
}

info() {
  echo -e "\033[1;36mInfo:\033[0m"
  if [ -r "$SRC_LIST" ] && [ -d $(dirname "$BL_FILE") ] && [ -d $(dirname "$TMP_FILE") ];
    then echo -n "- '$SC_NAME' version $SC_VERS is installed "; [ "$EXT_DRIVE" ] && echo 'on external drive.' || echo 'on internal drive.'
    else echo -e "\033[31m! Something is wrong with installation!\033[0m"
  fi
  echo -ne "- Checking latest available version...\r"
  SC_LAST_VERS="$(last_avail_version)";
  if [ "$SC_LAST_VERS" ]; then
    _LOC_VERS=$(echo "$SC_VERS"|/bin/sed 's/[^[:digit:]]//g')
    _REM_VERS=$(echo "$SC_LAST_VERS"|/bin/sed 's/[^[:digit:]]//g')
    if [ $_LOC_VERS -eq $_REM_VERS ]; then echo "- This is the last version.            "
    elif [ $_LOC_VERS -lt $_REM_VERS ]; then echo -e "\033[35m- New version available: $SC_LAST_VERS       \033[0m"
    else echo -e "\033[35m- This version is higher than than the one available: $SC_LAST_VERS       \033[0m"
    fi
  else echo -e "\033[31m! Could not check what is the last version online!\033[0m"
  fi
  if check_path
    then echo "- '$SC_NAME' is in PATH."
    else echo "- '$SC_NAME' is not in PATH (you need to use $NICE_PATH)."
  fi
  # check iprange binary
  [ "$IPR_BIN" ] && echo "- 'iprange' is installed: $($IPR_BIN --version | /usr/bin/head -n 1)" || echo "- 'iprange' is not installed."
  # check web compagnon
  check_web && echo "- $WEB_NAME is installed." || echo "- $WEB_NAME is not installed."
}

#---------------------------- _STATUS ----------------------------
# ---------------------------------------------
: ENV START
# ---------------------------------------------
# STATUS VARS
CK_FWS=1             # CK PB
CK_PM=2              # CK PB
CK_IPS_BL=4          # CK PB
CK_IPS_WL=8          # CK PB
CK_IPT_CH=16         # CK PB
CK_IPT_WAN_BP=32     # CK PB WN
CK_IPT_TUN_BP=64     # CK PB WN
CK_IPT_WL=128        # CK PB
CK_IPT_LOG=256       # CK ..
PB_IPT_IFO=256       # .. PB
CK_IPT_TUN=512       # CK PB
CK_IPT_WAN=1024      # CK PB
PB_IPT_WAN_MISS=2048 # .. PB

WN_BL_FILE_DIFF=1   # . . . . . . _ x
WN_BL_FILE_MISS=2   # . . . . . . x _
WN_BL_FILE_NTLD=3   # . . . . . . x x
WN_WL_FILE_DIFF=4   # . . . . _ x . .
WN_WL_FILE_MISS=8   # . . . . x _ . .
WN_WL_FILE_NTLD=12  # . . . . x x . .
WN_TUN_MISS=16      # . . . x . . . .
# 32 CK_IPT_WAN_BP -> WAN BYPASS MISSING
# 64 CK_IPT_TUN_BP -> TUN BYPASS MISSING
WN_LOG_DIFF=128     # x . . . . . . .

CK_MASK=2047 #11 bits
PB_MASK=4095 #12 bits
WN_MASK=255  #8 bits

# ---------------------------------------------
: ENV EOF
# ---------------------------------------------

chain_status() {
  [ "$1" = 'src' ] && { _DIR='-s'; _PUT='-i'; _IPTBL_CH=$IPTBL_SRC; _RULE='DROP'; } || { _DIR='-d'; _PUT='-o'; _IPTBL_CH=$IPTBL_DST; _RULE='REJECT'; }
  _CH_CK=0
  _CH_PB=0
  _CH_IPT="$(echo "$_IPT"|/bin/grep -nF -- "-A $_IPTBL_CH")"
  _SL="$(echo $_CH_IPT|/usr/bin/cut -d: -f1)"
  if [ "$_CH_IPT" ]; then
    _LL=$((_SL+$(echo "$_CH_IPT"|/usr/bin/wc -l)-1))
    if [ "$(echo "$_CH_IPT"|/bin/grep -F -- "-j $_RULE"|/usr/bin/cut -d: -f1)" = $_LL ]; then _CH_CK=$((_CH_CK+CK_IPT_CH))
      _CL=$_SL # current line
      OLDIFS=$IFS; IFS=$'\n'; for _BPL in "$(echo "$_CH_IPT"|/bin/grep -F -- "-m comment --comment \"$SC_ABR inet bypass\"")"; do
        [ -z "$_BPL" ] && break
        [ "$(echo $_BPL|/usr/bin/cut -d: -f1)" != "$_CL" ] && { _CH_PB=$((_CH_PB+CK_IPT_CH)); break 2; }
        case "$_BPL" in
          *"$_DIR $_WAN_INET $_PUT $WAN_IF"*) # we have WAN with correct inet
            if [ $((_CH_CK&CK_IPT_WAN_BP)) = 0 ]; then                          _CH_CK=$((_CH_CK+CK_IPT_WAN_BP))
            elif [ $((_CH_PB&CK_IPT_WAN_BP)) = 0 ]; then                        _CH_PB=$((_CH_PB+CK_IPT_WAN_BP))
            fi ;;
          *"$_PUT $WAN_IF "*) # we have WAN with wrong inet
            [ $((_CH_PB&CK_IPT_WAN_BP)) = 0 ] &&                                _CH_PB=$((_CH_PB+CK_IPT_WAN_BP))
            ;;
          *"$_DIR $_TUN_INET $_PUT $TUN_IF "*)
            if [ $((_CH_CK&CK_IPT_TUN_BP)) = 0 ]; then                          _CH_CK=$((_CH_CK+CK_IPT_TUN_BP))
            elif [ $((_CH_PB&CK_IPT_TUN_BP)) = 0 ]; then                        _CH_PB=$((_CH_PB+CK_IPT_TUN_BP))
            fi ;;
          *"$_PUT $TUN_IF "*) # we have TUN with wrong inet
            [ $((_CH_PB&CK_IPT_TUN_BP)) = 0 ] &&                                _CH_PB=$((_CH_PB+CK_IPT_TUN_BP))
            ;;
          *) # we found a non matching interface
            _CH_PB=$((_CH_PB+CK_IPT_CH)); break 2
            ;;
        esac
        _CL=$((_CL+1))
      done; IFS=$OLDIFS
      if [ "$(echo "$_CH_IPT"|/bin/grep -F -- "$IPSET_WL_NAME"|/usr/bin/cut -d: -f1)" = $_CL ]; then _CH_CK=$((_CH_CK+CK_IPT_WL))
        _CL=$((_CL+1))
      fi
      if [ "$(echo "$_CH_IPT"|/bin/grep -F -- 'LOG'|/usr/bin/cut -d: -f1)" = $_CL ]; then            _CH_CK=$((_CH_CK+CK_IPT_LOG))
        _CL=$((_CL+1))
      fi
      [ $_CL = $_LL ] ||                                                         _CH_PB=$((_CH_PB+CK_IPT_CH))
    else                                                                         _CH_PB=$((_CH_PB+CK_IPT_CH))
    fi
  fi
  [ "$1" = 'src' ] && { _S_CK=$_CH_CK; _S_PB=$_CH_PB; _S_IPT=$_CH_IPT; } || { _D_CK=$_CH_CK; _D_PB=$_CH_PB; _D_IPT=$_CH_IPT; }
}

_status() {
  _CK=0; _WN=0; _PB=0
  _BLC=0; _WLC=0
  _cipset_init
  
  # CHECK ENVIRONMENT
  # check firewall-start.sh script
  check_firewall_start &&                                                        _CK=$((_CK+CK_FWS))
  # check post-mount.sh script if script on external drive
  [ "$EXT_DRIVE" ] && check_postmount &&                                         _CK=$((_CK+CK_PM))

  # CHECK BLOCKLIST (IPS, FILE)
  if _cipset_copy_set $IPSET_BL_NAME; then                                       _CK=$((_CK+CK_IPS_BL))
    _BLC=$(_cipset_count_set $IPSET_BL_NAME)
    if [ -r "$BL_FILE" ]; then
      _cipset_diff_set_file $IPSET_BL_NAME $BL_FILE ||                           _WN=$((_WN+WN_BL_FILE_DIFF))
    else                                                                         _WN=$((_WN+WN_BL_FILE_MISS))
    fi
  elif [ -r "$BL_FILE" ]; then                                                   _WN=$((_WN+WN_BL_FILE_NTLD))
  fi

  # CHECK WHITELIST (IPS, FILE)
  if _cipset_copy_set $IPSET_WL_NAME; then                                       _CK=$((_CK+CK_IPS_WL))
    _WLC=$(_cipset_count_set $IPSET_WL_NAME)
    if [ -r "$WL_FILE" ]; then
      _cipset_diff_set_file $IPSET_WL_NAME $WL_FILE ||                           _WN=$((_WN+WN_WL_FILE_DIFF))
    else                                                                         _WN=$((_WN+WN_WL_FILE_MISS))
    fi
  elif [ -r "$WL_FILE" ]; then                                                   _WN=$((_WN+WN_WL_FILE_NTLD))
  fi

  # CHECK IPTABLES
  get_ipt
  _WAN_INET=$(inet_for_if $WAN_IF)
  [ "$TUN_IF" ] && _TUN_INET=$(inet_for_if $TUN_IF)
  # -- SRC CHAIN
  chain_status src
  # -- DST CHAIN
  chain_status dst
  # -- SRC & DST
  if [ $_S_CK -eq $_D_CK ]; then                                                 _CK=$((_CK+_S_CK))
    if [ $_S_PB -eq $_D_PB ]; then                                               _PB=$((_PB+_S_PB))
    else                                                                         _PB=$((_PB+(_S_PB|_D_PB)))
    fi
  else                                                                           _PB=$((_PB+CK_IPT_CH))                                                                           
  fi
  # -- IFO (INPUT, FORWARD, OUTPUT)
  _IFO_IPT="$(echo "$_IPT"|/bin/grep -F -- "-m set --match-set $IPSET_BL_NAME")"
  if [ "$_IFO_IPT" ]; then
    _TCT=$(echo "$_IFO_IPT"|/usr/bin/wc -l)
    # checking VPN tunnel interface rules
    if [ "$TUN_IF" ]; then
      _CT=$(echo "$_IFO_IPT"|/bin/grep -cF -- "$TUN_IF"); _TCT=$((_TCT-_CT))
      case "$_CT" in
        4)                                                                       _CK=$((_CK+CK_IPT_TUN));;
        0)                                                                       _WN=$((_WN+WN_TUN_MISS));;
        *)                                                                       _PB=$((_PB+CK_IPT_TUN));;
      esac
    fi
    # checking WAN interface rules
    _CT=$(echo "$_IFO_IPT"|/bin/grep -cF -- "$WAN_IF"); _TCT=$((_TCT-_CT))
    case "$_CT" in
      4)                                                                         _CK=$((_CK+CK_IPT_WAN));;
      0)                                                                         _PB=$((_PB+PB_IPT_WAN_MISS));;
      *)                                                                         _PB=$((_PB+CK_IPT_WAN));;
    esac
    # checking if old rules exists or if corrupted
    [ $_TCT -ne 0 ] &&                                                           _PB=$((_PB+PB_IPT_IFO))
  fi

  # DEEPER CHECK
  if [ $_CK -ne 0 ]; then
  # -- PROBLEMS / WARNINGS
    # ENV
    [ $((_CK&CK_FWS)) -eq 0 ] &&                                                 _PB=$((_PB+CK_FWS))
    [ "$EXT_DRIVE" ] && [ $((_CK&CK_PM)) -eq 0 ] &&                              _PB=$((_PB+CK_PM))
    # BL
    [ $((_CK&CK_IPS_BL)) -eq 0 ] &&                                              _PB=$((_PB+CK_IPS_BL))
    # CH
    [ $(((_CK&CK_IPT_CH)+(_PB&CK_IPT_CH))) -eq 0 ] &&                            _PB=$((_PB+CK_IPT_CH))
    if [ $((_PB&CK_IPT_CH)) -eq 0 ]; then
      # BP
      _cipset_inet_in_bl $_WAN_INET && [ $(((_CK|_PB)&CK_IPT_WAN_BP)) -eq 0 ] &&                  _WN=$((_WN+CK_IPT_WAN_BP))
      [ "$TUN_IF" ] && _cipset_inet_in_bl $_TUN_INET && [ $(((_CK|_PB)&CK_IPT_TUN_BP)) -eq 0 ] && _WN=$((_WN+CK_IPT_TUN_BP))
      # WL
      _OK=$((CK_IPS_WL+CK_IPT_WL))
      if [ $((_CK&_OK)) -ne 0 ] && [ $((_CK&_OK)) -ne $_OK ]; then
        [ $((_CK&CK_IPS_WL)) -eq 0 ] &&                                                           _PB=$((_PB+CK_IPS_WL))
        [ $((_CK&CK_IPT_WL)) -eq 0 ] &&                                                           _PB=$((_PB+CK_IPT_WL))
      fi
      # LOG
      if [ $((_PB&CK_IPT_CH)) -eq 0 ]; then if sc_conf get log >/dev/null
        then [ $((_CK&CK_IPT_LOG)) -eq 0 ] &&                                                     _WN=$((_WN+WN_LOG_DIFF))
        else [ $((_CK&CK_IPT_LOG)) -ne 0 ] &&                                                     _WN=$((_WN+WN_LOG_DIFF))
      fi fi
    fi
    # IFO
  fi
  
  _cipset_end
  
  echo -n "$_CK $_PB $_WN $_BLC $_WLC"
}

status_term() {
# variables are already set when calling _status from here. so no need to set variables from stdout here.
#  set -- $(_status); _CK=$1; _PB=$2; _WN=$3; _BLC=$4; _WLC=$5
_status>/dev/null

  echo -e '\033[1;36mStatus:\033[0m'
  if [ $((_CK+_PB)) -eq 0 ]; then
    _RETVAL=1
    echo "- '$SC_NAME' is not active; Settings are clean."
  elif [ $_CK -ne 0 ] && [ $_PB -eq 0 ]; then
    _RETVAL=0
    echo -ne "- \033[1;32m'$SC_NAME' is set and active\033[0m"
    [ $((_CK&CK_IPT_WAN)) -ne 0 ] && echo -n " for WAN interface ($WAN_IF)"
    [ $((_CK&CK_IPT_TUN)) -ne 0 ] && echo -n " and VPN tunnel ($TUN_IF)"
    echo -e ".\n- Filtering $_BLC IP adresses."
    [ $((_CK&CK_IPT_WL)) -ne 0 ] && echo "- Bypassing $_WLC IP adresses."
  else
    _RETVAL=2
    echo -e "- \033[1;31mSomething is not right!\033[0m"
  fi
  
  if [ $_PB -ne 0 ]; then
    echo -ne '\033[1;31mErrors:\033[0m'; [ "$VERBOSE" -ge 2 ] && echo " (CODE: $_PB)" || echo ''
    [ $((_PB&CK_FWS)) -ne 0 ] &&     echo -e "\033[31m- 'firewall-start.sh' is not set properly for $SC_NAME!\033[0m"
    [ $((_PB&CK_PM)) -ne 0 ] &&      echo -e "\033[31m- 'post-mount.sh' is not set properly for $SC_NAME!\033[0m"
    [ $((_PB&CK_IPS_BL)) -ne 0 ] &&  echo -e "\033[31m- ipset: no blocklist is set!\033[0m"
    [ $((_PB&CK_IPS_WL)) -ne 0 ] &&  echo -e "\033[31m- ipset: no whitelist is set!\033[0m"
    [ $((_PB&CK_IPT_CH)) -ne 0 ] &&  echo -e "\033[31m- iptables: engine chains are not right!\033[0m"
    [ $((_PB&CK_IPT_WAN_BP)) -ne 0 ] &&  echo -e "\033[31m- iptables: WAN network range bypass rules are not right!\033[0m"
    [ $((_PB&CK_IPT_TUN_BP)) -ne 0 ] &&  echo -e "\033[31m- iptables: VPN network range bypass rules are not right!\033[0m"
    [ $((_PB&CK_IPT_WL)) -ne 0 ] &&  echo -e "\033[31m- iptables: whitelist rules are not right!\033[0m"
    [ $((_PB&CK_IPT_TUN)) -ne 0 ] &&      echo -e "\033[31m- iptables: VPN tunnel IFO rules are corrupted!\033[0m"
    [ $((_PB&CK_IPT_WAN)) -ne 0 ] &&      echo -e "\033[31m- iptables: WAN interface IFO rules are corrupted!\033[0m"
    [ $((_PB&PB_IPT_WAN_MISS)) -ne 0 ] && echo -e "\033[31m- iptables: WAN interface ($WAN_IF) IFO rules are missing!\033[0m"
    [ $((_PB&PB_IPT_IFO)) -ne 0 ] &&      echo -e "\033[31m- iptables: Extra engine IFO rules were found (likely from an old interface)!\033[0m"
  fi
  
  if [ $((_CK+_PB)) -ne 0 ] && [ $_WN -ne 0 ]; then
    echo -ne '\033[1;35mWarnings:\033[0m'; [ "$VERBOSE" -ge 2 ] && echo " (CODE: $_WN)" || echo ''
    case "$((_WN&WN_BL_FILE_NTLD))" in
      $WN_BL_FILE_DIFF) echo -e "\033[35m- blocklist set is different than file.\033[0m";;
      $WN_BL_FILE_MISS) echo -e "\033[35m- blocklist is set but file is missing.\033[0m";;
      $WN_BL_FILE_NTLD) echo -e "\033[35m- no blocklist is set but file exists.\033[0m";;
    esac
    case "$((_WN&WN_WL_FILE_NTLD))" in
      $WN_WL_FILE_DIFF) echo -e "\033[35m- whitelist set is different than file.\033[0m";;
      $WN_WL_FILE_MISS) echo -e "\033[35m- whitelist is set but file is missing.\033[0m";;
      $WN_WL_FILE_NTLD) echo -e "\033[35m- no whitelist is set but file exists.\033[0m";;
    esac
    [ $((_WN&CK_IPT_WAN_BP)) -ne 0 ] && echo -e "\033[31m- iptables: WAN network range bypass rules are missing!\033[0m"
    [ "$TUN_IF" ] && [ $((_WN&CK_IPT_TUN_BP)) -ne 0 ] && echo -e "\033[31m- iptables: VPN network range bypass rules are missing!\033[0m"
    [ $((_WN&WN_TUN_MISS)) -ne 0 ] && echo -e "\033[31m- iptables: VPN tunnel ($TUN_IF) IFO rules are missing!\033[0m"
    [ $((_WN&WN_LOG_DIFF)) -ne 0 ] && echo -e "\033[35m- current logging settings differs from last time engine was started.\033[0m"
  fi
 
  [ "$VERBOSE" ] || return 0

  echo -ne '\033[1;36mDetailed status:\033[0m'; [ "$VERBOSE" -ge 2 ] && echo " (CODE: $_CK)" || echo ''
  echo "- Active WAN interface is '$WAN_IF'."
  [ "$TUN_IF" ] && echo "- Active VPN tunnel is '$TUN_IF'." || echo "- no VPN tunnel found."
  # dates
  echo "- Actual router time: $(/bin/date +'%Y-%m-%d %X')"
  [ -e "$BL_FILE" ] && echo "- Blocklist generation time: $(/bin/date +'%Y-%m-%d %X' -r $BL_FILE)"
  [ -e "$WL_FILE" ] && echo "- Whitelist generation time: $(/bin/date +'%Y-%m-%d %X' -r $WL_FILE)"
  if [ $_CK -ne 0 ]; then
    [ $((_CK&CK_FWS)) -ne 0 ] &&      echo "- 'firewall-start.sh' is set for $SC_NAME."
    [ $((_CK&CK_PM)) -ne 0 ] &&       echo "- 'post-mount.sh' is set for $SC_NAME."
    [ $((_CK&CK_IPS_BL)) -ne 0 ] &&   echo "- ipset: blocklist is set."
    [ $((_CK&CK_IPS_WL)) -ne 0 ] &&   echo "- ipset: whitelist is set."
    [ $((_CK&CK_IPT_CH)) -ne 0 ] &&   echo "- iptables: engine chains are set."
    [ $((_CK&CK_IPT_WAN_BP)) -ne 0 ] && echo "- iptables: WAN network range bypass rules are set."
    [ $((_CK&CK_IPT_TUN_BP)) -ne 0 ] && echo "- iptables: VPN network range bypass rules are set."
    [ $((_CK&CK_IPT_WL)) -ne 0 ] &&   echo "- iptables: whitelist rules are set."
    [ $((_CK&CK_IPT_LOG)) -ne 0 ] &&  echo "- iptables: $SC_NAME logging is on."
    [ $((_CK&CK_IPT_TUN)) -ne 0 ] &&  echo "- iptables: VPN tunnel IFO rules are set."
    [ $((_CK&CK_IPT_WAN)) -ne 0 ] &&  echo "- iptables: WAN interface IFO rules are set."
  fi
  
  [ "$VERBOSE" -lt 2 ] && return 0

  # Status file
  echo -ne "\033[1;36m'$SC_NAME' engine last launch report:\033[0m"
  if [ -r "$INFO_FILE" ]; then
    read INFO INFO_WAN INFO_TUN<"$INFO_FILE"
    INFO_FROM=$((INFO&INFO_FROM_MASK))
    INFO_IPS=$(((INFO>>INFO_IPS_SHIFT)&INFO_IPS_MASK))
    INFO_IPT=$(((INFO>>INFO_IPT_SHIFT)&INFO_IPT_MASK))
    echo " (CODE: $INFO_FROM-$INFO_IPS-$INFO_IPT)"
    case "$INFO_FROM" in
      $INFO_FROM_SC) FROM="$SC_NAME script" ;;
      $INFO_FROM_PM) FROM="post-mount.sh" ;;
      $INFO_FROM_FWS) FROM="firewall-start.sh" ;;
    esac
    echo "- engine was launched from: $FROM @ $(/bin/date +'%Y-%m-%d %X' -r $INFO_FILE)"
    echo "- WAN interface was '$INFO_WAN'."
    [ "$INFO_TUN" ] && echo "- VPN tunnel was '$INFO_TUN'." || echo '- No VPN tunnel was found.'
    case $((INFO_IPS&INFO_IPS_BL_MASK)) in
      0) echo '! blocklist file was not found!' ;;
      $INFO_IPS_BL_SAME) echo '- ipset: blocklist was already set and identical to file.' ;;
      $INFO_IPS_BL_MISS) echo '- ipset: blocklist file was not found! The one already set was kept.' ;;
      $INFO_IPS_BL_LOAD) echo '- ipset: blocklist was set from file.' ;;
    esac
    case $((INFO_IPS&INFO_IPS_WL_MASK)) in
      0) echo '- no whitelist file was found.' ;;
      $((INFO_IPS_WL_SAME+INFO_IPS_WL_KEEP))) echo '- ipset: whitelist was already set and identical to file.' ;;
      $INFO_IPS_WL_KEEP) echo '- ipset: whitelist was kept.' ;;
      $INFO_IPS_WL_LOAD) echo '- ipset: whitelist was set from file.' ;;
      $INFO_IPS_WL_SWAP) echo '- ipset: whitelist was updated from file.' ;;
      $INFO_IPS_WL_DEL) echo '- ipset: whitelist was unset.' ;;
    esac
    if [ $((INFO_IPT & INFO_IPT_SRC_KEEP)) -eq 0 ]
      then echo "- iptables: engine inbound chain was set."
      else echo "- iptables: engine inbound chain was already set."
    fi
    if [ $((INFO_IPT & INFO_IPT_DST_KEEP)) -eq 0 ]
      then echo '- iptables: engine outbound chain was set.'
      else echo '- iptables: engine outbound chain was already set.'
    fi
    [ $((INFO_IPT & INFO_IPT_IB_PBM)) -ne 0 ] && echo '- iptables: some irrelevant bypass rules had to be removed.'
    if [ $((INFO_IPS & INFO_IPS_WB_NDD)) -ne 0 ]; then
      if [ $((INFO_IPT & INFO_IPT_WB_SRC_NEW)) -ne 0 ]
        then echo '- iptables: inbound WAN network range bypass rules were set.'
        else echo '- iptables: inbound WAN network range bypass rules were kept.'
      fi
      if [ $((INFO_IPT & INFO_IPT_WB_DST_NEW)) -ne 0 ]
        then echo '- iptables: outbound WAN network range bypass rules were set.'
        else echo '- iptables: outbound WAN network range bypass rules were kept.'
      fi
    else echo '- iptables: WAN network range bypass rules were not needed or manually skipped.'
    fi
    if [ $((INFO_IPS & INFO_IPS_TB_NDD)) -ne 0 ]; then
      if [ $((INFO_IPT & INFO_IPT_TB_SRC_NEW)) -ne 0 ]
        then echo '- iptables: inbound VPN network range bypass rules were set.'
        else echo '- iptables: inbound VPN network range bypass rules were kept.'
      fi
      if [ $((INFO_IPT & INFO_IPT_TB_DST_NEW)) -ne 0 ]
        then echo '- iptables: outbound VPN network range bypass rules were set.'
        else echo '- iptables: outbound VPN network range bypass rules were kept.'
      fi
    else [ "$INFO_TUN" ] && echo '- iptables: VPN network range bypass rules were not needed or manually skipped.'
    fi
    if [ $((INFO_IPT & INFO_IPT_WL)) -ne 0 ]; then
      if [ $((INFO_IPT & INFO_IPT_WL_SRC_NEW)) -ne 0 ]
        then echo '- iptables: inbound whitelist rules were set.'
        else echo '- iptables: inbound whitelist rules were kept.'
      fi
      if [ $((INFO_IPT & INFO_IPT_WL_DST_NEW)) -ne 0 ]
        then echo '- iptables: outbound whitelist rules were set.'
        else echo '- iptables: outbound whitelist rules were kept.'
      fi
    fi
    if [ $((INFO_IPT & INFO_IPT_LOG)) -ne 0 ]; then
      if [ $((INFO_IPT & INFO_IPT_LOG_SRC_NEW)) -ne 0 ]
        then echo '- iptables: inbound logging rules were set.'
        else echo '- iptables: inbound logging rules were kept.'
      fi
      if [ $((INFO_IPT & INFO_IPT_LOG_DST_NEW)) -ne 0 ]
        then echo '- iptables: outbound logging rules were set.'
        else echo '- iptables: outbound logging rules were kept.'
      fi
    fi
    
    [ $((INFO_IPT & INFO_IPT_IFO_PBM)) -ne 0 ] && echo '- iptables: some irrelevant IFO rules had to be removed.'
    if [ $((INFO_IPT & INFO_IPT_WAN_PBM)) -eq $INFO_IPT_WAN_PBM ]; then echo '- iptables: WAN interface IFO rules had to be reset.'
    elif [ $((INFO_IPT & INFO_IPT_WAN_NEW)) -ne 0 ]; then echo '- iptables: WAN interface IFO rules were set.'
    elif [ $((INFO_IPT & INFO_IPT_WAN_KEEP)) -ne 0 ]; then echo '- iptables: WAN interface IFO rules were kept.'
    fi
    if [ $((INFO_IPT & INFO_IPT_TUN_PBM)) -eq $INFO_IPT_TUN_PBM ]; then echo '- iptables: VPN tunnel IFO rules had to be reset.'
    elif [ $((INFO_IPT & INFO_IPT_TUN_NEW)) -ne 0 ]; then echo '- iptables: VPN tunnel IFO rules were set.'
    elif [ $((INFO_IPT & INFO_IPT_TUN_KEEP)) -ne 0 ]; then echo '- iptables: VPN tunnel IFO rules were kept.'
    fi
    
    echo -ne "\033[0m"
  else
    echo -e '\n- No status file found.'
  fi
  
  [ "$VERBOSE" -lt 3 ] && return 0
  
  if [ $((_CK+_PB)) -ne 0 ]; then
    echo -e "\033[1;36miptables:\033[0m"
    [ -z "$_IPT" ] && echo "- no $SC_NAME rules are set." || echo "$_IPT"|/bin/sed 's/^/- iptables /'
    ipset -L -n|/bin/grep -F -- "$SC_ABR"|while read _SET; do
      case "$_SET" in
        "$IPSET_BL_NAME") _NAME='blocklist' ;;
        "$IPSET_WL_NAME") _NAME='whitelist' ;;
        *) _NAME="$_SET" ;;
      esac
      echo -e "\033[1;36mipset '$_NAME':\033[0m"
      ipset -L -t $_SET|/bin/sed 's/^/- /'
    done
  fi
}

status_raw() {
  echo "$(_status) '$WAN_IF' '$TUN_IF'"; exit 0
}
#---------------------------- END _STATUS ----------------------------

print_help() {
  echo -e "\033[1;36m$SC_NAME $SC_VERS\033[0m"
  echo -e "Usage: \033[1m$SC_NAME \033[35mCOMMAND \033[36m[OPTION(S)]\033[0m"
  echo -e "\033[7mCOMMANDS (use only one):\033[0m"
  echo -e " \033[1;35mrestart\033[0m        - restarts internal firewall and $SC_NAME engine"
  echo -e " \033[1;35mupdate_set\033[0m     - updates set from servers in '$SRC_LIST'"
  echo -e " \033[1;35mload_set\033[0m       - reloads $SC_NAME engine with last generated set"
  echo -e " \033[1;35mupdate\033[0m         - updates set then reloads $SC_NAME engine with it \033[1;36m[probably what you want to use]\033[0m"
  echo -e " \033[1;35mclean\033[0m          - removes $SC_NAME engine from internal firewall and restarts it"
  echo -e " \033[1;35mhelp\033[0m           - displays help (this)"
  echo -e " \033[1;35minfo\033[0m           - displays info on this script"
  echo -e " \033[1;35mstatus\033[0m         - displays status"
  echo -e " \033[1;35mlog\033[0m            - displays log"
  echo -e " \033[1;35mupgrade\033[0m        - downloads and installs latest version"
  echo -e " \033[1;35mweb -install\033[0m   - downloads and installs $WEB_NAME"
  echo -e " \033[1;35mweb -remove\033[0m    - removes $WEB_NAME"
  echo -e "\033[7mOPTIONS (none, one or more):\033[0m"
  echo -e " \033[7;34mGENERAL OPTIONS\033[0m (can be used with any command):"
  echo -e " \033[1;36m-v\033[0m             - verbose mode (level 1)"
  echo -e " \033[1;36m-vv\033[0m            - verbose mode (level 2)"
  echo -e " \033[1;36m-vvv\033[0m           - verbose mode (level 3)"
  echo -e " \033[1;36m-q\033[0m             - quiet mode (no output)"
  echo -e " \033[7;34mENGINE OPTIONS\033[0m (to use with \033[1;35mrestart\033[0m, \033[1;35mload_set\033[0m or \033[1;35mupdate\033[0m):"
  echo -e " \033[1;36m-log\033[0m           - will enable logging"
  echo -e " \033[1;36m-wan_no_bypass\033[0m - will not set the WAN network range bypass"
  echo -e " \033[1;36m-vpn_no_bypass\033[0m - will not set the VPN network range bypass"
  echo -e " \033[7;34mDISPLAY LOG OPTIONS\033[0m (to use with \033[1;35mlog\033[0m):"
  echo -e " \033[1;36m-lines=\033[0mN       - will display N lines (N being the number of lines to show)"
  echo -e " \033[7;34mCLEANING OPTIONS\033[0m (to use with \033[1;35mclean\033[0m):"
  echo -e " \033[1;36m-rm-config\033[0m     - removes $SC_NAME configuration file"
  echo -e " \033[1;36m-rm-symlink\033[0m    - removes the symlink /usr/bin/$SC_NAME"
  echo -e " \033[1;36m-rm-web\033[0m        - removes $WEB_NAME"
}

###############################################
#
#    MAIN ROUTINE
#
###############################################
_RETVAL=0

[ $# = 0 ] && { >&2 echo -e "\033[31m! No parameter!\033[0m"; print_help; exit 1; }
[ "$1" = "_pm" ] && [ "$2" ] && _pm

ARGS=" $* "

if [ -z "${ARGS##* %devmode*% *}" ]; then
  if [ "${ARGS##* %devmode% *}" ]; then
    _DEV="$(echo "$ARGS"|/bin/sed 's/[^%]*%devmode \([^%]*\)%[^%]*/\1/')"
    echo "dev: '$_DEV'"
    if [ -z "${_DEV##*cmd=*}" ]; then
      _CMD="$(echo "$_DEV"|/bin/sed 's/.*cmd=\([^,$]*\).*/\1/')"
      echo "Executing command: '$_CMD'"
      eval "$_CMD"
    fi
    if [ -z "${_DEV##*repo=*}" ]; then
      _REPO="$(echo "$_DEV"|/bin/sed 's/.*repo=\([^,$]*\).*/\1/')"
      SC_DEV_REPO="$SC_BASE_REPO/$_REPO"
      echo "Using git path: '$SC_DEV_REPO'"
    fi
  fi
  DEVMODE=1
  ARGS="${ARGS% %devmode*% *} ${ARGS#* %devmode*% }"
  echo "Arguments: '$ARGS'"
fi

PARAM="$(echo "$ARGS" | /bin/sed 's/-[[:alpha:]=]*[[:space:]]*[[:digit:]]*//g')"
case $(echo "$PARAM"|/usr/bin/wc -w) in
  0) >&2 echo -e "\033[31m! No parameter!\033[0m"; print_help; exit 1 ;;
  1) PARAM="$(echo "$PARAM"|/bin/sed 's/ //g')" ;;
  *) >&2 echo -e "\033[31m! Too many parameters!\033[0m"; print_help; exit 1 ;;
esac

[ -z "${ARGS##* -v *}" ] && VERBOSE=1
[ -z "${ARGS##* -vv *}" ] && VERBOSE=2
[ -z "${ARGS##* -vvv *}" ] && VERBOSE=3
[ -z "${ARGS##* -q *}" ] && QUIET=1
_engine_args() {
  [ -z "${ARGS##* -log *}" ]           && sc_conf set log=1 || sc_conf delete log
  [ -z "${ARGS##* -wan_no_bypass *}" ] && sc_conf set wan.no_bypass=1 || sc_conf delete wan.no_bypass
  [ -z "${ARGS##* -vpn_no_bypass *}" ] && sc_conf set tun.no_bypass=1 || sc_conf delete tun.no_bypass
}
_clean_args() {
  [ -z "${ARGS##* -rm-config *}" ]     && RM_CONF=1
  [ -z "${ARGS##* -rm-symlink *}" ]    && RM_SYMLINK=1
  [ -z "${ARGS##* -rm-web *}" ]        && RM_WEB=1
}

sc_conf commit

[ "$QUIET" ] && exec>/dev/null

pre_init

if [ $DEVMODE ]; then echo -e "\033[7;31m$SC_NAME $SC_VERS - Developer mode\033[0m"; VERBOSE=3
elif [ $VERBOSE ]; then echo -e "\033[7;31m$SC_NAME $SC_VERS - Verbose mode [level $VERBOSE]\033[0m"; fi

case "$PARAM" in
  # engine commands
    'restart') _engine_args; init; fw_restart; [ $VERBOSE ] && status_term ;;
    'load_set') _engine_args; init; set_ipset; [ $VERBOSE ] && status_term ;;
    'update') _engine_args; init; update_iplist; set_ipset; [ $VERBOSE ] && status_term ;;
  'update_set') update_iplist ;;
  'clean') _clean_args; clean; [ $VERBOSE ] && status_term ;;
  'status') status_term ;;
  'help') print_help ;;
  'info') info ;;
  'log') [ -z "${ARGS##* -lines=[0-9]*}" ] && _PL=$(echo "$ARGS"|/bin/sed 's/.* -lines=\([[:digit:]]\+\) .*/\1/') || _PL=''; print_log $_PL ;;
  'upgrade') upgrade ;;
  'web') [ -z "${ARGS##* -install *}" ] && install_web; [ -z "${ARGS##* -remove *}" ] && clean_web ;;
  # calls for outside helpers (html)
  '_status') status_raw ;;
  '_restart') _engine_args; VERBOSE=1; init; fw_restart ;;
  '_update') _engine_args; VERBOSE=1; init; update_iplist; set_ipset ;;
  '_clean') VERBOSE=1; clean ;;
  '_upgrade') _upgrade ;;
  
  *) >&2 echo -e "\033[31m! Unknown Parameter $2!\033[0m"; print_help; exit 1 ;;
esac

exit $_RETVAL
