#! /bin/sh

SC_NAME="aegis"
SC_ABR="aegis"
IPTBL_SRC="${SC_ABR}_src"
IPTBL_DST="${SC_ABR}_dst"
[ "$(nvram get aegis_log)" = "1" ] && IPTBL_LOGGING='y' || IPTBL_LOGGING=''
IPSET_BL_NAME="${SC_ABR}_bl"
IPSET_WL_NAME="${SC_ABR}_wl"
IPSET_WG_NAME="${SC_ABR}_wg"
ROOT_DIR="/opt/bolemo"
BL_FILE="$ROOT_DIR/etc/${SC_NAME}-bl.netset"
WL_FILE="$ROOT_DIR/etc/${SC_NAME}-wl.netset"
INFO_FILE="/tmp/${SC_ABR}_status"
WAN_IF="$(nvram get wan_ifname)"
WAN_GW="$(nvram get wan_gateway)"
WAN_NM="$(nvram get wan_netmask)"
# VPN tunnel detection
if ifconfig|grep -qF 'wg0'; then
  # WireGuard
  TUN_IF='wg0'
elif ps -w|grep -vE 'grep|server_tap|server_tun'|grep -qF -- '/usr/sbin/openvpn --dev'; then
  # Open VPN client
  TUN_IF="$(ps -w|grep -F -- '/usr/sbin/openvpn --dev'|grep -vE 'grep|server_tap|server_tun'|sed -n -- 's/.*openvpn --dev \([[:alnum:]]*\).*/\1/p')"
else
  # No tunneling
  TUN_IF=''
fi
INFO_IPS_BL_LOAD='1'
INFO_IPS_BL_NEW='2'
INFO_IPS_BL_KEEP='3'
INFO_IPS_BL_WGW='4'
INFO_IPS_WL_LOAD='5'
INFO_IPS_WL_KEEP='7'
INFO_IPS_WG_ADD='8'
INFO_IPS_WG_KEEP='9'
INFO_IPT_SRC_KEEP='a'
INFO_IPT_DST_KEEP='b'
INFO_IPT_LOG='c'
INFO_IPT_WL='d'
INFO_IPT_WG='f'
INFO_IPT_WAN='e'
INFO_IPT_TUN='g'
INFO_IPT_WAN_PBM='h'
INFO_IPT_TUN_PBM='i'
INFO_IPT_WG_PBM='j'

_fws() {
  :> "$INFO_FILE"

  # creating ipset blocklist if needed
  if ipset -q -n list "$IPSET_BL_NAME">/dev/null; then echo "$INFO_IPS_BL_KEEP" >> "$INFO_FILE"
  else
    if [ -r "$BL_FILE" ]; then
    # netset file exists, so creating blocklist ipset from it
      echo -e "create $IPSET_BL_NAME hash:net family inet maxelem $(wc -l < "$BL_FILE")\n$(sed "s/^/add $IPSET_BL_NAME /" "$BL_FILE")" | ipset restore
      echo "$INFO_IPS_BL_LOAD" >> "$INFO_FILE"
    else
    # no netset file, creating empty blocklist ipset
      ipset -q create "$IPSET_BL_NAME" hash:net family inet
      echo "$INFO_IPS_BL_NEW" >> "$INFO_FILE"
    fi
  fi
  
  # checking if WAN gateway is in blocklist
  if [ "$WAN_GW" != '0.0.0.0' ] && ipset -q test "$IPSET_BL_NAME" "$WAN_GW"; then
    _WG='y'
    echo "$INFO_IPS_BL_WGW" >> "$INFO_FILE"
    if ! ipset -q test "$IPSET_WG_NAME" "$WAN_GW"; then
      # Calculate WAN_RANGE (IP & CIDR)
      _CIDR=0
      for _OCTET in $(echo "$WAN_NM"| sed 's/\./ /g'); do
        _BINBITS=$(echo "obase=2; ibase=10; ${_OCTET}"| bc | sed 's/0//g')
        let _CIDR+=${#_BINBITS}
      done
      WAN_RANGE="$WAN_GW/$_CIDR"
      ipset -q create "$IPSET_WG_NAME" hash:net family inet
      ipset -q flush "$IPSET_WG_NAME"
      ipset -q add "$IPSET_WG_NAME" "$WAN_RANGE"
      echo "$INFO_IPS_WG_ADD" >> "$INFO_FILE"
    else
      echo "$INFO_IPS_WG_KEEP" >> "$INFO_FILE"
    fi
  fi
  
  # creating ipset whitelist if needed
  if ipset -q -n list "$IPSET_WL_NAME">/dev/null; then
    # ipset whitelist is already in place
    if [ -r "$WL_FILE" ]; then
      # we want to keep it
      _WL='y'
      echo "$INFO_IPS_WL_KEEP" >> "$INFO_FILE"
    else
      # we need to remove it
      ipset -q destroy "$IPSET_WL_NAME"
    fi
  else
    if [ -r "$WL_FILE" ]; then
      # netset file exists, so creating whitelist ipset from it
      _WL='y'
      echo -e "create $IPSET_WL_NAME hash:net family inet\n$(sed "s/^/add $IPSET_WL_NAME /" "$WL_FILE")" | ipset restore
      echo "$INFO_IPS_WL_LOAD" >> "$INFO_FILE"
    else
      # no need for whitelist, just destroy if exists
      ipset -q destroy "$IPSET_WL_NAME"
    fi
  fi

  #Creating our iptables chains if not already set
  iptables -L "$IPTBL_SRC" >/dev/null 2>/dev/null && echo "$INFO_IPT_SRC_KEEP" >> "$INFO_FILE" || iptables -N "$IPTBL_SRC"
  iptables -L "$IPTBL_DST" >/dev/null 2>/dev/null && echo "$INFO_IPT_DST_KEEP" >> "$INFO_FILE" || iptables -N "$IPTBL_DST"
  
  if [ "$IPTBL_LOGGING" ]; then
    iptables -S "$IPTBL_SRC" | grep -qF -- "-j LOG" || iptables -A "$IPTBL_SRC" -j LOG --log-prefix "[$SC_NAME] "
    iptables -S "$IPTBL_DST" | grep -qF -- "-j LOG" || iptables -A "$IPTBL_DST" -j LOG --log-prefix "[$SC_NAME] "
    echo "$INFO_IPT_LOG" >> "$INFO_FILE"
  else
    iptables -D "$IPTBL_SRC" -j LOG --log-prefix "[$SC_NAME] " 2>/dev/null
    iptables -D "$IPTBL_DST" -j LOG --log-prefix "[$SC_NAME] " 2>/dev/null
  fi
  iptables -S "$IPTBL_SRC" | grep -qF -- "-j DROP" || iptables -A "$IPTBL_SRC" -j DROP
  iptables -S "$IPTBL_DST" | grep -qF -- "-j DROP" || iptables -A "$IPTBL_DST" -j DROP
  
  if [ "$_WL" ]; then
    # apply whitelist
    iptables -S "$IPTBL_SRC" | grep -qF -- "$IPSET_WL_NAME" || iptables -I "$IPTBL_SRC" -m set --match-set "$IPSET_WL_NAME" src -j ACCEPT
    iptables -S "$IPTBL_DST" | grep -qF -- "$IPSET_WL_NAME" || iptables -I "$IPTBL_DST" -m set --match-set "$IPSET_WL_NAME" dst -j ACCEPT
    echo "$INFO_IPT_WL" >> "$INFO_FILE"
  else
    #Removing any trace of whitelist if any
    iptables -S 2>/dev/null | grep -F -- "$IPSET_WL_NAME" | sed 's/^-A/iptables -D/' | while read _CMD; do "$_CMD 2>/dev/null"; done
  fi
  
  #########
  if [ "$_WG" ]; then
    # apply whitelist
    iptables -S "$IPTBL_SRC" | grep -qF -- "$IPSET_WG_NAME" || iptables -I "$IPTBL_SRC" -i $WAN_IF -m set --match-set "$IPSET_WG_NAME" src -j ACCEPT
    iptables -S "$IPTBL_DST" | grep -qF -- "$IPSET_WG_NAME" || iptables -I "$IPTBL_DST" -o $WAN_IF -m set --match-set "$IPSET_WG_NAME" dst -j ACCEPT
    echo "$INFO_IPT_WG" >> "$INFO_FILE"
  else
    #Removing any trace of WAN gareway whitelist if any
    iptables -S 2>/dev/null | grep -F -- "$IPSET_WG_NAME" | sed 's/^-A/iptables -D/' | while read _CMD; do "$_CMD 2>/dev/null"; done
  fi
  #########
  
  # creating the required iptables rules for wan interface
  _CT=$(iptables -S 2>/dev/null | grep -cF -- "$WAN_IF -m set --match-set $IPSET_BL_NAME")
  if [ $_CT -ne 4 ]; then
    if [ $_CT -ne 0 ]; then
      # something is messed up with rules; deleting what is left
      iptables -S 2>/dev/null | grep -F -- "$WAN_IF -m set --match-set $IPSET_BL_NAME" | sed 's/^-A/iptables -D/' | while read _CMD; do "$_CMD 2>/dev/null"; done
      echo "$INFO_IPT_WAN_PBM" >> "$INFO_FILE"
    fi
    iptables -I INPUT 1 -i $WAN_IF -m set --match-set "$IPSET_BL_NAME" src -j "$IPTBL_SRC"
    iptables -I OUTPUT 1 -o $WAN_IF -m set --match-set "$IPSET_BL_NAME" dst -j "$IPTBL_DST"
    iptables -I FORWARD 1 -i $WAN_IF -m set --match-set "$IPSET_BL_NAME" src -j "$IPTBL_SRC"
    iptables -I FORWARD 2 -o $WAN_IF -m set --match-set "$IPSET_BL_NAME" dst -j "$IPTBL_DST"
    echo "$INFO_IPT_WAN" >> "$INFO_FILE"
  fi
  
  # creating the required iptables WAN gateway whitelist rules for wan interface if needed
#  if [ "$_WG" ]; then
#    _CT=$(iptables -S 2>/dev/null | grep -cF -- "$WAN_IF -m set --match-set $IPSET_WG_NAME")
#    if [ $_CT -ne 4 ]; then
#      if [ $_CT -ne 0 ]; then
        # something is messed up with rules; deleting what is left
#        iptables -S 2>/dev/null | grep -F -- "$WAN_IF -m set --match-set $IPSET_WG_NAME" | sed 's/^-A/iptables -D/' | while read _CMD; do "$_CMD 2>/dev/null"; done
#        echo "$INFO_IPT_WG_PBM" >> "$INFO_FILE"
#      fi
#      iptables -I INPUT 1 -i $WAN_IF -m set --match-set "$IPSET_WG_NAME" src -j ACCEPT
#      iptables -I OUTPUT 1 -o $WAN_IF -m set --match-set "$IPSET_WG_NAME" dst -j ACCEPT
#      iptables -I FORWARD 1 -i $WAN_IF -m set --match-set "$IPSET_WG_NAME" src -j ACCEPT
#      iptables -I FORWARD 3 -o $WAN_IF -m set --match-set "$IPSET_WG_NAME" dst -j ACCEPT
#      echo "$INFO_IPT_WG" >> "$INFO_FILE"
#    fi
#  fi
  
  # creating the required iptables rules for vpn tunnel interface (if needed)
  if [ "$TUN_IF" ]; then
    _CT=$(iptables -S 2>/dev/null | grep -cF -- "$TUN_IF -m set --match-set $IPSET_BL_NAME")
    if [ $_CT -ne 4 ]; then
      if [ $_CT -ne 0 ]; then
        # something is messed up with rules; deleting what is left
        iptables -S 2>/dev/null | grep -F -- "$TUN_IF -m set --match-set $IPSET_BL_NAME" | sed 's/^-A/iptables -D/' | while read _CMD; do "$_CMD 2>/dev/null"; done
        echo "$INFO_IPT_TUN_PBM" >> "$INFO_FILE"
      fi
      iptables -I INPUT 2 -i $TUN_IF -m set --match-set "$IPSET_BL_NAME" src -j "$IPTBL_SRC"
      iptables -I OUTPUT 2 -o $TUN_IF -m set --match-set "$IPSET_BL_NAME" dst -j "$IPTBL_DST"
      iptables -I FORWARD 2 -i $TUN_IF -m set --match-set "$IPSET_BL_NAME" src -j "$IPTBL_SRC"
      iptables -I FORWARD 3 -o $TUN_IF -m set --match-set "$IPSET_BL_NAME" dst -j "$IPTBL_DST"
      echo "$INFO_IPT_TUN" >> "$INFO_FILE"
    fi
  fi
}

#we are called from firewall_start.sh
if [ "$1" ] && [ "$1" = "_fws" ]; then
  _fws
  exit 0
fi

#when called from post-mount.sh
_pm() {
#  sleep 1
  [ -e /opt/bolemo ] || /bin/ln -sf /tmp/mnt/$2/bolemo /opt/bolemo
  init
  _fws
  exit 0
}

SC_VERS="1.1.0"
SC_PATH="$(cd "$(dirname "$0")" >/dev/null 2>&1 ; pwd -P)"
IPR_BIN="$(command -v iprange)"
IPSET_TMP="${IPSET_BL_NAME}_tmp"
SC_NICEPATH="$ROOT_DIR/scripts/$SC_NAME"
SRC_LIST="$ROOT_DIR/etc/$SC_NAME.sources"
CUST_BL_FILE="$ROOT_DIR/etc/$SC_NAME.custom-blacklist.netset"
CUST_WL_FILE="$ROOT_DIR/etc/$SC_NAME.custom-whitelist.netset"
TMP_FILE="/tmp/$SC_NAME.tmp"
FWS_DIR="/opt/scripts"
FWS_FILE="$FWS_DIR/firewall-start.sh"
# Check if scriot is installed on USB
if echo "$SC_PATH" | grep -q '^/tmp/mnt/'; then
  PM_DIR="$(echo "$SC_PATH" | sed "s|\(/tmp/mnt/[[:alnum:]]*\)/.*|\1|")/autorun/scripts"
  PM_FILE="$PM_DIR/post-mount.sh"
  EXT_DRIVE='y'
else
  EXT_DRIVE=''
fi

upgrade() {
  echo -e "\033[1;36mUpgrading:\033[0m"
  echo "- Version installed: $SC_VERS"
  if [ "$DEVMODE" ]; then
    echo "- Devmode on, force downloading dev version..."
    UPGRADE_URL="https://raw.githubusercontent.com/bolemo/aegis/dev/aegis"
  else
    echo -ne "- Checking latest available version...\r"
    SC_LAST_VERS="$(last_avail_version)";
    if [ "$SC_LAST_VERS" ]
      then if [ "$SC_VERS" = "$SC_LAST_VERS" ]
        then echo "- This is already the last version.         "; exit 0
        else echo "- Version found: $SC_LAST_VERS                    "
      fi
      else
        >&2 echo -e "\033[31m! Could not check what is the last version online!\033[0m"
        exit 1
    fi
    UPGRADE_URL="https://raw.githubusercontent.com/bolemo/aegis/master/aegis"
  fi
  if [ ! "$DEVMODE" ]; then
    echo -n "? Do you want to upgrade from $SC_VERS to $SC_LAST_VERS (y/n)? "
    case "$(i=0;while [ $i -lt 2 ];do i=$((i+1));read -p "" yn </dev/tty;[ -n "$yn" ] && echo "$yn" && break;done)" in Y|y|yes|Yes|YES) : ;; *) exit 0 ;; esac
  fi
  echo "- Downloading:"

  DL_PATH="/tmp/$SC_NAME.dl"
  _PROG='--show-progress';
  [ "$DEVMODE" ] && _PROG="--no-cache $_PROG"
  echo -ne "\033[35m"
  if wget -qO "$DL_PATH" $_PROG "$UPGRADE_URL"; then
    \mv "$DL_PATH" "$SC_NICEPATH"
    chmod +x "$SC_NICEPATH"
    echo -e "\033[0m- Script installed to $SC_NICEPATH"
  else
    echo -ne "\033[0m"
    >&2 echo -e "\033[31m! Wget error code $?! Could not download $DL_PATH\033[0m"
    rm -f "$DL_PATH"
    exit 1
  fi

  exit 0
}

check_firewall_start() {
  [ -x $FWS_FILE ] || return 1
  [ "$(sed 's/[[:space:]]\+/ /g' $FWS_FILE | grep -c -- "\[ -x $SC_NICEPATH \] && $SC_NICEPATH _fws")" = 1 ] || return 1
  return 0
}

create_firewall_start() {
  [ -d "$FWS_DIR" ] || mkdir -p "$FWS_DIR"
  [ -e "$FWS_FILE" ] && sed -i "/$SC_NAME/d" "$FWS_FILE"
  echo -e "# Bolemo $SC_NAME\n[ -x $SC_NICEPATH ] && $SC_NICEPATH _fws" >> "$FWS_FILE"
  [ -x "$FWS_FILE" ] || chmod +x "$FWS_FILE"
}

check_postmount() {
  [ -x "$PM_FILE" ] || return 1
  [ "$(sed 's/[[:space:]]\+/ /g' $PM_FILE | grep -c -- "\[ -x $SC_NICEPATH \] && $SC_NICEPATH _pm \$1")" = 1 ] || return 1
  return 0
}

create_postmount() {
  [ "$EXT_DRIVE" ] || return 1
  [ -d "$PM_DIR" ] || mkdir -p "$PM_DIR"
  [ -e "$PM_FILE" ] && sed -i "/$SC_NAME/d" "$PM_FILE"
  echo -e "# Bolemo $SC_NAME\n[ -x $SC_NICEPATH ] && $SC_NICEPATH _pm \$1" >> "$PM_FILE"
  [ -x "$PM_FILE" ] || chmod +x "$PM_FILE"
}

check_path() {
  command -v "$SC_NAME" > /dev/null && return 0 || return 1
}

set_path() {
  [ -e "/usr/bin/$SC_NAME" ] || ln -s "/opt/bolemo/scripts/$SC_NAME" "/usr/bin/$SC_NAME"
}

remove_path() {
  if [ -e "/usr/bin/$SC_NAME" ]; then
    rm "/usr/bin/$SC_NAME" 2>/dev/null
    [ "$VERBOSE" ] && echo "- '/usr/bin' symlink was removed."
  fi
}

last_avail_version() {
  wget -qO- 'https://raw.githubusercontent.com/bolemo/aegis/master/version'
}

count_ip_in_file() {
  if [ -x "$IPR_BIN" ]
    then $IPR_BIN -C "$1" | sed -n 's/.*,//p'
    else grep -oE '(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\/([0-9]{1,2})' "$1" | awk -F / '{ count[$2]++ } END { for (mask in count) total+=count[mask]*2^(32-mask); print total }'
  fi
}

count_ip_in_ipset() {
  if [ -x "$IPR_BIN" ]
    then ipset list "$1" | sed -n '/Members:/,$p' | tail -n +2 | $IPR_BIN -C | sed -n 's/.*,//p'
    else ipset list "$1" | sed -n '/Members:/,$p' | tail -n +2 | grep -oE '(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\/([0-9]{1,2})' | awk -F / '{ count[$2]++ } END { for (mask in count) total+=count[mask]*2^(32-mask); print total }'
  fi
}

info() {
  echo -e "\033[1;36mInfo:\033[0m"
  if [ -r "$SRC_LIST" ] && [ -d $(dirname "$BL_FILE") ] && [ -d $(dirname "$TMP_FILE") ];
    then echo -n "- '$SC_NAME' version $SC_VERS is installed "; [ "$EXT_DRIVE" ] && echo 'on external drive.' || echo 'on internal drive.'
    else echo -e "\033[31m! Something is wrong with installation!\033[0m"
  fi
  echo -ne "- Checking latest available version...\r"
  SC_LAST_VERS="$(last_avail_version)";
  if [ "$SC_LAST_VERS" ]
    then if [ "$SC_VERS" = "$SC_LAST_VERS" ]
      then echo "- This is the last version.            "
      else echo -e "\033[35m- Lastest version available: $SC_LAST_VERS       \033[0m"
    fi
    else echo -e "\033[31m! Could not check what is the last version online!\033[0m"
  fi
  [ "$IPR_BIN" ] && echo "- 'iprange' is installed: $($IPR_BIN --version | head -n 1)" || echo "- 'iprange' is not installed."
}

init() {
  [ "$VERBOSE" ] && echo -e "\033[1;36mInitializing...\033[0m"
  ipset -q destroy $IPSET_TMP
  if check_firewall_start; then
    [ "$VERBOSE" ] && echo "- 'firewall-start.sh' is in place and ok."
  else
    create_firewall_start
    check_firewall_start || { >&2 echo -e "\033[31m! Problem with $FWS_FILE!\033[0m"; exit 1; }
    [ "$VERBOSE" ] && echo "- 'firewall-start.sh' was edited and is now ok."
  fi
  if [ "$EXT_DRIVE" ]; then
    [ "$VERBOSE" ] && echo "- '$SC_NAME' is installed on external drive."
    if check_postmount; then
      [ "$VERBOSE" ] && echo "- 'post-mount.sh' is in place and ok."
    else
      create_postmount
      check_postmount || { >&2 echo -e "\033[31m! Problem with $PM_FILE!\033[0m"; exit 1; }
      [ "$VERBOSE" ] && echo "- 'post-mount.sh' was edited and is now ok."
    fi
  else
    [ "$VERBOSE" ] && echo "- '$SC_NAME' is installed on internal drive."
  fi
  check_path || set_path
}

fw_restart() {
  [ "$VERBOSE" ] && echo -e "\033[1;36mRestarting firewall...\033[0m"
  if [ "$LOG_ACT" ]; then
    if [ "$LOG_ACT" = 'ON' ]; then
      [ "$VERBOSE" ] && echo "- Enabling logging."
      nvram set aegis_log=1
    else
      [ "$VERBOSE" ] && echo "- Disabling logging."
      nvram unset aegis_log
    fi
  fi
  /usr/sbin/net-wall restart > /dev/null
  [ "$VERBOSE" ] && echo "- Firewall restarted."
}

fw_needs_restart() {
  _IPT="$(iptables -S "$IPTBL_SRC" 2>/dev/null)\n$(iptables -S "$IPTBL_DST" 2>/dev/null)"
  _IPT="$(echo -e "$_IPT"|sed "s/ *$//g ; s/WAN_IF/wan/")"

  if [ "$LOG_ACT" ]; then
    [ $(echo "$_IPT"|grep -Fc -- '-j LOG ') = 2 ] && LOG_IS_ON='y'
    if [ "$LOG_ACT" = 'ON' ]
      then [ "$LOG_IS_ON" ] || return 0
      else [ "$LOG_IS_ON" ] && return 0
    fi
  fi
  
  [ $(echo "$_IPT"|grep -Fc -- "$IPSET_WL_NAME") = 2 ] && _WL='y'
  [ $(echo "$_IPT"|grep -Fc -- "$IPSET_WG_NAME") = 2 ] && _WG='y'

  if [ "$_WL" ]; then
    [ -r "$WL_FILE" ] || return 0
  else
    [ -r "$WL_FILE" ] && return 0
    ipset -q list -n "$IPSET_WL_NAME">/dev/null && return 0
  fi
  
  if [ "$_WG" ]; then
    [ "$WAN_GW" = '0.0.0.0' ] && return 0
    ipset -q test "$IPSET_BL_NAME" "$WAN_GW" || return 0
  else
    ipset -q list -n "$IPSET_WG_NAME">/dev/null && return 0
    [ "$WAN_GW" != '0.0.0.0' ] && ipset -q test "$IPSET_BL_NAME" "$WAN_GW" && return 0
  fi
    
  _CT=$(iptables -S 2>/dev/null | grep -cF -- "$WAN_IF -m set --match-set $IPSET_BL_NAME")
  [ $_CT = 4 ] || return 0
  
  _CT=$(iptables -S 2>/dev/null | grep -cF -- "$TUN_IF -m set --match-set $IPSET_BL_NAME")
  if [ "$TUN_IF" ]
    then [ $_CT = 4 ] || return 0
    else [ $_CT -ne 0 ] && return 0
  fi
  
  return 1;
}

fw_restart_if_needed() {
  if fw_needs_restart; then
    [ "$VERBOSE" ] && echo "- Internal firewall needs to be restarted..."
    fw_restart
  else
    [ "$VERBOSE" ] && echo "- Internal firewall does not need to be restarted."
  fi
}

print_log() {
  echo -e "\033[1;36mLog:\033[0m"
  echo -e "\033[35mIf the log is empty, to be sure it is enabled, use the \033[1mstatus\033[0;35m parameter.\033[0m"
  dmesg | grep -F "$SC_NAME"
}

clean() {
  [ "$VERBOSE" ] && echo -e "\033[1;36mCleaning...\033[0m"
  if [ -e "$FWS_FILE" ]; then
    if [ "$(grep -Fv "$SC_NAME" "$FWS_FILE" | sed '/^[[:space:]]*$/d')" ]; then
      sed -i "/$SC_NAME/d" "$FWS_FILE"
      [ "$VERBOSE" ] && echo "- 'firewall-start.sh' has some other rules; removed only our rules."
    else
      rm "$FWS_FILE" 2>/dev/null
      [ "$VERBOSE" ] && echo "- 'firewall-start.sh' had no other rules; removed it."
    fi
  fi
  if [ "$EXT_DRIVE" ] && [ -e "$PM_FILE" ]; then
    if [ "$(grep -Fv "$SC_NAME" "$PM_FILE" | sed '/^[[:space:]]*$/d')" ]; then
      sed -i "/$SC_NAME/d" "$PM_FILE"
      [ "$VERBOSE" ] && echo "- 'post-mount.sh' has some other code; removed only our code."
    else
      rm "$PM_FILE" 2>/dev/null
      [ "$VERBOSE" ] && echo "- 'post-mount.sh' had no other code; removed it."
    fi
  fi
  check_path && remove_path
  rm "$INFO_FILE" 2>/dev/null
  /usr/sbin/net-wall restart > /dev/null
  [ "$VERBOSE" ] && echo "- Built-in firewall restarted."
  ipset -q destroy "$IPSET_BL_NAME"
  ipset -q destroy "$IPSET_WL_NAME"
  ipset -q destroy "$IPSET_WG_NAME"
  ipset -q destroy "$IPSET_TMP"
  [ "$VERBOSE" ] && echo "- Cleaned ipsets."
  [ -e "$TMP_FILE" ] && rm "$TMP_FILE"
  nvram unset log_firewall_blocklist
  [ "$VERBOSE" ] && echo -e "- Removed temporary files.\n- Cleaning done."
}

set_ipset() {
  [ -r "$BL_FILE" ] || { >&2 echo -e "\033[31m! $BL_FILE not readable!\033[0m"; exit 1; }

  MAX="$(wc -l < $BL_FILE)"
  
  if [ "$VERBOSE" ]; then
    NUM_IP="$(count_ip_in_file $BL_FILE)"
    echo -e "\033[1;36mBuilding ipset blocklist ($MAX entries blocking $NUM_IP ips)...\033[0m"
  fi

  if ipset -q list -n "$IPSET_BL_NAME">/dev/null; then
    echo -e "create $IPSET_TMP hash:net family inet maxelem $MAX\n$(sed "s/^/add $IPSET_TMP /" $BL_FILE)" | ipset restore
    [ "$VERBOSE" ] && echo "- Created blocklist, swapping it."
    ipset swap "$IPSET_BL_NAME" "$IPSET_TMP"
    ipset destroy $IPSET_TMP
  else
    echo -e "create $IPSET_BL_NAME hash:net family inet maxelem $MAX\n$(sed "s/^/add $IPSET_BL_NAME /" $BL_FILE)" | ipset restore
    [ "$VERBOSE" ] && echo "- Created blocklist."
  fi
  [ "$VERBOSE" ] && echo "- Done."
  
  # whitelist
  if [ -s "$WL_FILE" ]; then
    if [ "$VERBOSE" ]; then
      MAX="$(wc -l < $WL_FILE)"
      NUM_IP="$(count_ip_in_file "$WL_FILE")"
      echo -e "\033[1;36mBuilding ipset whitelist ($MAX entries bypassing $NUM_IP ips)...\033[0m"
    fi

    if ipset -q list -n "$IPSET_WL_NAME">/dev/null; then
      echo -e "create $IPSET_TMP hash:net family inet\n$(sed "s/^/add $IPSET_TMP /" $WL_FILE)" | ipset restore
      [ "$VERBOSE" ] && echo "- Created whitelist, swapping it."
      ipset swap "$IPSET_WL_NAME" "$IPSET_TMP"
      ipset destroy "$IPSET_TMP"
    else
      echo -e "create $IPSET_WL_NAME hash:net family inet\n$(sed "s/^/add $IPSET_WL_NAME /" $WL_FILE)" | ipset restore
      [ "$VERBOSE" ] && echo "- Created whitelist."
    fi
    [ "$VERBOSE" ] && echo "- Done."
  else
    ipset -q destroy "$IPSET_WL_NAME"
  fi
}

update_iplist() {
  [ "$VERBOSE" ] && echo -e "\033[1;36mUpdating blocklist from sources...\033[0m"
  [ -r "$SRC_LIST" ] || { >&2 echo -e "\033[31m! $SRC_LIST not readable!\033[0m"; exit 1; }

  :>"$TMP_FILE"
  # Process each source url
  [ "$VERBOSE" ] && echo "- Downloading lists defined in $SRC_LIST"
  [ "$VERBOSE" ] && WGET_OPTS='-qO- --show-progress' || WGET_OPTS='-qO-'
  _NBOK=0; _TOT=0;
  grep -v "^[[:space:]*\#]" "$SRC_LIST" | \
  { while read -r URL; do
      _TOT=$((_TOT+1))
      [ "$VERBOSE" ] && echo -e "$_TOT) $URL\033[35m"
      { { { { wget $WGET_OPTS "$URL"; echo $? >&3; } | grep '^[0-9]' | sed 's/;.*//' >>"$TMP_FILE"; } 3>&1; } | { read _EC; exit $_EC; } } 4>&1
      _EC=$?
      [ "$VERBOSE" ] && echo -e "\033[0m"
      [ $_EC = 0 ] && _NBOK=$((_NBOK+1)) || >&2 echo -e "\033[31m! Wget error code $_EC! Could not download $URL\033[0m"
    done
    [ $_NBOK = 0 ] && { >&2 echo -e "\033[31m! Could not get any list!\033[0m"; rm "$TMP_FILE"; exit 1; }
    [ $_NBOK = $_TOT ] || >&2 echo -e "\033[31m! Downloaded only $_NBOK / $_TOT list(s)!\033[0m"
  }
  if [ -r "$CUST_BL_FILE" ]; then
    [ "$VERBOSE" ] && echo "- Adding netset from custom blacklist ($CUST_BL_FILE)"
    grep '^[0-9]' "$CUST_BL_FILE" | sed 's/;.*//' >>"$TMP_FILE"
  fi
  if [ -x "$IPR_BIN" ]; then
    [ "$VERBOSE" ] && echo "- Optimizing and reducing netset (using iprange)..."
    $IPR_BIN --ipset-reduce 20 "$TMP_FILE" > "$BL_FILE"
  else
    [ "$VERBOSE" ] && echo -e "- iprange not installed, passing optimization and reduction process.\n- Removing duplicates..."
    sort "$TMP_FILE" | uniq > "$BL_FILE"
  fi
  rm "$TMP_FILE" 2>/dev/null
  [ "$VERBOSE" ] && echo "- Done."

  # processing whitelist if any
  if [ -r "$CUST_WL_FILE" ]; then
    [ "$VERBOSE" ] && echo -e "\033[1;36mGenerating whitelist from custom list...\033[0m"
    grep '^[0-9]' "$CUST_WL_FILE" | sed 's/;.*//' >"$TMP_FILE"
    
    if [ -s "$TMP_FILE" ]; then
      if [ -x "$IPR_BIN" ]; then
        if [ "$($IPR_BIN --common "$BL_FILE" "$TMP_FILE")" ]; then
          [ "$VERBOSE" ] && echo "- Optimizing and reducing netset (using iprange)..."
          $IPR_BIN --ipset-reduce 20 "$TMP_FILE"  > "$WL_FILE"
        else
          echo '- No IP in common with blocklist, skipping whitelist.'
        fi
      else
        [ "$VERBOSE" ] && echo -e "- iprange not installed, passing optimization and reduction process.\n- Removing duplicates..."
        sort "$TMP_FILE" | uniq > "$WL_FILE"
      fi
      else echo '- No IP set found, custom whitelist is empty.'
    fi
    rm "$TMP_FILE"
    [ "$VERBOSE" ] && echo "- Done."
  else
    rm "$WL_FILE" 2>/dev/null
  fi
}

status() {
  echo -e "\033[1;36mStatus:\033[0m\n- '$SC_NAME' version: $SC_VERS"
  
  # check iprange binary
  [ "$IPR_BIN" ] && echo "- 'iprange' is installed: $($IPR_BIN --version | head -n 1)" || echo "- 'iprange' is not installed."
  
  # check firewall-start.sh script
  check_firewall_start && STAT_FWS='ok' || STAT_FWS=''
  
  # check post-mount.sh script if script on external drive
  if [ "$EXT_DRIVE" ]; then check_postmount && STAT_PM='ok' || STAT_PM=''; else STAT_PM='na'; fi
  
  # check iptables
  STAT_IPT="$(iptables -S 2>/dev/null | grep -F "$SC_ABR" | sed 's/ *$//g')"
  if [ "$STAT_IPT" ]; then
    _CT=$(echo "$STAT_IPT"|grep -c -- "-A ${SC_ABR}_... -j DROP")
    [ $_CT = 2 ] && STAT_IPT_PBM='' || STAT_IPT_PBM='y' ;;
  
    case $(echo "$STAT_IPT"|grep -Fc -- "$IPSET_WL_NAME") in
      2) STAT_IPT_WL='y' ;;
      0) STAT_IPT_WL='' ;;
      *) STAT_IPT_PBM='y' ;;
    esac
  
    case $(echo "$STAT_IPT"|grep -Fc -- "$IPSET_WG_NAME") in
      2) STAT_IPT_WG='y' ;;
      0) STAT_IPT_WG='' ;;
      *) STAT_IPT_PBM='y' ;;
    esac
  
    _CT=$(echo "$STAT_IPT" | grep -cF -- "$WAN_IF -m set --match-set $IPSET_BL_NAME")
    [ $_CT = 4 ] && STAT_IPT_WAN='' || STAT_IPT_WAN='ok'
  
    _CT=$(echo "$STAT_IPT" | grep -cF -- "$TUN_IF -m set --match-set $IPSET_BL_NAME")
    if [ "$TUN_IF" ]
      then [ $_CT = 4 ] && STAT_IPT_TUN='' || STAT_IPT_TUN='ok'
      else [ $_CT -ne 0 ] && STAT_IPT_TUN='na' || STAT_IPT_TUN=''
    fi
  
    # check log    
    case $(echo "$STAT_IPT"| grep -c -- "-A ${SC_ABR}_... -j LOG --log-prefix") in
      2) STAT_LOG='y' ;;
      0) STAT_LOG='' ;;
      *) STAT_IPT_PBM='y' ;;
    esac
  fi
  # end check iptables
  
  # check ipset blocklist
  STAT_IPS="$(ipset -q list $IPSET_BL_NAME -t)"
  
  # check ipset whitelist
  STAT_IPS_WL="$(ipset -q list $IPSET_WL_NAME -t)"
  
  # check ipset WAN gateway whitelist
  STAT_IPS_WG="$(ipset -q list $IPSET_WG_NAME -t)"
  
  if [ "$WAN_GW" = '0.0.0.0' ]; then
    STAT_GW_IN_BL=''; STAT_GW_IN_WG=''
  else
    # check WAN gateway in ipset blocklist
    ipset -q test "$IPSET_BL_NAME" "$WAN_GW" && STAT_GW_IN_BL='y' || STAT_GW_IN_BL=''

    # check WAN gatewan in WAN gateway ipset whitelist
    ipset -q test "$IPSET_WG_NAME" "$WAN_GW" && STAT_GW_IN_WG='y' || STAT_GW_IN_WG=''
  fi
  
  # master check
  if   [ "$STAT_IPT_PBM" ]; then
    echo -e "- \033[1;31mSomething is not right with iptables setup!\033[0m Use '$SC_NAME -v status' for more details"
  elif [ -z "$STAT_IPT$STAT_IPS$STAT_IPS_WL$STAT_IPS_WG$STAT_FWS$STAT_PM" ]; then
    echo "- '$SC_NAME' is not active; Settings are clean."
  elif [ "$STAT_IPT_WAN" -a "$STAT_IPT_TUN" -a "$STAT_IPS" -a "$STAT_FWS" -a "$STAT_PM" ]; then
    echo -n "- '$SC_NAME' is set and active"
    [ "$STAT_IPT_WAN" ] && echo -n " for WAN interface ($WAN_IF)"
    [ "$STAT_IPT_TUN" = 'ok' ] && echo -n " and VPN tunnel ($TUN_IF)"
    echo -e ".\n- Filtering $(count_ip_in_ipset $IPSET_BL_NAME) IP adresses."
    [ "$STAT_IPT_WL" ] && if [ "$STAT_IPS_WL" ]; then
      echo "- Bypassing $(count_ip_in_ipset $IPSET_WL_NAME) IP adresses."
    else
      echo -e "- \033[1;31mWhitelist is defined in ipset but not in iptables!\033[0m Use '$SC_NAME -v status' for more details"
    fi
    if [ "$STAT_GW_IN_BL" -a "$STAT_GW_IN_WG" -a "$STAT_IPT_WG" ]; then
      echo "- WAN gateway IP range is bypassed (because in blocklist)."
    else
      echo -e "- \033[1;31mSomething is not right with the WAN gateway bypass!\033[0m Use '$SC_NAME -v status' for more details"
    fi
  else
    echo -e "- \033[1;31mSomething is not right!\033[0m Use '$SC_NAME -v status' for more details"
  fi
  [ "$STAT_LOG" ] && echo "- Logging is on." || echo "- Logging is off."
  [ "$VERBOSE" ] || return 0
  
  # details
  echo -e "\033[1;36mDetailed status:\033[0m"
  if check_path
    then echo "- '$SC_NAME' is in \$PATH."
    else echo "- '$SC_NAME' is not in \$PATH (you need to use $NICE_PATH)."
  fi
  if [ "$STAT_FWS" ]; then
    echo "- 'firewall-start.sh' exists with correct settings."
  else
    echo "- 'firewall-start.sh' does not exist or does not have '$SC_NAME' settings."
  fi

  if [ "$STAT_PM" ]; then
    [ "$STAT_PM" = 'ok' ] && echo "- 'post-mount.sh' exists with correct settings."
  else
    echo "- 'post-mount.sh' does not exist or does not have '$SC_NAME' settings."
  fi
  
  # dates
  echo "- Actual router time: $(/bin/date +'%Y-%m-%d %X')"
  [ -e "$BL_FILE" ] && echo "- Blocklist generation time: $(/bin/date +'%Y-%m-%d %X' -r $BL_FILE)"
  [ -e "$WL_FILE" ] && echo "- Whitelist generation time: $(/bin/date +'%Y-%m-%d %X' -r $WL_FILE)"
  
  # Status file
  if [ -r "$INFO_FILE" ]; then
    echo -e "- Router firewall was last started $(/bin/date +'%Y-%m-%d %X' -r $INFO_FILE): \033[35m"
    /bin/grep -qF "$INFO_IPS_BL_LOAD" "$INFO_FILE" && echo '     ipset blocklist was loaded from blocklist file.'
    /bin/grep -qF "$INFO_IPS_BL_NEW" "$INFO_FILE" && echo '     ipset blocklist was created empty.'
    /bin/grep -qF "$INFO_IPS_BL_KEEP" "$INFO_FILE" && echo '     ipset blocklist was already loaded.'
    /bin/grep -qF "$INFO_IPS_BL_WGW" "$INFO_FILE" && echo '     WAN gateway was in ipset blocklist.'
    /bin/grep -qF "$INFO_IPS_WL_LOAD" "$INFO_FILE" && echo '     ipset whitelist was loaded from whitelist file.'
    /bin/grep -qF "$INFO_IPS_WL_KEEP" "$INFO_FILE" && echo '     ipset whitelist was already loaded and was kept.'
    /bin/grep -qF "$INFO_IPS_WG_ADD" "$INFO_FILE" && echo '     WAN gateway whitelist was added into ipset.'
    /bin/grep -qF "$INFO_IPS_WG_KEEP" "$INFO_FILE" && echo '     WAN gateway whitelist was already loaded.'
    /bin/grep -qF "$INFO_IPT_SRC_KEEP" "$INFO_FILE" && echo '     inbound iptables rules were already set!'
    /bin/grep -qF "$INFO_IPT_DST_KEEP" "$INFO_FILE" && echo '     outbound iptables rules were already set!'
    /bin/grep -qF "$INFO_IPT_LOG" "$INFO_FILE" && echo '     iptables logging rules were set.'
    /bin/grep -qF "$INFO_IPT_WL" "$INFO_FILE" && echo '     iptables whitelist rules were set.'
    /bin/grep -qF "$INFO_IPT_WAN_PBM" "$INFO_FILE" && echo '     WAN blocklist rules had problems and were reset.'
    /bin/grep -qF "$INFO_IPT_WG_PBM" "$INFO_FILE" && echo '     WAN gateway whitelist rules had problems and were reset.'
    /bin/grep -qF "$INFO_IPT_TUN_PBM" "$INFO_FILE" && echo '     VPN blocklist rules had problems and were reset.'
    /bin/grep -qF "$INFO_IPT_WAN" "$INFO_FILE" && echo '     WAN blocklist rules were added to iptables.'
    /bin/grep -qF "$INFO_IPT_WG" "$INFO_FILE" && echo '     WAN gateway whitelist rules were added to iptables.'
    /bin/grep -qF "$INFO_IPT_TUN" "$INFO_FILE" && echo '     VPN blocklist rules were added to iptables.'
    echo -ne "\033[0m"
  else
    echo '- No status file found.'
  fi
  
  if [ "$STAT_IPT" ]; then
    if [ "$STAT_IPT_PBM" ]; then
      echo -e "- \033[31miptables rules are not set properly\033[0m:"
    else
      echo -n "- iptables rules are set"
      [ "$STAT_IPT_WL" ] && echo -n ", with whitelist"
      [ "$STAT_IPT_WG" ] && echo -n ", with WAN gateway bypass"
      echo ':'
    fi
    echo -ne "\033[35m"
    echo "$STAT_IPT" | sed -e 's/^/     iptables /g'
    echo -ne "\033[0m"
  else
    echo "- iptables rules are not set."
  fi
  if [ "$STAT_LOG" ];
    then echo "- Logging is active."
    else echo "- Logging is inactive."
  fi
  if [ "$STAT_IPS" ]; then
    echo "- ipset blocklist is set:"
    if [ "$STAT_GW_IN_BL" ]
      then if [ "$STAT_GW_IN_WG" ]
        then echo -e "     \033[36mWAN gateway ($WAN_GW) is in blocklist\033[0m"
        else echo -e "     \033[31mWAN gateway ($WAN_GW) is in blocklist (but not bypassed)!\033[0m"
      fi
    fi
    echo -e "\033[35m$STAT_IPS\033[0m" | sed -e 's/^/     /g'
  else
    echo "- ipset blocklist is not set."
  fi
  
  if [ "$STAT_IPS_WL" ]; then
    echo "- ipset whitelist is set:"
    echo -e "\033[35m$STAT_IPS_WL\033[0m" | sed -e 's/^/     /g'
  else
    echo "- ipset whitelist is not set."
  fi
  
  if [ "$STAT_IPS_WG" ]; then
    echo "- ipset WAN gateway bypass is set:"
    [ "$STAT_GW_IN_BL" ] || echo -e "     \033[31mWAN gateway IP ($WAN_GW) is NOT in blocklist!\033[0m"
    if [ "$STAT_GW_IN_WG" ]
        then echo -e "     \033[36mWAN gateway ($WAN_GW) is in bypass list\033[0m"
        else echo -e "     \033[31mWAN gateway ($WAN_GW) is NOT in bypass list!\033[0m"
    fi
    echo -e "\033[35m$STAT_IPS_WG\033[0m" | sed -e 's/^/     /g'
  else
    [ "$STAT_GW_IN_BL" ] && _CLR='\033[31m' || _CLR='\033[0m'
    echo -e "${_CLR}- ipset WAN gateway bypass is not set.\033[0m"
  fi
}

print_help() {
  echo -e "\033[1;36m$SC_NAME $SC_VERS\033[0m"
  echo -e "Usage: \033[1m$SC_NAME \033[35mCOMMAND \033[36m[OPTION(S)]\033[0m"
  echo -e "\033[7mCOMMANDS (use only one):\033[0m"
  echo -e " \033[1;35mrestart\033[0m    - setup ipset and iptables then restarts internal firewall"
  echo -e " \033[1;35mupdate_set\033[0m - generates blocklist set from servers in $SRC_LIST"
  echo -e " \033[1;35mload_set\033[0m   - loads blocklist set into ipset then restarts internal firewall"
  echo -e " \033[1;35mupdate\033[0m     - update_set then load_set \033[1;36m[probably what you want to use]\033[0m"
  echo -e " \033[1;35mclean\033[0m      - clean ipset and iptables rules from setup created by this script"
  echo -e " \033[1;35mhelp\033[0m       - displays help (this)"
  echo -e " \033[1;35minfo\033[0m       - displays info on this script"
  echo -e " \033[1;35mstatus\033[0m     - displays status"
  echo -e " \033[1;35mlog\033[0m        - displays log"
  echo -e " \033[1;35mupgrade\033[0m    - download and install latest version"
  echo -e "\033[7mOPTIONS (none, one or more):\033[0m"
  echo -e " \033[1;36m-v\033[0m          - verbose mode"
  echo -e " \033[1;36m-log=on\033[0m/\033[1;36moff\033[0m - when used with restart, load_set or update, will enable/disable logging"
}

# Main routine
[ $# = 0 ] && { >&2 echo -e "\033[31m! No parameter!\033[0m"; print_help; exit 1; }
[ "$1" = "_pm" ] && [ "$2" ] && _pm

if [ "$1" != "_niced" ]; then
  OPTS=''
  if [ -z "${*##-v *}" ] || [ -z "${*##* -v *}" ] || [ -z "${*##* -v}" ]; then OPTS='_verbose'; fi
  if [ -z "${*##--devmode *}" ] || [ -z "${*##* --devmode *}" ] || [ -z "${*##* --devmode}" ]; then OPTS="${OPTS}_devmode"; fi
  if [ -z "${*##-log=on *}" ] || [ -z "${*##* -log=on *}" ] || [ -z "${*##* -log=on}" ]; then OPTS="${OPTS}_logon"; fi
  if [ -z "${*##-log=off *}" ] || [ -z "${*##* -log=off *}" ] || [ -z "${*##* -log=off}" ]; then OPTS="${OPTS}_logoff"; fi
  PARAM="$(echo "$*" | /bin/sed 's/-[[:alpha:]=]*//g' | sed 's/ //g')"
  [ "$PARAM" ] || { >&2 echo -e "\033[31m! No parameter!\033[0m"; print_help; exit 1; }

  nice -n 15 "$SC_PATH/$SC_NAME" _niced "$PARAM" "$OPTS"
  exit $?
fi

if [ "$3" ]; then
  [ -z "${3##*devmode*}" ] && DEVMODE='y'
  [ -z "${3##*verbose*}" ] && VERBOSE='y'
  [ -z "${3##*logon*}" ] && LOG_ACT='ON'
  [ -z "${3##*logoff*}" ] && LOG_ACT='OFF'
fi
if [ $DEVMODE ]; then echo -e "\033[7;31m$SC_NAME $SC_VERS - Developer mode\033[0m"; VERBOSE='y'
elif [ $VERBOSE ]; then echo -e "\033[7;31m$SC_NAME $SC_VERS - Verbose mode\033[0m"; fi

case "$2" in
  "restart") init; fw_restart; [ $VERBOSE ] && status ;;
  "clean") clean; [ $VERBOSE ] && status ;;
  "load_set") init; set_ipset; fw_restart_if_needed; [ $VERBOSE ] && status ;;
  "update_set") update_iplist ;;
  "update") init; update_iplist; set_ipset; fw_restart_if_needed; [ $VERBOSE ] && status ;;
  "status") status ;;
  "help") print_help ;;
  "info") info ;;
  "log") print_log ;;
  "upgrade") upgrade ;;
  *) >&2 echo -e "\033[31m! Unknown Parameter $2!\033[0m"; print_help; exit 1 ;;
esac

exit 0
