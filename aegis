#! /bin/sh
# ----------- ENVIRONMENT VARIABLES -----------
# CAN BE SOURCED INTO UTILS USING AEGIS -------
# USING: eval "$(aegis _env)" -----------------
if [ "$1" = '_env' ]; then IFS=; while read -r L
  do case "$L" in ': ENV START') E=1;; ': ENV STOP') E=;; ': ENV EOF') break;; *) [ $E ] && echo "$L";; esac
done<$0; exit; fi
# ---------------------------------------------
: ENV START
# ---------------------------------------------
command -v iptables>/dev/null 2>&1 || export PATH=/bin:/sbin:/usr/bin:/usr/sbin
! command -v iprange>/dev/null 2>&1 && [ -e /root/.profile ] && source /root/.profile
SC_VERS="1.5.3"
SC_NAME="aegis"
SC_ABR="aegis"
IPR_BIN="$(/usr/bin/which iprange)"
IPT_COM='iptables'
IPT_BIN="/usr/sbin/$IPT_COM"
IPTBL_SRC="${SC_ABR}_src"
IPTBL_DST="${SC_ABR}_dst"
IPSET_BL_NAME="${SC_ABR}_bl"
IPSET_WL_NAME="${SC_ABR}_wl"
IPSET_TMP="${IPSET_BL_NAME}_tmp"
ROOT_DIR="/opt/bolemo"
BL_FILE="$ROOT_DIR/etc/${SC_NAME}-bl.netset"
WL_FILE="$ROOT_DIR/etc/${SC_NAME}-wl.netset"
INFO_FILE="/tmp/${SC_ABR}_status"
LOG_FILE="/var/log/log-$SC_ABR"
ifconfig ppp0 >/dev/null 2>/dev/null && WAN_IF='ppp0' || WAN_IF="$(/bin/nvram get wan_ifname)"
# VPN tunnel detection
if ifconfig wg0 >/dev/null 2>/dev/null; then
  # WireGuard
  TUN_IF='wg0'
else
  TUN_IF="$(ps -w|/bin/grep -F -- '/usr/sbin/openvpn --dev'|/bin/grep -vE 'grep|server_tap|server_tun')"
  [ "$TUN_IF" ] && TUN_IF=${TUN_IF##* --dev } && TUN_IF=${TUN_IF%% *} # Open VPN client or no tunneling
fi

# INFO FROM (2 bits)
INFO_FROM_MASK=3
INFO_FROM_FWS=1       # _ x
INFO_FROM_PM=2        # x _
INFO_FROM_SC=3        # x x

# INFO IPSET (7 bits)
INFO_IPS_SHIFT=2
INFO_IPS_MASK=127
                      # . . . . . _ _  PBM, BL FILE MISSING
INFO_IPS_BL_SAME=1    # . . . . . _ x  KEEP
INFO_IPS_BL_MISS=2    # . . . . . x _  KEEP
INFO_IPS_BL_LOAD=3    # . . . . . x x
INFO_IPS_BL_MASK=3    # . . . . . x x
INFO_IPS_WL_SAME=4    # . . _ . x . .  SAME => KEEP
INFO_IPS_WL_KEEP=8    # . . _ x . . .  KEEP
INFO_IPS_WL_LOAD=16   # . . x _ _ . .
INFO_IPS_WL_SWAP=20   # . . x _ x . . = RELOAD
INFO_IPS_WL_DEL=24    # . . x x _ . . => was there, was deleted
                      # . . _ _ _ . . => was not there, was not loaded
INFO_IPS_WL_MASK=28   # . . x x x . .
INFO_IPS_WB_NDD=32    # . x . . . . .
INFO_IPS_TB_NDD=64    # x . . . . . .

# INFO IPTABLES (18 bits)
INFO_IPT_SHIFT=9
INFO_IPT_MASK=262143
INFO_IPT_SRC_KEEP=1        # . . . . . . . . . . . . . . . . . x (or NEW)
INFO_IPT_DST_KEEP=2        # . . . . . . . . . . . . . . . . x . (or NEW)

INFO_IPT_IB_PBM=4          # . . . . . . . . . . . . . . . x . .

INFO_IPT_IB_SRC_NEW=1 # . x
INFO_IPT_IB_DST_NEW=2 # x .

INFO_IPT_WB_SHIFT=3
INFO_IPT_WB_SRC_NEW=8      # . . . . . . . . . . . . . . x . . . (or KEEP)
INFO_IPT_WB_DST_NEW=16     # . . . . . . . . . . . . . x . . . . (or KEEP)

INFO_IPT_TB_SHIFT=5
INFO_IPT_TB_SRC_NEW=32     # . . . . . . . . . . . . x . . . . . (or KEEP)
INFO_IPT_TB_DST_NEW=64     # . . . . . . . . . . . x . . . . . . (or KEEP)

INFO_IPT_WL=128            # . . . . . . . . . . x . . . . . . .
INFO_IPT_WL_SRC_NEW=256    # . . . . . . . . . x . . . . . . . . (or KEEP)
INFO_IPT_WL_DST_NEW=512    # . . . . . . . . x . . . . . . . . . (or KEEP)
INFO_IPT_LOG=1024          # . . . . . . . x . . . . . . . . . .
INFO_IPT_LOG_SRC_NEW=2048  # . . . . . . x . . . . . . . . . . . (or KEEP)
INFO_IPT_LOG_DST_NEW=4096  # . . . . . x . . . . . . . . . . . . (or KEEP)

INFO_IPT_IF_NEW=1  # _ x
INFO_IPT_IF_KEEP=2 # x _
INFO_IPT_IF_PBM=3  # x x

INFO_IPT_WAN_SHIFT=13
INFO_IPT_WAN_NEW=8192      # . . . _ x . . . . . . . . . . . . .
INFO_IPT_WAN_KEEP=16384    # . . . x _ . . . . . . . . . . . . .
INFO_IPT_WAN_PBM=24576     # . . . x x . . . . . . . . . . . . .

INFO_IPT_TUN_SHIFT=15
INFO_IPT_TUN_NEW=32768     # . _ x . . . . . . . . . . . . . . .
INFO_IPT_TUN_KEEP=65536    # . x _ . . . . . . . . . . . . . . .
INFO_IPT_TUN_PBM=98304     # . x x . . . . . . . . . . . . . . .

INFO_IPT_IFO_PBM=131072    # x . . . . . . . . . . . . . . . . .

# INFO LOGD (2 bits)
INFO_LOGD_SHIFT=27
INFO_LOGD_KEEP_ON=0        # _ _
INFO_LOGD_KEEP_OFF=1       # _ x
INFO_LOGD_STARTED=2        # x _
INFO_LOGD_STOPPED=3        # x x
INFO_LOGD_MASK=3

# --------------- ENV FUNCTIONS ---------------

sc_conf() { [ -z "$2" ] && _OPT= || _OPT=".$2" ;/sbin/uci -qc $ROOT_DIR/etc/config $1 $SC_ABR$_OPT; return $?; }

get_ipt() { _IPT="$($IPT_BIN -S|/bin/grep -F "$SC_ABR")"; } 2>/dev/null

inet_for_if() {
  _IP="$(/usr/sbin/ip -4 addr show $1|/usr/bin/awk 'NR==2 {print $2;exit}')"
  if [ "$IPR_BIN" ]
    then echo $_IP|iprange -
    else _IP=$(/bin/ipcalc.sh $_IP|/usr/bin/awk -F= '/NETWORK|PREFIX/ {ORS="/";print $2}');echo ${_IP%?}
  fi
}

# ---------------------------------------------
: ENV STOP
# ---------------------------------------------

# -------------- LOGD FUNCTIONS ---------------
# Aegis logging daemon
# ---------------------------------------------
LOGD_NAME=${SC_ABR}-logd
LOGD_PID="/var/run/${LOGD_NAME}.pid"
LOGD_TMP="/tmp/$LOGD_NAME"
_logd_start() {
[ -e $LOGD_PID ] && kill -0 $(cat $LOGD_PID) && return 2 # logd is already running
sc_conf get log.len >/dev/null || { sc_conf set log.len=5000; sc_conf commit; }
cat >"$LOGD_TMP" <<'EOF'
local LOG_MSG=/var/log/log-message
rm $LOGD_TMP 2>/dev/null
trap "{ PID=$(cat $LOGD_PID); rm $LOGD_PID; rm $LOGD_TMP; kill -9 $PID; exit; } 2>/dev/null" TERM EXIT
touch $LOG_FILE
while :; do
  local NUMLINES=$(uci -qc /opt/bolemo/etc/config get aegis.log.len)
  local FIRST_MSG_LINE="$(/usr/bin/awk '/\['$SC_ABR'\]/{print; exit}' $LOG_MSG)" # first line in rotated message log
  if [ "$FIRST_MSG_LINE" ] && [ -s $LOG_FILE ]; then
    local FIRST_EXT_TS="$(/usr/bin/awk -F':' 'NR==1{print $1; exit}' $LOG_FILE)" # first timestamp in our log
    if [ "${FIRST_MSG_LINE%%:*}" -gt "$FIRST_EXT_TS" ]; then :>$LOGD_TMP
      /usr/bin/awk '$0=="'"$FIRST_MSG_LINE"'"{exit} {print}' $LOG_FILE >>$LOGD_TMP
      set -- $(/usr/bin/wc -l $LOGD_TMP); if [ "$NUMLINES" -le "$1" ]
        then /usr/bin/tail -n $NUMLINES $LOGD_TMP >$LOG_FILE
        else cat $LOGD_TMP >$LOG_FILE
      fi
    else :>$LOG_FILE
    fi
  else set -- $(/usr/bin/wc -l $LOG_FILE); if [ "$NUMLINES" -le "$1" ]
    then /usr/bin/tail -n $NUMLINES $LOG_FILE >$LOGD_TMP; cat $LOGD_TMP >$LOG_FILE; fi
  fi
  rm $LOGD_TMP 2>/dev/null
     # using LOG_FILE>LOGD_TMP>LOG_FILE allow to keep same inode for LOG_FILE
     # now, LOG_FILE ends just before LOG_MSG starts and is no longer than NUMLINES
  local INODE="$(ls -i $LOG_MSG)"
  local C=1
  while /usr/bin/awk -F: '/\['$SC_ABR'\]/{st=index($0," ");if ($1==pts) {c++} else {c=0;pts=$1}; printf("%s:%.3d:%s\n",$1,c,substr($0,st)); system("")}'; do
    sleep 2 & wait $!
    [ "$INODE" != "$(ls -i $LOG_MSG)" ] && break;
    if [ $C -eq 10 ] # check every C x 2 seconds
      then C=1; $IPT_BIN -C $IPTBL_SRC -j LOG --log-prefix "[$SC_ABR] " || kill $(cat $LOGD_PID)
      else C=$((C+1))
    fi
  done <$LOG_MSG >>$LOG_FILE 2>/dev/null;
done
EOF
export LOGD_NAME; export LOGD_PID; export LOGD_TMP
export LOG_FILE; export SC_ABR; export IPTBL_SRC; export IPT_BIN
cd /tmp; /bin/sh $LOGD_NAME & echo $! >$LOGD_PID
return 0
}
_logd_stop() { [ -e $LOGD_PID ] && kill $(cat $LOGD_PID); return $?; } 2>/dev/null
_logd_status() { [ -e $LOGD_PID ] && kill -0 $(cat $LOGD_PID); return $?; }

# ------------- CIPSET FUNCTIONS --------------
# Copy ipset in /tmp to work on it
# ---------------------------------------------
_cipset_init() { _CIPSET_DIR=$(/bin/mktemp -d "/tmp/${SC_ABR}_XXXXXX"); trap "_cipset_end; exit" TERM INT; }
_cipset_end() { [ -d "$_CIPSET_DIR" ] && /bin/rm -r $_CIPSET_DIR; }
_cipset_copy_set() { return $({ { ipset -q -L "$1" 3>&1; echo $? >&3; }|/usr/bin/awk 'NR==1,/Members:/ {next};NF' >"$_CIPSET_DIR/$1"; } 3>&1); }
_cipset_diff_set_file() {
  if [ $IPR_BIN ]; then $IPR_BIN --quiet "$_CIPSET_DIR/$1" --diff "$2"; else /usr/bin/sort|diff -q "$_CIPSET_DIR/$1" "$2" >/dev/null; fi
  return $?
}
_cipset_swap_set_file() {
  cat $2 >$_CIPSET_DIR/$1
  echo -e "create $IPSET_TMP hash:net family inet maxelem $(/usr/bin/wc -l <"$_CIPSET_DIR/$1")\n$(/bin/sed "s/^/add $IPSET_TMP /" $_CIPSET_DIR/$1)" | ipset restore
  ipset swap "$1" "$IPSET_TMP"
  ipset destroy $IPSET_TMP
}
_cipset_create_set_file() {
  cat $2 >$_CIPSET_DIR/$1
  echo -e "create $1 hash:net family inet maxelem $(/usr/bin/wc -l <"$_CIPSET_DIR/$1")\n$(/bin/sed "s/^/add $1 /" "$_CIPSET_DIR/$1")" | ipset restore
}
_cipset_inet_in_bl() {
  [ -z "$IPR_BIN" ] && return 0 # we return true because without iprange, we are not checking thus we want the BP
  [ -z "$(echo "$1" | iprange "$_CIPSET_DIR/$IPSET_BL_NAME" --common - )" ] && return 1 || return 0
}
_cipset_count_set() {
  [ $IPR_BIN ] && { $IPR_BIN "$_CIPSET_DIR/$1" -C|/usr/bin/cut -d, -f2; return; }
  /bin/grep -oE '(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\/([0-9]{1,2})' "$_CIPSET_DIR/$1"|/usr/bin/awk -F / '{ count[$2]++ } END { for (mask in count) total+=count[mask]*2^(32-mask); print total }'
}

###############################################
#
#    ENGINE-START
#
###############################################

_set_ipt_bypass_for_if_inet_pos() { # Bypass for interface inet $1=iface, $2=inet, $3=pos
  _RET=0
  _BP_POS="$(echo "$_IPT_SRC"|/bin/grep -nF -- "-s $2 -i $1 -m comment --comment \"$SC_ABR inet bypass\""|cut -d: -f1)"
  if [ "$_BP_POS" != "$3" ]; then
    echo "$_IPT_SRC"|/bin/grep -F -- "-i $1 -j RETURN"|/bin/sed "s/^-A/$IPT_COM -D/"|while read _CMD; do eval "$_CMD"; done
    $IPT_BIN -I "$IPTBL_SRC" $3 -s $2 -i $1 -m comment --comment "$SC_ABR inet bypass" -j RETURN
    _RET=$INFO_IPT_IB_SRC_NEW
  fi
  _BP_POS="$(echo "$_IPT_DST"|/bin/grep -nF -- "-d $2 -o $1 -m comment --comment \"$SC_ABR inet bypass\""|cut -d: -f1)"
  if [ "$_BP_POS" != "$3" ]; then
    echo "$_IPT_DST"|/bin/grep -F -- "-o $1 -j RETURN"|/bin/sed "s/^-A/$IPT_COM -D/"|while read _CMD; do eval "$_CMD"; done
    $IPT_BIN -I "$IPTBL_DST" $3 -d $2 -o $1 -m comment --comment "$SC_ABR inet bypass" -j RETURN
    _RET=$((_RET+INFO_IPT_IB_DST_NEW))
  fi
  return $_RET
}

_set_ipt_for_if_pos() {
  _IF="$1"
  _POS=$2
  _CT=$(echo "$_IPT"|/bin/grep -cF -- "$_IF -m set --match-set $IPSET_BL_NAME")
  if [ "$_CT" -ne 4 ]; then
    if [ "$_CT" ] && [ "$_CT" -ne 0 ]; then
      # something is messed up with rules; deleting what is left
      echo "$_IPT"|/bin/grep -F -- "$_IF -m set --match-set $IPSET_BL_NAME"|/bin/sed "s/^-A/$IPT_COM -D/"|while read _CMD; do eval "$_CMD"; done
      _RET=$INFO_IPT_IF_PBM
    else
      _RET=$INFO_IPT_IF_NEW
    fi
    $IPT_BIN -I INPUT $_POS -i $_IF -m set --match-set "$IPSET_BL_NAME" src -m comment --comment "incoming in $SC_ABR blacklist" -j "$IPTBL_SRC"
    $IPT_BIN -I OUTPUT $_POS -o $_IF -m set --match-set "$IPSET_BL_NAME" dst -m comment --comment "outgoing in $SC_ABR blacklist" -j "$IPTBL_DST"
    $IPT_BIN -I FORWARD $_POS -i $_IF -m set --match-set "$IPSET_BL_NAME" src -m comment --comment "incoming in $SC_ABR blacklist" -j "$IPTBL_SRC"
    $IPT_BIN -I FORWARD $((_POS*2)) -o $_IF -m set --match-set "$IPSET_BL_NAME" dst -m comment --comment "outgoing in $SC_ABR blacklist" -j "$IPTBL_DST"
  else
    _RET=$INFO_IPT_IF_KEEP
  fi
  return $_RET
}

shield_uprear() {
  NFO_FROM=$1
  [ $2 ] && _RELOAD_WTD=1

  NFO_IPS=0; NFO_IPT=0
  _logd_status; NFO_LOGD=$?
  _cipset_init
  # creating ipset blocklist if needed
  if _cipset_copy_set $IPSET_BL_NAME; then
    # an ipset blocklist is already loaded
    if [ -r "$BL_FILE" ]; then
      [ "$_RELOAD_WTD" ] && _RELOAD=1
      # checking if ipset and file are identical
      if _cipset_diff_set_file $IPSET_BL_NAME $BL_FILE
        then _RELOAD=''; NFO_IPS=$((NFO_IPS+INFO_IPS_BL_SAME))
        else _RELOAD=1
      fi
    else
      # blocklist file is missing!
      _RELOAD=''
      NFO_IPS=$((NFO_IPS+INFO_IPS_BL_MISS))
    fi
    if [ "$_RELOAD" ]; then
    # reload is asked for; so need to swap ipset
      _cipset_swap_set_file $IPSET_BL_NAME $BL_FILE
      NFO_IPS=$((NFO_IPS+INFO_IPS_BL_LOAD))
    # else keeping existing blocklist
    fi
  else
    if [ -r "$BL_FILE" ]; then
    # netset file exists, so creating blocklist ipset from it
      _cipset_create_set_file $IPSET_BL_NAME $BL_FILE
      NFO_IPS=$((NFO_IPS+INFO_IPS_BL_LOAD))
    else
    # no netset file, exiting with _IPS=0
      exit 1
    fi
  fi
  
  # creating ipset whitelist if needed
  if _cipset_copy_set $IPSET_WL_NAME; then
    # ipset whitelist is already in place
    if [ -r "$WL_FILE" ]; then
      _WL=1
      [ "$_RELOAD_WTD" ] && _RELOAD=1 || _RELOAD=''
      # checking if ipset and file are identical
      if _cipset_diff_set_file $IPSET_WL_NAME $WL_FILE
        then _RELOAD=''; NFO_IPS=$((NFO_IPS+INFO_IPS_WL_SAME))
        else _RELOAD=1
      fi
      if [ "$_RELOAD" ]; then
      # reload is asked for; so need to swap ipset
        _cipset_swap_set_file $IPSET_WL_NAME $WL_FILE
        NFO_IPS=$((NFO_IPS+INFO_IPS_WL_SWAP))
      else
      # else we want to keep it
        NFO_IPS=$((NFO_IPS+INFO_IPS_WL_KEEP))
      fi
    #else it will be destroyed later
    fi
  else
    if [ -r "$WL_FILE" ]; then
      # netset file exists, so creating whitelist ipset from it
      _WL=1
      _cipset_create_set_file $IPSET_WL_NAME $WL_FILE
      NFO_IPS=$((NFO_IPS+INFO_IPS_WL_LOAD))
    fi
  fi

  get_ipt
  #Define grep to find inaccurate ifaces (used for clean-ups)
  [ "$TUN_IF" ] && _GREP="/bin/grep -v '\($WAN_IF\|$TUN_IF\)'" || _GREP="/bin/grep -vF '$WAN_IF'"
  #Creating our iptables chains if not already set
  _IPT_SRC="$(echo "$_IPT"|/bin/grep -F -- "-A $IPTBL_SRC")"
  [ "$_IPT_SRC" ] && NFO_IPT=$((NFO_IPT+INFO_IPT_SRC_KEEP)) || $IPT_BIN -N "$IPTBL_SRC"
  _IPT_DST="$(echo "$_IPT"|/bin/grep -F -- "-A $IPTBL_DST")"
  [ "$_IPT_DST" ] && NFO_IPT=$((NFO_IPT+INFO_IPT_DST_KEEP)) || $IPT_BIN -N "$IPTBL_DST"

  WAN_INET=$(inet_for_if $WAN_IF)
  [ "$TUN_IF" ] && TUN_INET=$(inet_for_if $TUN_IF)
  # checking and cleaning any bypass that is not WAN_IF or TUN_IF (+ WAN_IF and TUN_IF if not needed) in SRC/DST chains
  if _cipset_inet_in_bl $WAN_INET; then _EXCL_IF=$WAN_IF; NFO_IPS=$((NFO_IPS+INFO_IPS_WB_NDD)); else WAN_INET=''; fi
  if _cipset_inet_in_bl $TUN_INET; then [ "$_EXCL_IF" ] && _EXCL_IF="\($WAN_IF\|$TUN_IF\)" || _EXCL_IF=$WAN_IF; NFO_IPS=$((NFO_IPS+INFO_IPS_TB_NDD)); else TUN_INET=''; fi
  if [ "$_EXCL_IF" ]
    then _IPT_UCH="$(echo "$_IPT"|/bin/grep -v $_EXCL_IF|/bin/grep -F -- "-m comment --comment \"$SC_ABR inet bypass\" -j RETURN")"
    else _IPT_UCH="$(echo "$_IPT"|/bin/grep -F -- "-m comment --comment \"$SC_ABR inet bypass\" -j RETURN")"
  fi
  if [ "$_IPT_UCH" ]; then
    # we have some unwanted rules (likely old WAN_IF or TUN_IF)
    echo "$_IPT_UCH"|/bin/sed "s/^-A/$IPT_COM -D/"|while read _CMD; do eval "$_CMD"; done
    NFO_IPT=$((NFO_IPT+INFO_IPT_IB_PBM))
  fi

  _POS=0
  # Applying WAN Network Range Bypass if needed and not skipped
  sc_conf get wan.no_bypass >/dev/null || [ "$WAN_INET" ] && { _POS=$((1+_POS)); _set_ipt_bypass_for_if_inet_pos $WAN_IF $WAN_INET $_POS; NFO_IPT=$((NFO_IPT+($?<<INFO_IPT_WB_SHIFT))); }
  # Applying TUN Network Range Bypass (if applicable, needed and not skipped)
  sc_conf get tun.no_bypass >/dev/null || [ "$TUN_INET" ] && { _POS=$((1+_POS)); _set_ipt_bypass_for_if_inet_pos $TUN_IF $TUN_INET $_POS; NFO_IPT=$((NFO_IPT+($?<<INFO_IPT_TB_SHIFT))); }

  if [ "$_WL" ]; then
    # apply whitelist
    _POS=$((1+_POS)) 
    _WL_POS="$(echo "$_IPT_SRC"|/bin/sed -n "/$IPSET_WL_NAME/=")"
    if [ "$_WL_POS" != "$_POS" ]; then
      [ "$_WL_POS" ] && echo "$_IPT_SRC"|/bin/grep -F -- "$IPSET_WL_NAME"|/bin/sed "s/^-A/$IPT_COM -D/"|while read _CMD; do eval "$_CMD"; done
      $IPT_BIN -I "$IPTBL_SRC" $_POS -m set --match-set "$IPSET_WL_NAME" src -m comment --comment "in $SC_ABR whitelist" -j RETURN
      NFO_IPT=$((NFO_IPT+INFO_IPT_WL_SRC_NEW))
    fi
    _WL_POS="$(echo "$_IPT_DST"|/bin/sed -n "/$IPSET_WL_NAME/=")"
    if [ "$_WL_POS" != "$_POS" ]; then
      [ "$_WL_POS" ] && echo "$_IPT_DST"|/bin/grep -F -- "$IPSET_WL_NAME"|/bin/sed "s/^-A/$IPT_COM -D/"|while read _CMD; do eval "$_CMD"; done
      $IPT_BIN -I "$IPTBL_DST" $_POS -m set --match-set "$IPSET_WL_NAME" dst -m comment --comment "in $SC_ABR whitelist" -j RETURN
      NFO_IPT=$((NFO_IPT+INFO_IPT_WL_DST_NEW))
    fi
    NFO_IPT=$((NFO_IPT+INFO_IPT_WL))
  else
    #Removing any trace of whitelist if any
    echo "$_IPT"|/bin/grep -F -- "$IPSET_WL_NAME"|/bin/sed "s/^-A/$IPT_COM -D/"|while read _CMD; do eval "$_CMD"; done
    ipset -q destroy "$IPSET_WL_NAME" && NFO_IPS=$((NFO_IPS+INFO_IPS_WL_DEL))
  fi

  if sc_conf get log.enabled >/dev/null; then
    _POS=$((1+_POS))
    _LOG_POS="$(echo "$_IPT_SRC"|/bin/sed -n "/-j LOG/=")"
    if [ "$_LOG_POS" != "$_POS" ]; then
      [ "$_LOG_POS" ] && $IPT_BIN -D "$IPTBL_SRC" -j LOG --log-prefix "[$SC_NAME] "
      $IPT_BIN -I "$IPTBL_SRC" $_POS -j LOG --log-prefix "[$SC_NAME] "
      NFO_IPT=$((NFO_IPT+INFO_IPT_LOG_SRC_NEW))
      _logd_start && NFO_LOGD=$INFO_LOGD_STARTED || NFO_LOGD=$INFO_LOGD_KEEP_ON
    fi
    _LOG_POS="$(echo "$_IPT_DST"|/bin/sed -n "/-j LOG/=")"
    if [ "$_LOG_POS" != "$_POS" ]; then
      [ "$_LOG_POS" ] && $IPT_BIN -D "$IPTBL_DST" -j LOG --log-prefix "[$SC_NAME] "
      $IPT_BIN -I "$IPTBL_DST" $_POS -j LOG --log-prefix "[$SC_NAME] "
      NFO_IPT=$((NFO_IPT+INFO_IPT_LOG_DST_NEW))
    fi
    NFO_IPT=$((NFO_IPT+INFO_IPT_LOG))
  else
    $IPT_BIN -D "$IPTBL_SRC" -j LOG --log-prefix "[$SC_NAME] "
    $IPT_BIN -D "$IPTBL_DST" -j LOG --log-prefix "[$SC_NAME] "
    _logd_stop && NFO_LOGD=$INFO_LOGD_STOPPED
  fi
  _POS=$((1+_POS))
  _DROP_POS="$(echo "$_IPT_SRC"|/bin/sed -n "/-j DROP/=")"
  if [ "$_DROP_POS" != "$_POS" ]; then
    [ "$_DROP_POS" ] && echo "$_IPT_SRC"|/bin/grep -F -- "-j DROP"|/bin/sed "s/^-A/$IPT_COM -D/"|while read _CMD; do eval "$_CMD"; done
    $IPT_BIN -I "$IPTBL_SRC" $_POS -m comment --comment "$SC_ABR drop incoming" -j DROP
  fi
  _DROP_POS="$(echo "$_IPT_DST"|/bin/sed -n "/-j REJECT/=")"
  if [ "$_DROP_POS" != "$_POS" ]; then
    [ "$_DROP_POS" ] && echo "$_IPT_DST"|/bin/grep -F -- "-j REJECT"|/bin/sed "s/^-A/$IPT_COM -D/"|while read _CMD; do eval "$_CMD"; done
    $IPT_BIN -I "$IPTBL_DST" $_POS -m comment --comment "$SC_ABR reject outgoing" -j REJECT --reject-with icmp-admin-prohibited
  fi
  
  # checking and cleaning anything that is not WAN_IF or TUN_IF in IFO chains
  _IPT_IFO="$(echo "$_IPT"|/bin/grep -F -- "-m set --match-set $IPSET_BL_NAME"|eval $_GREP)"
  if [ "$_IPT_IFO" ]; then
    # we have some unwanted rules (likely old WAN_IF or TUN_IF)
    echo "$_IPT_IFO"|/bin/sed "s/^-A/$IPT_COM -D/"|while read _CMD; do eval "$_CMD"; done
    NFO_IPT=$((NFO_IPT+INFO_IPT_IFO_PBM))
  fi
  
  # creating the required iptables rules for wan interface
  _set_ipt_for_if_pos "$WAN_IF" 1
  NFO_IPT=$((NFO_IPT+($?<<INFO_IPT_WAN_SHIFT)))
  
  # creating the required iptables rules for vpn tunnel interface (if needed)
  if [ "$TUN_IF" ]; then
    _set_ipt_for_if_pos "$TUN_IF" 2
    NFO_IPT=$((NFO_IPT+($?<<INFO_IPT_TUN_SHIFT)))
  fi
  
  _cipset_end
  
  echo -ne "$((NFO_FROM+(NFO_IPS<<INFO_IPS_SHIFT)+(NFO_IPT<<INFO_IPT_SHIFT)+(NFO_LOGD<<INFO_LOGD_SHIFT))) $WAN_IF $TUN_IF" > "$INFO_FILE"
} 2>/dev/null

###############################################
#
#    CALLED FROM FIREWALL-START & POST-MOUNT
#
###############################################

#we are called from firewall_start.sh
if [ "$1" ] && [ "$1" = "_fws" ]; then
  sc_conf get up >/dev/null || exit 0
  shield_uprear "$INFO_FROM_FWS"
  exit 0
fi

#when called from post-mount.sh
_pm() {
  sc_conf get up >/dev/null || exit 0
  [ -d "$ROOT_DIR" ] || /bin/ln -sfn /tmp/mnt/$2/bolemo $ROOT_DIR
  sc_init
  shield_init
  shield_uprear "$INFO_FROM_PM"
  exit 0
}

###############################################
#
#    ADDITIONNAL GLOBALS NEEDED WHEN NOT CALLED FROM FIREWALL-START
#
###############################################
# ---------------------------------------------
: ENV START
# ---------------------------------------------
SC_NICEPATH="$ROOT_DIR/scripts/$SC_NAME"
SC_PATH="$(cd "$ROOT_DIR/scripts/">/dev/null 2>&1; pwd -P)"
SRC_LIST="$ROOT_DIR/etc/$SC_NAME.sources"
CUST_BL_FILE="$ROOT_DIR/etc/${SC_NAME}*.blacklist"
CUST_WL_FILE="$ROOT_DIR/etc/${SC_NAME}*.whitelist"
TMP_FILE="/tmp/$SC_NAME.tmp"
TMP_HTML="/tmp/$SC_NAME-html.tmp"
WWW_PATH="$ROOT_DIR/www"
FWS_DIR="/opt/scripts"
FWS_FILE="$FWS_DIR/firewall-start.sh"
# Check if script is installed on USB
if [ -z "${SC_PATH##/tmp/mnt/*}" ]; then
  PM_DIR="${SC_PATH%${SC_PATH#/tmp/mnt/*/}}autorun/scripts"
  PM_FILE="$PM_DIR/post-mount.sh"
  EXT_DRIVE=1
else
  EXT_DRIVE=''
fi
# ---------------------------------------------
: ENV STOP
# ---------------------------------------------

###############################################
#
#    DEALING WITH EXTERNAL SCRIPTS/CONFS
#    check, set, clean
#
###############################################

# SCRIPT: firewall-start.sh ###################
check_firewall_start() {
  [ -x "$FWS_FILE" ] || return 1
  [ "$(/bin/sed 's/[[:space:]]\+/ /g' "$FWS_FILE"|/bin/grep -c -- "\[ -x $SC_NICEPATH \] && $SC_NICEPATH _fws")" = 1 ] || return 1
  return 0
}

set_firewall_start() {
  [ -d "$FWS_DIR" ] || /bin/mkdir -p "$FWS_DIR"
  [ -e "$FWS_FILE" ] && /bin/sed -i "/$SC_NAME/d" "$FWS_FILE"
  echo -e "# Bolemo $SC_NAME\n[ -x $SC_NICEPATH ] && $SC_NICEPATH _fws" >> "$FWS_FILE"
  [ -x "$FWS_FILE" ] || /bin/chmod +x "$FWS_FILE"
}

clean_firewall_start() {
  if [ -e "$FWS_FILE" ]; then
    if [ "$(/bin/grep -Fv "$SC_NAME" "$FWS_FILE"|/bin/sed '/^[[:space:]]*$/d')" ]; then
      /bin/sed -i "/$SC_NAME/d" "$FWS_FILE"
      [ "$VERBOSE" ] && echo "- 'firewall-start.sh' has some other rules; removed only our rules."
    else
      /bin/rm "$FWS_FILE" 2>/dev/null
      [ "$VERBOSE" ] && echo "- 'firewall-start.sh' had no other rules; removed it."
    fi
  fi
}

# SCRIPT: post-mount.sh ########################
check_postmount() {
  [ -x "$PM_FILE" ] || return 1
  [ "$(/bin/sed 's/[[:space:]]\+/ /g' "$PM_FILE"|/bin/grep -cF -- "[ -x $SC_NICEPATH ] && $SC_NICEPATH _pm \$1")" = 1 ] || return 1
  return 0
}

set_postmount() {
  [ "$EXT_DRIVE" ] || return 1
  [ -d "$PM_DIR" ] || /bin/mkdir -p "$PM_DIR"
  [ -e "$PM_FILE" ] && /bin/sed -i "/$SC_NAME/d" "$PM_FILE"
  echo -e "# Bolemo $SC_NAME\n[ -x $SC_NICEPATH ] && $SC_NICEPATH _pm \$1" >> "$PM_FILE"
  [ -x "$PM_FILE" ] || /bin/chmod +x "$PM_FILE"
}

clean_postmount() {
  if [ "$EXT_DRIVE" ] && [ -e "$PM_FILE" ]; then
    if [ "$(/bin/grep -Fv "$SC_NAME" "$PM_FILE"|/bin/sed '/^[[:space:]]*$/d')" ]; then
      /bin/sed -i "/$SC_NAME/d" "$PM_FILE"
      [ "$VERBOSE" ] && echo "- 'post-mount.sh' has some other code; removed only our code."
    else
      /bin/rm "$PM_FILE" 2>/dev/null
      [ "$VERBOSE" ] && echo "- 'post-mount.sh' had no other code; removed it."
    fi
  fi
}

# SYMLINK: /usr/bin/SELF ######################
check_path() {
  command -v "$SC_NAME" > /dev/null && return 0 || return 1
}

set_path() {
  [ -e "/usr/bin/$SC_NAME" ] || /bin/ln -s "$SC_NICEPATH" "/usr/bin/$SC_NAME"
}

clean_path() {
  if [ -e "/usr/bin/$SC_NAME" ]; then /bin/rm "/usr/bin/$SC_NAME" 2>/dev/null
    [ $VERBOSE ] && echo "- '/usr/bin' symlink was removed."
  fi
}

# CONFIG: .../bolemo/etc/config/aegis #########
check_conf() {
  [ -d "$ROOT_DIR/etc/config" ] && sc_conf get && sc_conf get wan && sc_conf get tun && sc_conf get log
  return $?
} >/dev/null

set_conf() {
  [ -d "$ROOT_DIR/etc/config" ] || /bin/mkdir -p "$ROOT_DIR/etc/config" 2>/dev/null
  uci -qc $ROOT_DIR/etc/config import $SC_ABR << EOF
package $SC_ABR
config net-iface 'wan'
config net-iface 'tun'
config log 'log'
EOF
  sc_conf commit
}

clean_conf() {
  /bin/rm "$ROOT_DIR/etc/config/$SC_ABR" 2>/dev/null
  [ $VERBOSE ] && echo "- '$SC_NAME' configuration file was removed."
}

###############################################
#
#    FUNCTIONS DEPENDING ON BOLEMO GIT REPO
#
###############################################
# ---------------------------------------------
: ENV START
# ---------------------------------------------
BOLEMO_GIT_REPO='https://raw.githubusercontent.com/bolemo'
SC_BASE_REPO="$BOLEMO_GIT_REPO/$SC_NAME"
SC_MAIN_REPO="$SC_BASE_REPO/master"
SC_DEV_REPO="$SC_BASE_REPO/dev"

last_avail_version() {
  [ "$DEVMODE" ] && VERSION_URL="$SC_DEV_REPO/version" || VERSION_URL="$SC_MAIN_REPO/version"
  /usr/bin/wget -qO- "$VERSION_URL"
}

# ---------------------------------------------
: ENV STOP
# ---------------------------------------------

do_upgrade() {
echo "- Downloading:"
  DL_PATH="/tmp/$SC_NAME.dl"
  _PROG='--show-progress';
  [ "$DEVMODE" ] && _PROG="--no-cache $_PROG"
  echo -ne "\033[35m"
  if /usr/bin/wget -qO "$DL_PATH" $_PROG "$UPGRADE_URL"; then
    strip_sh_file "$DL_PATH"
    \/bin/mv "$DL_PATH" "$SC_NICEPATH"
    /bin/chmod +x "$SC_NICEPATH"
    echo -e "\033[0m- Script installed to $SC_NICEPATH"
  else
    echo -ne "\033[0m"
    >&2 echo -e "\033[31m! Wget error code $?! Could not download $DL_PATH\033[0m"
    /bin/rm -f "$DL_PATH"
    exit 1
  fi
  check_web && install_web
  exit 0
}

_upgrade() {
  UPGRADE_URL="$SC_MAIN_REPO/$SC_NAME"; UPGRADE_VER="$SC_LAST_VERS"
  do_upgrade
}

upgrade() {
  echo -e "\033[1;36mUpgrading:\033[0m"
  echo "- Version installed: $SC_VERS"
  if [ "$DEVMODE" ]; then
    echo "- Devmode on, force downloading from '$SC_DEV_REPO'..."
    UPGRADE_URL="$SC_DEV_REPO/$SC_NAME"
    UPGRADE_VER=$(/usr/bin/wget -qO- "$SC_DEV_REPO/version")
    [ -z "$UPGRADE_VER" ] && { >&2 echo -e "\033[31m! Could not get version!\033[0m";exit 1; }
  else
    echo -ne "- Checking latest available version...\r"
    SC_LAST_VERS="$(last_avail_version)"
    if [ "$SC_LAST_VERS" ]; then
      _LOC_VERS=$(echo "$SC_VERS"|/bin/sed 's/[^[:digit:]]//g')
      _REM_VERS=$(echo "$SC_LAST_VERS"|/bin/sed 's/[^[:digit:]]//g')
      if [ $_LOC_VERS -eq $_REM_VERS ]; then echo "- This is already the last version.            "; exit 0
      elif [ $_LOC_VERS -lt $_REM_VERS ]; then echo "- New version available: $SC_LAST_VERS         "
      else echo -e "\033[35m- This version is higher than than the one available: $SC_LAST_VERS         \033[0m"
      fi
    else
      >&2 echo -e "\033[31m! Could not check what is the last version online!\033[0m"
      exit 1
    fi
    UPGRADE_URL="$SC_MAIN_REPO/$SC_NAME"
    UPGRADE_VER="$SC_LAST_VERS"
  fi
  if [ ! "$DEVMODE" ]; then
    echo -n "? Do you want to upgrade from $SC_VERS to $SC_LAST_VERS (y/n)? "
    case "$(i=0;while [ $i -lt 2 ];do i=$((i+1));read -p '' YN </dev/tty;[ -n "$YN" ] && echo "$YN" && break;done)" in Y|y|yes|Yes|YES) : ;; *) exit 0 ;; esac
  fi
  do_upgrade
}

# get default sources list (from bolemo github)
get_def_srclst() {
  if [ ! -e "$SRC_LIST" ]; then
    [ "$VERBOSE" ] && echo -e "! $SRC_LIST is missing!"
    SRC_LIST_URL="$SC_MAIN_REPO/$SC_NAME.sources"
    if /usr/bin/wget -qO "$SRC_LIST" "$SRC_LIST_URL"; then
      [ "$VERBOSE" ] && echo -e "- Default list was downloaded."
    else
      >&2 echo -e "\033[31m! Wget error code $?! Could not download $SRC_LIST_URL\033[0m"
      /bin/rm -f "$SRC_LIST"
      exit 1
    fi
  fi
}

###############################################
#
#    WEB COMPANION RELATED FUNCTIONS
#
###############################################
WEB_NAME='Web Companion'
check_web() {
  [ -L "/www/bolemo" ] || return 1
  [ -e "/www/bolemo/aegis.htm" ] || return 1
  [ -x "/www/bolemo/cgi-bin/aegis_web.cgi" ] || return 1
  return 0
}

install_web() {
  [ -d "$WWW_PATH" ] || /bin/mkdir "$WWW_PATH" 2>/dev/null
  [ -d "$WWW_PATH/cgi-bin" ] || mkdir "$WWW_PATH/cgi-bin"
  if [ -z "$UPGRADE_URL" ]; then
    if [ "$DEVMODE" ]; then
      echo "- Devmode on, force downloading from '$SC_DEV_REPO'..."
      UPGRADE_URL="$SC_DEV_REPO/$SC_NAME"
    else
      UPGRADE_URL="$SC_MAIN_REPO/$SC_NAME"
    fi
  fi
  echo "- Downloading $WEB_NAME:"
  DL_PATH="/tmp/$SC_NAME.dl"
  _PROG='--show-progress';
  [ "$DEVMODE" ] && _PROG="--no-cache $_PROG"
  echo -ne "\033[35m"
  if /usr/bin/wget -qO "$DL_PATH" $_PROG "${UPGRADE_URL}.htm"; then
    \/bin/mv "$DL_PATH" "$WWW_PATH/$SC_NAME.htm"
    echo -e "\033[0m- $WEB_NAME htm file installed to $WWW_PATH/$SC_NAME.htm"
  else
    echo -ne "\033[0m"
    >&2 echo -e "\033[31m! Wget error code $?! Could not download $DL_PATH\033[0m"
    /bin/rm -f "$DL_PATH"
    exit 1
  fi
  echo -ne "\033[35m"
  if /usr/bin/wget -qO "$DL_PATH" $_PROG "${UPGRADE_URL}_web.cgi"; then
    strip_sh_file "$DL_PATH"
    \/bin/mv "$DL_PATH" "$WWW_PATH/cgi-bin/${SC_NAME}_web.cgi"
    /bin/chmod +x "$WWW_PATH/cgi-bin/${SC_NAME}_web.cgi"
    echo -e "\033[0m- $WEB_NAME cgi file installed to $WWW_PATH/cgi-bin/${SC_NAME}_web.cgi"
  else
    echo -ne "\033[0m"
    >&2 echo -e "\033[31m! Wget error code $?! Could not download $DL_PATH\033[0m"
    /bin/rm -f "$DL_PATH"
    exit 1
  fi
  if ! check_web; then
    /bin/rm -f "/www/bolemo" 2>/dev/null
    /bin/ln -sfn "$WWW_PATH" '/www/bolemo' 2>/dev/null
    echo "- $WEB_NAME paths were repaired."
  fi
  exit 0
}

clean_web() {
  /bin/rm -f "$WWW_PATH/$SC_NAME.htm"
  eval "$WWW_PATH/cgi-bin/${SC_NAME}_web.cgi uninstall"
  /bin/rm -f "$WWW_PATH/cgi-bin/${SC_NAME}_web.cgi"
  [ "$VERBOSE" ] && echo "- $WEB_NAME was removed."
} 2>/dev/null

###############################################
#
#    UTILITY FUNCTIONS
#
###############################################

strip_sh_file() { /bin/sed -i 's/^[[:space:]]*// ; 1!{/^#/d;s/#[^"\}'\'']*$//;} ; s/[[:space:]]*$// ; /^$/d ; s/   *\([^"'\'']*\)$/ \1/ ; s/^\(\([^"'\'' ]\+ \)*\) \+/\1/' "$1"; }

#name_from_ip() {
#  _NAME="$(/usr/bin/awk 'match($0,/'$1' /) {print $3;exit}' /tmp/netscan/attach_device)"
#  [ -z "$_NAME" ] && _NAME="$(/usr/bin/awk 'match($0,/'$1' /) {print $NF;exit}' /tmp/dhcpd_hostlist /tmp/hosts)"
#  [ -z "$_NAME" ] && echo "$1" || echo "$_NAME ($1)"
#} 2>/dev/null

###############################################
#
#    INIT FUNCTIONS
#    script init & shield init
#
###############################################

sc_init() {
  check_path || set_path
  [ -d "$ROOT_DIR/etc" ] || /bin/mkdir "$ROOT_DIR/etc"
  check_conf || set_conf
  [ -d "$WWW_PATH" ] || /bin/mkdir "$WWW_PATH"
  [ -d '/www/bolemo' ] || /bin/ln -sfn "$WWW_PATH" '/www/bolemo'
} 2>/dev/null

shield_init() {
  [ "$VERBOSE" ] && echo -e "\033[1;36mInitializing...\033[0m"
  ipset -q destroy $IPSET_TMP
  if check_conf
    then [ "$VERBOSE" ] && echo "- Configuration file is set."
    else { >&2 echo -e "\033[31m! Problem with the configuration system!\033[0m"; exit 1; }
  fi
  if check_firewall_start; then
    [ "$VERBOSE" ] && echo "- 'firewall-start.sh' is in place and ok."
  else
    set_firewall_start
    check_firewall_start || { >&2 echo -e "\033[31m! Problem with $FWS_FILE!\033[0m"; exit 1; }
    [ "$VERBOSE" ] && echo "- 'firewall-start.sh' was edited and is now ok."
  fi
  if [ "$EXT_DRIVE" ]; then
    [ "$VERBOSE" ] && echo "- '$SC_NAME' is installed on external drive."
    if check_postmount; then
      [ "$VERBOSE" ] && echo "- 'post-mount.sh' is in place and ok."
    else
      set_postmount
      check_postmount || { >&2 echo -e "\033[31m! Problem with $PM_FILE!\033[0m"; exit 1; }
      [ "$VERBOSE" ] && echo "- 'post-mount.sh' was edited and is now ok."
    fi
  else
    [ "$VERBOSE" ] && echo "- '$SC_NAME' is installed on internal drive."
  fi
}

###############################################
#
#    FUNCTIONS FOR SCRIPT CMD ARGUMENTS
#
###############################################

#_log_line_for_iface() { # $1 = iface / $2 = iface name
#  case $LINE in
#    *"IN=$1 OUT= "*) [ "$_DST" = '255.255.255.255' ] && _DNAME="broadcast" || _DNAME="router"
#       echo -e "$_PT Blocked \\033[1;35mincoming\\033[0m $_PROTO packet from $2: \\033[1;35m$_SRC$_SPT\\033[0m to $_DNAME: \\033[1;33m$_DST$_DPT\\033[0m" ;;
#    *"IN=$1"*) echo -e "$_PT Blocked \\033[1;35mincoming\\033[0m $_PROTO packet from $2: \\033[1;35m$_SRC$_SPT\\033[0m to LAN: \\033[1;33m$(name_from_ip $_DST)$_DPT\\033[0m" ;;
#    *"IN= OUT=$1"*) echo -e "$_PT Blocked \\033[1;33moutgoing\\033[0m $_PROTO packet to $2: \\033[1;35m$_DST$_DPT\\033[0m from router: \\033[1;33m$_SRC$_SPT\\033[0m" ;;
#    *"OUT=$1"*) echo -e "$_PT Blocked \\033[1;33moutgoing\\033[0m $_PROTO packet to $2: \\033[1;35m$_DST$_DPT\\033[0m from LAN: \\033[1;33m$(name_from_ip $_SRC)$_SPT\\033[0m" ;;
#    *) return 1 ;;
#  esac;
#}

#print_log() {
#  _logd_status || echo -e "\033[35mLogging is disabled!\033[0m"
#  echo -e "\033[1;36mLog:\033[0m"
#  [ $1 ] && _TAIL=$1 || _TAIL=100
#  _BT=$(( $(/bin/date +%s) - $(/usr/bin/cut -d. -f1 /proc/uptime) ))
#  /usr/bin/tail -n$_TAIL $LOG_FILE | while IFS= read -r LINE; do
#    _TS=$(echo $LINE|/usr/bin/cut -d: -f1)
#    _PT="$(/bin/date -d $((_BT+_TS)) -D %s +"%F %T")"
#
#    _1=${LINE#* SRC=}; _SRC=${_1%% *}
#    _1=${LINE#* DST=}; _DST=${_1%% *}
#    _1=${LINE#* PROTO=}; _PROTO=${_1%% *}; [ -z "${_PROTO##*[!0-9]*}" ] || _PROTO="[protocol $_PROTO]"
#    _1=${LINE#* SPT=}; [ "$_1" = "$LINE" ] && _SPT='' || _SPT=":${_1%% *}"
#    _1=${LINE#* DPT=}; [ "$_1" = "$LINE" ] && _DPT='' || _DPT=":${_1%% *}"
#
#    _log_line_for_iface $WAN_IF 'WAN' || { [ $TUN_IF ] && _log_line_for_iface $TUN_IF 'TUN'; }
#  done
#}
print_log() {
  _UPT=$(/usr/bin/cut -d. -f1 /proc/uptime)
  _logd_status || echo -e "\033[35mLogging is disabled!\033[0m"
  echo -e "\033[1;36mLog:\033[0m"
  case "$1" in '') _TAIL=100; _LSCI=0 ;; 0) _TAIL=100; _LSCI=$_UPT ;; *) _TAIL=$1 _LSCI=0 ;; esac
  _LSC=/tmp/aegis_lsc; echo "$_LSCI">$_LSC; trap "rm $_LSC >/dev/null 2>&1; exit" INT TERM
  _BT=$(( $(/bin/date +%s) - _UPT ))
  _RSIZE=$(wc -l <$LOG_FILE)
while :; do while /usr/bin/awk -F: '
function namefromip(ip){
  cmd="/usr/bin/awk '"'"'$1==\""ip"\"{print $3;exit}'"'"' /tmp/netscan/attach_device";cmd|getline nm;close(cmd);
  if (!nm) {cmd="/usr/bin/awk '"'"'$1==\""ip"\"{print NF;exit}'"'"' /tmp/dhcpd_hostlist /tmp/hosts";cmd|getline nm;close(cmd)}
  if (nm) {nm=nm"("ip")"} else {nm=ip}
  return nm}
function protoname(proto){return (proto~/^[0-9]+$/)?"[protocol "proto"]":proto}
function getval(n){i=index(l[c]," "n"=");if(i==0)return;str=substr(l[c],i+length(n)+2);i=index(str," ");str=substr(str,0,i-1);return str}
function floored(a){return (a<0)?0:a}
function pline(iface){
  if (IN==iface){REM=SRC;RPT=SPT;LPT=DPT;DIR="\033[1;35mincoming\033[0m";DIR1="from";DIR2="to";
     if (OUT=="") {LOC=DST; LNM=(DST=="255.255.255.255")?"broadcast":"router"}
     else {LOC=namefromip(DST); LNM="LAN"}
  } else if (OUT==iface){REM=DST;RPT=DPT;LPT=SPT;DIR="\033[1;33moutgoing\033[0m";DIR1="to";DIR2="from";
     if (IN=="") {LOC=SRC; LNM="router"}
     else {LOC=namefromip(SRC); LNM="LAN"}
  } else return 0;
  return 1;}
$1$2>'$(cat $_LSC)'{ts[++b]=$1;l[b]=$0} END
{c=floored(b-'$_TAIL');while (c++<b){
  PT=strftime("%F %T", ('$_BT'+ts[c]));
  IN=getval("IN"); OUT=getval("OUT"); SRC=getval("SRC"); DST=getval("DST"); PROTO=protoname(getval("PROTO")); SPT=getval("SPT"); DPT=getval("DPT");
  if (pline("'$WAN_IF'")) {IFACE="WAN"} else if (pline("'$TUN_IF'")) {IFACE="VPN"}
  if (RPT) {RPT=":"RPT}; if (LPT) {LPT=":"LPT}
  printf("%s: Blocked %s %s packet %s %s:\033[1;35m%s%s\033[0m %s %s:\033[1;33m%s%s\033[0m\n",PT,DIR,PROTO,DIR1,IFACE,REM,RPT,DIR2,LNM,LOC,LPT)
} print $1$2 >"'$_LSC'"}'; do
  [ "$_LSCI" -eq 0 ] && break 2;
  _ASIZE=$(wc -l <$LOG_FILE); [ $_ASIZE -ge $_RSIZE ] && _RSIZE=$_ASIZE || { _RSIZE=$_ASIZE; break; }
  sleep 1
done <$LOG_FILE; done
rm $_LSC >/dev/null 2>&1
}

shield_up() {
  sc_conf set up=1; sc_conf commit
  shield_init
  [ $VERBOSE ] && echo -e "\033[1;36mUprearing $SC_NAME shield...\033[0m"
  if [ $1 ]; then
    [ -r "$BL_FILE" ] || { >&2 echo -e "\033[31m! $BL_FILE not readable!\033[0m"; exit 1; }
    [ $VERBOSE ] && echo "- Directives will be (re)loaded into $SC_NAME shield."
    _FORCE_NS_RELOAD=1
  fi
  sc_conf get log.enabled >/dev/null && [ $VERBOSE ] && echo "- Enabling logging."
  if [ $2 ]; then
    [ "$VERBOSE" ] && echo -e "- Restarting firewall with $SC_NAME shield.\033[0m"
    /usr/sbin/net-wall restart > /dev/null
  else shield_uprear "$INFO_FROM_SC" $_FORCE_NS_RELOAD
  fi
  [ $VERBOSE ] && echo "- Done."
}

shield_down() {
  [ $VERBOSE ] && echo -e "\033[1;36mWithdrawing shield...\033[0m"
  sc_conf delete up; sc_conf commit
  /bin/rm -f "$INFO_FILE"
  /usr/sbin/net-wall restart > /dev/null; [ $VERBOSE ] && echo "- Built-in firewall restarted."
  _logd_stop; [ $VERBOSE ] && echo "- Made sure the log daemon is off."
  ipset -q destroy "$IPSET_BL_NAME"; ipset -q destroy "$IPSET_WL_NAME"; ipset -q destroy "$IPSET_TMP"; [ $VERBOSE ] && echo "- Cleaned ipsets."
  [ $VERBOSE ] && echo "- Shield down."
}

clean() {
  [ $VERBOSE ] && echo -e "\033[1;36mUnsetting...\033[0m"
  clean_firewall_start
  clean_postmount
  if check_conf; then [ $RM_CONF ] && clean_conf || { sc_conf delete up; sc_conf commit; }; fi
  [ $RM_SYMLINK ] && check_path && clean_path
  [ $RM_WEB ] && check_web && clean_web
  /bin/rm -f "$INFO_FILE"
  /usr/sbin/net-wall restart > /dev/null; [ $VERBOSE ] && echo "- Built-in firewall restarted."
  _logd_stop; [ $VERBOSE ] && echo "- Made sure the log daemon is off."
  [ $RM_LOG ] && { rm $LOG_FILE 2>/dev/null; [ $VERBOSE ] && echo "- Removed log file."; }
  ipset -q destroy "$IPSET_BL_NAME"
  ipset -q destroy "$IPSET_WL_NAME"
  ipset -q destroy "$IPSET_TMP"
  [ $VERBOSE ] && echo "- Cleaned ipsets."
  [ -e "$TMP_FILE" ] && /bin/rm -f "$TMP_FILE"
  [ $VERBOSE ] && echo -e "- Removed temporary files.\n- Done."
}

update_iplist() {
  [ "$VERBOSE" ] && echo -e "\033[1;36mUpdating directives file from sources and custom lists...\033[0m"
  [ -e "$SRC_LIST" ] || get_def_srclst

  :>"$TMP_FILE"
  # Process each source url
  [ "$VERBOSE" ] && echo "- Downloading lists defined in $SRC_LIST"
  [ "$VERBOSE" ] && WGET_OPTS='-qO- --show-progress' || WGET_OPTS='-qO-'
  _NBOK=0; _TOT=0;
  /bin/grep -v "^[[:space:]*\#]" "$SRC_LIST" | \
  { while read -r URL; do
      _TOT=$((_TOT+1))
      [ "$VERBOSE" ] && echo -e "$_TOT) $URL\033[35m"
      { { { { /usr/bin/wget $WGET_OPTS "$URL"; echo $? >&3; } |/bin/grep '^[0-9]'|/bin/sed 's/;.*//' >>"$TMP_FILE"; } 3>&1; } | { read _EC; exit $_EC; } }
      _EC=$?
      [ "$VERBOSE" ] && echo -e "\033[0m"
      [ $_EC = 0 ] && _NBOK=$((_NBOK+1)) || >&2 echo -e "\033[31m! Wget error code $_EC! Could not download $URL\033[0m"
    done
    [ $_NBOK = 0 ] && { >&2 echo -e "\033[31m! Could not get any list!\033[0m"; rm "$TMP_FILE"; exit 1; }
    [ $_NBOK = $_TOT ] || >&2 echo -e "\033[31m! Downloaded only $_NBOK / $_TOT list(s)!\033[0m"
  }
  if ( for F in $CUST_BL_FILE; do test -r $F || exit 1; done; ); then
    [ "$VERBOSE" ] && echo "- Adding netset from custom blacklist(s)..."
    /usr/bin/awk -F'[#;]' 'match($1,/^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+(\/[0-9]+)?$/) {print $1}' $CUST_BL_FILE >>"$TMP_FILE"
  fi
  if [ -x "$IPR_BIN" ]; then
    [ "$VERBOSE" ] && echo "- Optimizing and reducing netset (using iprange)..."
    $IPR_BIN --ipset-reduce 20 "$TMP_FILE" > "$BL_FILE"
  else
    [ "$VERBOSE" ] && echo -e "- iprange not installed, passing optimization and reduction process.\n- Removing duplicates..."
    /usr/bin/sort "$TMP_FILE"|/usr/bin/uniq > "$BL_FILE"
  fi
  /bin/rm -f "$TMP_FILE"
  [ "$VERBOSE" ] && echo "- Done."

  # processing whitelist if any
  if ( for F in $CUST_WL_FILE; do test -r $F || exit 1; done; ); then
    [ "$VERBOSE" ] && echo -e "\033[1;36mGenerating whitelist directives from custom list(s)...\033[0m"
    /usr/bin/awk -F'[#;]' 'match($1,/^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+(\/[0-9]+)?$/) {print $1}' $CUST_WL_FILE >>"$TMP_FILE"
    
    if [ -s "$TMP_FILE" ]; then
      if [ -x "$IPR_BIN" ]; then
        if [ "$($IPR_BIN --common "$BL_FILE" "$TMP_FILE")" ]; then
          [ "$VERBOSE" ] && echo "- Optimizing and reducing netset (using iprange)..."
          $IPR_BIN --ipset-reduce 20 "$TMP_FILE"  > "$WL_FILE"
        else
          echo '- No IP in common with blocklist directives, skipping whitelist directives.'
        fi
      else
        [ "$VERBOSE" ] && echo -e "- iprange not installed, passing optimization and reduction process.\n- Removing duplicates..."
        /usr/bin/sort "$TMP_FILE"|/usr/bin/uniq > "$WL_FILE"
      fi
      else echo '- No IP set found, custom whitelist is empty.'
    fi
    /bin/rm -f "$TMP_FILE"
    [ "$VERBOSE" ] && echo "- Done."
  else
    /bin/rm -f "$WL_FILE"
  fi
}

info() {
  echo -e "\033[1;36mInfo:\033[0m"
  if [ -r "$SRC_LIST" ] && [ -d $(dirname "$BL_FILE") ] && [ -d $(dirname "$TMP_FILE") ];
    then echo -n "- '$SC_NAME' version $SC_VERS is installed "; [ "$EXT_DRIVE" ] && echo 'on external drive.' || echo 'on internal drive.'
    else echo -e "\033[31m! Something is wrong with installation!\033[0m"
  fi
  echo -ne "- Checking latest available version...\r"
  SC_LAST_VERS="$(last_avail_version)";
  if [ "$SC_LAST_VERS" ]; then
    _LOC_VERS=$(echo "$SC_VERS"|/bin/sed 's/[^[:digit:]]//g')
    _REM_VERS=$(echo "$SC_LAST_VERS"|/bin/sed 's/[^[:digit:]]//g')
    if [ $_LOC_VERS -eq $_REM_VERS ]; then echo "- This is the last version.            "
    elif [ $_LOC_VERS -lt $_REM_VERS ]; then echo -e "\033[35m- New version available: $SC_LAST_VERS       \033[0m"
    else echo -e "\033[35m- This version is higher than than the one available: $SC_LAST_VERS       \033[0m"
    fi
  else echo -e "\033[31m! Could not check what is the last version online!\033[0m"
  fi
  if check_path
    then echo "- '$SC_NAME' is in PATH."
    else echo "- '$SC_NAME' is not in PATH (you need to use $NICE_PATH)."
  fi
  # check iprange binary
  [ "$IPR_BIN" ] && echo "- 'iprange' is installed: $($IPR_BIN --version | /usr/bin/head -n 1)" || echo "- 'iprange' is not installed."
  # check web compagnon
  check_web && echo "- $WEB_NAME is installed." || echo "- $WEB_NAME is not installed."
}

#---------------------------- _STATUS ----------------------------
# ---------------------------------------------
: ENV START
# ---------------------------------------------
# STATUS VARS
CK_FWS=1             # CK PB
CK_PM=2              # CK PB
CK_ENV_MASK=3
CK_IPS_BL=4          # CK PB
CK_IPS_WL=8          # CK PB
CK_IPT_CH=16         # CK PB
CK_IPT_WAN_BP=32     # CK PB WN
CK_IPT_TUN_BP=64     # CK PB WN
CK_IPT_WL=128        # CK PB
CK_IPT_LOG=256       # CK ..
PB_IPT_IFO=256       # .. PB
CK_IPT_TUN=512       # CK PB
CK_IPT_WAN=1024      # CK PB
PB_IPT_WAN_MISS=2048 # .. PB

WN_BL_FILE_DIFF=1   # . . . . . . _ x
WN_BL_FILE_MISS=2   # . . . . . . x _
WN_BL_FILE_NTLD=3   # . . . . . . x x
WN_WL_FILE_DIFF=4   # . . . . _ x . .
WN_WL_FILE_MISS=8   # . . . . x _ . .
WN_WL_FILE_NTLD=12  # . . . . x x . .
WN_TUN_MISS=16      # . . . x . . . .
# 32 CK_IPT_WAN_BP -> WAN BYPASS MISSING
# 64 CK_IPT_TUN_BP -> TUN BYPASS MISSING
WN_LOG_DIFF=128     # x . . . . . . .

CK_MASK=2047 #11 bits
PB_MASK=4095 #12 bits
WN_MASK=255  #8 bits

# ---------------------------------------------
: ENV EOF
# ---------------------------------------------

chain_status() {
  [ "$1" = 'src' ] && { _DIR='-s'; _PUT='-i'; _IPTBL_CH=$IPTBL_SRC; _RULE='DROP'; } || { _DIR='-d'; _PUT='-o'; _IPTBL_CH=$IPTBL_DST; _RULE='REJECT'; }
  _CH_CK=0
  _CH_PB=0
  _CH_IPT="$(echo "$_IPT"|/bin/grep -nF -- "-A $_IPTBL_CH")"
  _SL="$(echo $_CH_IPT|/usr/bin/cut -d: -f1)"
  if [ "$_CH_IPT" ]; then
    _LL=$((_SL+$(echo "$_CH_IPT"|/usr/bin/wc -l)-1))
    if [ "$(echo "$_CH_IPT"|/bin/grep -F -- "-j $_RULE"|/usr/bin/cut -d: -f1)" = $_LL ]; then _CH_CK=$((_CH_CK+CK_IPT_CH))
      _CL=$_SL # current line
      local _MKTMP="$(/bin/mktemp /tmp/${SC_ABR}_tmp_XXXXXX)"
      echo "$_CH_IPT"|/bin/grep -F -- "-m comment --comment \"$SC_ABR inet bypass\"" >$_MKTMP
      while read -r _BPL; do
        [ -z "$_BPL" ] && break
        [ "$(echo $_BPL|/usr/bin/cut -d: -f1)" != "$_CL" ] && { _CH_PB=$((_CH_PB+CK_IPT_CH)); break 2; }
        case "$_BPL" in
          *"$_DIR $_WAN_INET $_PUT $WAN_IF"*) # we have WAN with correct inet
            if [ $((_CH_CK&CK_IPT_WAN_BP)) = 0 ]; then                          _CH_CK=$((_CH_CK+CK_IPT_WAN_BP))
            elif [ $((_CH_PB&CK_IPT_WAN_BP)) = 0 ]; then                        _CH_PB=$((_CH_PB+CK_IPT_WAN_BP))
            fi ;;
          *"$_PUT $WAN_IF "*) # we have WAN with wrong inet
            [ $((_CH_PB&CK_IPT_WAN_BP)) = 0 ] &&                                _CH_PB=$((_CH_PB+CK_IPT_WAN_BP))
            ;;
          *"$_DIR $_TUN_INET $_PUT $TUN_IF "*)
            if [ $((_CH_CK&CK_IPT_TUN_BP)) = 0 ]; then                          _CH_CK=$((_CH_CK+CK_IPT_TUN_BP))
            elif [ $((_CH_PB&CK_IPT_TUN_BP)) = 0 ]; then                        _CH_PB=$((_CH_PB+CK_IPT_TUN_BP))
            fi ;;
          *"$_PUT $TUN_IF "*) # we have TUN with wrong inet
            [ $((_CH_PB&CK_IPT_TUN_BP)) = 0 ] &&                                _CH_PB=$((_CH_PB+CK_IPT_TUN_BP))
            ;;
          *) # we found a non matching interface
            _CH_PB=$((_CH_PB+CK_IPT_CH)); break 2
            ;;
        esac
        _CL=$((_CL+1))
      done <$_MKTMP; rm $_MKTMP
      if [ "$(echo "$_CH_IPT"|/bin/grep -F -- "$IPSET_WL_NAME"|/usr/bin/cut -d: -f1)" = $_CL ]; then _CH_CK=$((_CH_CK+CK_IPT_WL))
        _CL=$((_CL+1))
      fi
      if [ "$(echo "$_CH_IPT"|/bin/grep -F -- 'LOG'|/usr/bin/cut -d: -f1)" = $_CL ]; then            _CH_CK=$((_CH_CK+CK_IPT_LOG))
        _CL=$((_CL+1))
      fi
      [ $_CL = $_LL ] ||                                                         _CH_PB=$((_CH_PB+CK_IPT_CH))
    else                                                                         _CH_PB=$((_CH_PB+CK_IPT_CH))
    fi
  fi
  [ "$1" = 'src' ] && { _S_CK=$_CH_CK; _S_PB=$_CH_PB; _S_IPT=$_CH_IPT; } || { _D_CK=$_CH_CK; _D_PB=$_CH_PB; _D_IPT=$_CH_IPT; }
}

_status() {
  _CK=0; _WN=0; _PB=0
  _BLC=0; _WLC=0
  _logd_status; _LOGD=$?
  _cipset_init
  
  # CHECK ENVIRONMENT
  # check firewall-start.sh script
  check_firewall_start &&                                                        _CK=$((_CK+CK_FWS))
  # check post-mount.sh script if script on external drive
  [ "$EXT_DRIVE" ] && check_postmount &&                                         _CK=$((_CK+CK_PM))

  # CHECK BLOCKLIST (IPS, FILE)
  if _cipset_copy_set $IPSET_BL_NAME; then                                       _CK=$((_CK+CK_IPS_BL))
    _BLC=$(_cipset_count_set $IPSET_BL_NAME)
    if [ -r "$BL_FILE" ]; then
      _cipset_diff_set_file $IPSET_BL_NAME $BL_FILE ||                           _WN=$((_WN+WN_BL_FILE_DIFF))
    else                                                                         _WN=$((_WN+WN_BL_FILE_MISS))
    fi
  elif [ -r "$BL_FILE" ]; then                                                   _WN=$((_WN+WN_BL_FILE_NTLD))
  fi

  # CHECK WHITELIST (IPS, FILE)
  if _cipset_copy_set $IPSET_WL_NAME; then                                       _CK=$((_CK+CK_IPS_WL))
    _WLC=$(_cipset_count_set $IPSET_WL_NAME)
    if [ -r "$WL_FILE" ]; then
      _cipset_diff_set_file $IPSET_WL_NAME $WL_FILE ||                           _WN=$((_WN+WN_WL_FILE_DIFF))
    else                                                                         _WN=$((_WN+WN_WL_FILE_MISS))
    fi
  elif [ -r "$WL_FILE" ]; then                                                   _WN=$((_WN+WN_WL_FILE_NTLD))
  fi

  # CHECK IPTABLES
  get_ipt
  _WAN_INET=$(inet_for_if $WAN_IF)
  [ "$TUN_IF" ] && _TUN_INET=$(inet_for_if $TUN_IF)
  # -- SRC CHAIN
  chain_status src
  # -- DST CHAIN
  chain_status dst
  # -- SRC & DST
  if [ $_S_CK -eq $_D_CK ]; then                                                 _CK=$((_CK+_S_CK))
    if [ $_S_PB -eq $_D_PB ]; then                                               _PB=$((_PB+_S_PB))
    else                                                                         _PB=$((_PB+(_S_PB|_D_PB)))
    fi
  else                                                                           _PB=$((_PB+CK_IPT_CH))                                                                           
  fi
  # -- IFO (INPUT, FORWARD, OUTPUT)
  _IFO_IPT="$(echo "$_IPT"|/bin/grep -F -- "-m set --match-set $IPSET_BL_NAME")"
  if [ "$_IFO_IPT" ]; then
    _TCT=$(echo "$_IFO_IPT"|/usr/bin/wc -l)
    # checking VPN tunnel interface rules
    if [ "$TUN_IF" ]; then
      _CT=$(echo "$_IFO_IPT"|/bin/grep -cF -- "$TUN_IF"); _TCT=$((_TCT-_CT))
      case "$_CT" in
        4)                                                                       _CK=$((_CK+CK_IPT_TUN));;
        0)                                                                       _WN=$((_WN+WN_TUN_MISS));;
        *)                                                                       _PB=$((_PB+CK_IPT_TUN));;
      esac
    fi
    # checking WAN interface rules
    _CT=$(echo "$_IFO_IPT"|/bin/grep -cF -- "$WAN_IF"); _TCT=$((_TCT-_CT))
    case "$_CT" in
      4)                                                                         _CK=$((_CK+CK_IPT_WAN));;
      0)                                                                         _PB=$((_PB+PB_IPT_WAN_MISS));;
      *)                                                                         _PB=$((_PB+CK_IPT_WAN));;
    esac
    # checking if old rules exists or if corrupted
    [ $_TCT -ne 0 ] &&                                                           _PB=$((_PB+PB_IPT_IFO))
  fi

  # DEEPER CHECK
  if [ $_CK -gt $CK_ENV_MASK ]; then
  # -- PROBLEMS / WARNINGS
    # ENV
    [ $((_CK&CK_FWS)) -eq 0 ] &&                                                 _PB=$((_PB+CK_FWS))
    [ "$EXT_DRIVE" ] && [ $((_CK&CK_PM)) -eq 0 ] &&                              _PB=$((_PB+CK_PM))
    # BL
    [ $((_CK&CK_IPS_BL)) -eq 0 ] &&                                              _PB=$((_PB+CK_IPS_BL))
    # CH
    [ $(((_CK&CK_IPT_CH)+(_PB&CK_IPT_CH))) -eq 0 ] &&                            _PB=$((_PB+CK_IPT_CH))
    if [ $((_PB&CK_IPT_CH)) -eq 0 ]; then
      # BP
      _cipset_inet_in_bl $_WAN_INET && [ $(((_CK|_PB)&CK_IPT_WAN_BP)) -eq 0 ] &&                  _WN=$((_WN+CK_IPT_WAN_BP))
      [ "$TUN_IF" ] && _cipset_inet_in_bl $_TUN_INET && [ $(((_CK|_PB)&CK_IPT_TUN_BP)) -eq 0 ] && _WN=$((_WN+CK_IPT_TUN_BP))
      # WL
      _OK=$((CK_IPS_WL+CK_IPT_WL))
      if [ $((_CK&_OK)) -ne 0 ] && [ $((_CK&_OK)) -ne $_OK ]; then
        [ $((_CK&CK_IPS_WL)) -eq 0 ] &&                                                           _PB=$((_PB+CK_IPS_WL))
        [ $((_CK&CK_IPT_WL)) -eq 0 ] &&                                                           _PB=$((_PB+CK_IPT_WL))
      fi
      # LOG
      if [ $((_PB&CK_IPT_CH)) -eq 0 ]; then if sc_conf get log.enabled >/dev/null
        then [ $((_CK&CK_IPT_LOG)) -eq 0 ] &&                                                     _WN=$((_WN+WN_LOG_DIFF))
        else [ $((_CK&CK_IPT_LOG)) -ne 0 ] &&                                                     _WN=$((_WN+WN_LOG_DIFF))
      fi fi
    fi
    # IFO
  else
    [ $((_WN&WN_WL_FILE_NTLD)) -ne 0 ] && _WN=$((_WN-WN_WL_FILE_NTLD))
    [ $((_WN&WN_BL_FILE_NTLD)) -ne 0 ] && _WN=$((_WN-WN_BL_FILE_NTLD))
  fi
  
  _cipset_end
  
  echo -n "$_CK $_PB $_WN $_BLC $_WLC $_LOGD"
}

netset_exists() { test -e "$BL_FILE"; return $?; }

status_term() {
# variables are already set when calling _status from here. so no need to set variables from stdout here.
#  set -- $(_status); _CK=$1; _PB=$2; _WN=$3; _BLC=$4; _WLC=$5; _LOGD=$6
_status>/dev/null

  echo -e '\033[1;36mStatus:\033[0m'
  if [ $((_CK+_PB)) -eq 0 ]; then _RETVAL=1
    echo "- Shield is unset."
  elif [ $_CK -le $CK_ENV_MASK ] && [ $_PB -eq 0 ]; then _RETVAL=2
    echo "- Shield is down."
  else if [ $_CK -ne 0 ] && [ $_PB -eq 0 ]; then _RETVAL=0
      echo -ne "- \033[1;32mShield is up\033[0m"
      [ $((_CK&CK_IPT_WAN)) -ne 0 ] && echo -n " for WAN interface ($WAN_IF)"
      [ $((_CK&CK_IPT_TUN)) -ne 0 ] && echo -n " and VPN tunnel ($TUN_IF)"
      echo -e ".\n- Filtering $_BLC IP adresses."
      [ $((_CK&CK_IPT_WL)) -ne 0 ] && echo "- Bypassing $_WLC IP adresses."
    else _RETVAL=3
       echo -e "- \033[1;31mSomething is not right!\033[0m"
    fi
    if [ $_LOGD -eq 0 ]; then echo "- Logging is enabled."; else echo "- Logging is disabled."; fi
  fi
  
  if [ $_PB -ne 0 ]; then
    echo -ne '\033[1;31mErrors:\033[0m'; [ "$VERBOSE" -ge 2 ] && echo " (CODE: $_PB)" || echo ''
    [ $((_PB&CK_FWS)) -ne 0 ] &&     echo -e "\033[31m- set: firewall-start.sh is not set properly for $SC_NAME!\033[0m"
    [ $((_PB&CK_PM)) -ne 0 ] &&      echo -e "\033[31m- set: post-mount.sh is not set properly for $SC_NAME!\033[0m"
    [ $((_PB&CK_IPS_BL)) -ne 0 ] &&  echo -e "\033[31m- ipset: no blocklist is set!\033[0m"
    [ $((_PB&CK_IPS_WL)) -ne 0 ] &&  echo -e "\033[31m- ipset: no whitelist is set!\033[0m"
    [ $((_PB&CK_IPT_CH)) -ne 0 ] &&  echo -e "\033[31m- iptables: shield chains are not right!\033[0m"
    [ $((_PB&CK_IPT_WAN_BP)) -ne 0 ] &&  echo -e "\033[31m- iptables: WAN network range bypass rules are not right!\033[0m"
    [ $((_PB&CK_IPT_TUN_BP)) -ne 0 ] &&  echo -e "\033[31m- iptables: VPN network range bypass rules are not right!\033[0m"
    [ $((_PB&CK_IPT_WL)) -ne 0 ] &&  echo -e "\033[31m- iptables: whitelist rules are not right!\033[0m"
    [ $((_PB&CK_IPT_TUN)) -ne 0 ] &&      echo -e "\033[31m- iptables: VPN tunnel IFO rules are corrupted!\033[0m"
    [ $((_PB&CK_IPT_WAN)) -ne 0 ] &&      echo -e "\033[31m- iptables: WAN interface IFO rules are corrupted!\033[0m"
    [ $((_PB&PB_IPT_WAN_MISS)) -ne 0 ] && echo -e "\033[31m- iptables: WAN interface ($WAN_IF) IFO rules are missing!\033[0m"
    [ $((_PB&PB_IPT_IFO)) -ne 0 ] &&      echo -e "\033[31m- iptables: Extra shield IFO rules were found (likely from an old interface)!\033[0m"
  fi
  
  if [ $((_CK+_PB)) -ne 0 ] && [ $_WN -ne 0 ]; then
    echo -ne '\033[1;35mWarnings:\033[0m'; [ "$VERBOSE" -ge 2 ] && echo " (CODE: $_WN)" || echo ''
    case "$((_WN&WN_BL_FILE_NTLD))" in
      $WN_BL_FILE_DIFF) echo -e "\033[35m- directives: shield blocklist is different than file.\033[0m";;
      $WN_BL_FILE_MISS) echo -e "\033[35m- directives: shield blocklist is set but file is missing.\033[0m";;
      $WN_BL_FILE_NTLD) echo -e "\033[35m- directives: no shield blocklist is set but file exists.\033[0m";;
    esac
    case "$((_WN&WN_WL_FILE_NTLD))" in
      $WN_WL_FILE_DIFF) echo -e "\033[35m- directives: ipset whitelist set is different than file.\033[0m";;
      $WN_WL_FILE_MISS) echo -e "\033[35m- directives: ipset whitelist is set but file is missing.\033[0m";;
      $WN_WL_FILE_NTLD) echo -e "\033[35m- directives: no ipset whitelist is set but file exists.\033[0m";;
    esac
    [ $((_WN&CK_IPT_WAN_BP)) -ne 0 ] && echo -e "\033[31m- iptables: WAN network range bypass rules are missing!\033[0m"
    [ "$TUN_IF" ] && [ $((_WN&CK_IPT_TUN_BP)) -ne 0 ] && echo -e "\033[31m- iptables: VPN network range bypass rules are missing!\033[0m"
    [ $((_WN&WN_TUN_MISS)) -ne 0 ] && echo -e "\033[31m- iptables: VPN tunnel ($TUN_IF) IFO rules are missing!\033[0m"
    [ $((_WN&WN_LOG_DIFF)) -ne 0 ] && echo -e "\033[35m- current logging settings differs from last time shield was upreared.\033[0m"
  fi
 
  [ "$VERBOSE" ] || return 0

  echo -ne '\033[1;36mDetailed status:\033[0m'; [ "$VERBOSE" -ge 2 ] && echo " (CODE: $_CK)" || echo ''
  echo "- Active WAN interface is '$WAN_IF'."
  [ "$TUN_IF" ] && echo "- Active VPN tunnel is '$TUN_IF'." || echo "- no VPN tunnel found."
  # dates
  echo "- Actual router time: $(/bin/date +'%Y-%m-%d %X')"
  [ -e "$BL_FILE" ] && echo "- Blocklist directives generation time: $(/bin/date +'%Y-%m-%d %X' -r $BL_FILE)"
  [ -e "$WL_FILE" ] && echo "- Whitelist directives generation time: $(/bin/date +'%Y-%m-%d %X' -r $WL_FILE)"
  if [ $_CK -ne 0 ]; then
    [ $((_CK&CK_FWS)) -ne 0 ] &&        echo "- set: firewall-start.sh is set for $SC_NAME."
    [ $((_CK&CK_PM)) -ne 0 ] &&         echo "- set: post-mount.sh is set for $SC_NAME."
    [ $((_CK&CK_IPS_BL)) -ne 0 ] &&     echo "- ipset: blocklist is set."
    [ $((_CK&CK_IPS_WL)) -ne 0 ] &&     echo "- ipset: whitelist is set."
    [ $((_CK&CK_IPT_CH)) -ne 0 ] &&     echo "- iptables: shield chains are set."
    [ $((_CK&CK_IPT_WAN_BP)) -ne 0 ] && echo "- iptables: WAN network range bypass rules are set."
    [ $((_CK&CK_IPT_TUN_BP)) -ne 0 ] && echo "- iptables: VPN network range bypass rules are set."
    [ $((_CK&CK_IPT_WL)) -ne 0 ] &&     echo "- iptables: whitelist rules are set."
    [ $((_CK&CK_IPT_LOG)) -ne 0 ] &&    echo "- iptables: $SC_NAME logging rules are set."
    [ $((_CK&CK_IPT_TUN)) -ne 0 ] &&    echo "- iptables: VPN tunnel IFO rules are set."
    [ $((_CK&CK_IPT_WAN)) -ne 0 ] &&    echo "- iptables: WAN interface IFO rules are set."
  fi
  
  [ "$VERBOSE" -lt 2 ] && return 0

  # Status file
  echo -ne "\033[1;36mLast shield uprear report:\033[0m"
  if [ -r "$INFO_FILE" ]; then
    read INFO INFO_WAN INFO_TUN<"$INFO_FILE"
    INFO_FROM=$((INFO&INFO_FROM_MASK))
    INFO_IPS=$(((INFO>>INFO_IPS_SHIFT)&INFO_IPS_MASK))
    INFO_IPT=$(((INFO>>INFO_IPT_SHIFT)&INFO_IPT_MASK))
    INFO_LOGD=$(((INFO>>INFO_LOGD_SHIFT)&INFO_LOGD_MASK))
    echo " (CODE: $INFO_FROM-$INFO_IPS-$INFO_IPT-$INFO_LOGD)"
    case "$INFO_FROM" in
      $INFO_FROM_SC) FROM="$SC_NAME script" ;;
      $INFO_FROM_PM) FROM="post-mount.sh" ;;
      $INFO_FROM_FWS) FROM="firewall-start.sh" ;;
    esac
    echo "- shield was upreared from: $FROM @ $(/bin/date +'%Y-%m-%d %X' -r $INFO_FILE)"
    echo "- WAN interface was '$INFO_WAN'."
    [ "$INFO_TUN" ] && echo "- VPN tunnel was '$INFO_TUN'." || echo '- No VPN tunnel was found.'
    case $((INFO_IPS&INFO_IPS_BL_MASK)) in
      0) echo '! directives: blocklist file was not found!' ;;
      $INFO_IPS_BL_SAME) echo '- directives: ipset blocklist was already set and identical to file.' ;;
      $INFO_IPS_BL_MISS) echo '- directives: blocklist file was not found! The one already in ipset was kept.' ;;
      $INFO_IPS_BL_LOAD) echo '- directives: ipset blocklist was set from file.' ;;
    esac
    case $((INFO_IPS&INFO_IPS_WL_MASK)) in
      0) echo '- directives: no whitelist file was found.' ;;
      $((INFO_IPS_WL_SAME+INFO_IPS_WL_KEEP))) echo '- ipset: whitelist was already set and identical to directives.' ;;
      $INFO_IPS_WL_KEEP) echo '- directives: ipset whitelist was kept.' ;;
      $INFO_IPS_WL_LOAD) echo '- directives: ipset whitelist was set from file.' ;;
      $INFO_IPS_WL_SWAP) echo '- directives: ipset whitelist was updated from file.' ;;
      $INFO_IPS_WL_DEL) echo '- directives: ipset whitelist was unset.' ;;
    esac
    if [ $((INFO_IPT & INFO_IPT_SRC_KEEP)) -eq 0 ]
      then echo "- iptables: shield inbound chain was set."
      else echo "- iptables: shield inbound chain was already set."
    fi
    if [ $((INFO_IPT & INFO_IPT_DST_KEEP)) -eq 0 ]
      then echo '- iptables: shield outbound chain was set.'
      else echo '- iptables: shield outbound chain was already set.'
    fi
    [ $((INFO_IPT & INFO_IPT_IB_PBM)) -ne 0 ] && echo '- iptables: some irrelevant bypass rules had to be removed.'
    if [ $((INFO_IPS & INFO_IPS_WB_NDD)) -ne 0 ]; then
      if [ $((INFO_IPT & INFO_IPT_WB_SRC_NEW)) -ne 0 ]
        then echo '- iptables: inbound WAN network range bypass rules were set.'
        else echo '- iptables: inbound WAN network range bypass rules were kept.'
      fi
      if [ $((INFO_IPT & INFO_IPT_WB_DST_NEW)) -ne 0 ]
        then echo '- iptables: outbound WAN network range bypass rules were set.'
        else echo '- iptables: outbound WAN network range bypass rules were kept.'
      fi
    else echo '- iptables: WAN network range bypass rules were not needed or manually skipped.'
    fi
    if [ $((INFO_IPS & INFO_IPS_TB_NDD)) -ne 0 ]; then
      if [ $((INFO_IPT & INFO_IPT_TB_SRC_NEW)) -ne 0 ]
        then echo '- iptables: inbound VPN network range bypass rules were set.'
        else echo '- iptables: inbound VPN network range bypass rules were kept.'
      fi
      if [ $((INFO_IPT & INFO_IPT_TB_DST_NEW)) -ne 0 ]
        then echo '- iptables: outbound VPN network range bypass rules were set.'
        else echo '- iptables: outbound VPN network range bypass rules were kept.'
      fi
    else [ "$INFO_TUN" ] && echo '- iptables: VPN network range bypass rules were not needed or manually skipped.'
    fi
    if [ $((INFO_IPT & INFO_IPT_WL)) -ne 0 ]; then
      if [ $((INFO_IPT & INFO_IPT_WL_SRC_NEW)) -ne 0 ]
        then echo '- iptables: inbound whitelist rules were set.'
        else echo '- iptables: inbound whitelist rules were kept.'
      fi
      if [ $((INFO_IPT & INFO_IPT_WL_DST_NEW)) -ne 0 ]
        then echo '- iptables: outbound whitelist rules were set.'
        else echo '- iptables: outbound whitelist rules were kept.'
      fi
    fi
    if [ $((INFO_IPT & INFO_IPT_LOG)) -ne 0 ]; then
      if [ $((INFO_IPT & INFO_IPT_LOG_SRC_NEW)) -ne 0 ]
        then echo '- iptables: inbound logging rules were set.'
        else echo '- iptables: inbound logging rules were kept.'
      fi
      if [ $((INFO_IPT & INFO_IPT_LOG_DST_NEW)) -ne 0 ]
        then echo '- iptables: outbound logging rules were set.'
        else echo '- iptables: outbound logging rules were kept.'
      fi
    fi
    
    [ $((INFO_IPT & INFO_IPT_IFO_PBM)) -ne 0 ] && echo '- iptables: some irrelevant IFO rules had to be removed.'
    if [ $((INFO_IPT & INFO_IPT_WAN_PBM)) -eq $INFO_IPT_WAN_PBM ]; then echo '- iptables: WAN interface IFO rules had to be reset.'
    elif [ $((INFO_IPT & INFO_IPT_WAN_NEW)) -ne 0 ]; then echo '- iptables: WAN interface IFO rules were set.'
    elif [ $((INFO_IPT & INFO_IPT_WAN_KEEP)) -ne 0 ]; then echo '- iptables: WAN interface IFO rules were kept.'
    fi
    if [ $((INFO_IPT & INFO_IPT_TUN_PBM)) -eq $INFO_IPT_TUN_PBM ]; then echo '- iptables: VPN tunnel IFO rules had to be reset.'
    elif [ $((INFO_IPT & INFO_IPT_TUN_NEW)) -ne 0 ]; then echo '- iptables: VPN tunnel IFO rules were set.'
    elif [ $((INFO_IPT & INFO_IPT_TUN_KEEP)) -ne 0 ]; then echo '- iptables: VPN tunnel IFO rules were kept.'
    fi
 
    case "$INFO_LOGD" in
      $INFO_LOGD_KEEP_OFF) echo '- log daemon: was already off.';;
      $INFO_LOGD_KEEP_ON)  echo '- log daemon: was already on.';;
      $INFO_LOGD_STOPPED)  echo '- log daemon: was turned off.';;
      $INFO_LOGD_STARTED)  echo '- log daemon: was turned on.';;
    esac
    
    echo -ne "\033[0m"
  else
    echo -e '\n- No status file found.'
  fi
  
  [ "$VERBOSE" -lt 3 ] && return 0
  
  if [ $((_CK+_PB)) -ne 0 ]; then
    echo -e "\033[1;36miptables:\033[0m"
    [ -z "$_IPT" ] && echo "- no $SC_NAME rules are set." || echo "$_IPT"|/bin/sed 's/^/- iptables /'
    ipset -L -n|/bin/grep -F -- "$SC_ABR"|while read _SET; do
      case "$_SET" in
        "$IPSET_BL_NAME") _NAME='blocklist' ;;
        "$IPSET_WL_NAME") _NAME='whitelist' ;;
        *) _NAME="$_SET" ;;
      esac
      echo -e "\033[1;36mipset '$_NAME':\033[0m"
      ipset -L -t $_SET|/bin/sed 's/^/- /'
    done
  fi
  exit $_RETVAL
}

status_raw() {
  echo "$(_status) '$WAN_IF' '$TUN_IF'"; exit 0
}
#---------------------------- END _STATUS ----------------------------

print_help() { echo -e "\033[1;36m$SC_NAME $SC_VERS\033[0m"'
'"Usage: \033[1m$SC_NAME \033[35mCOMMAND \033[36m[OPTION(S)]\033[0m"'
'"\033[7mCOMMANDS (only one) and their specific options:\033[0m"'
'"\033[1;35mup\033[0m                  - (re)starts $SC_NAME shield protection"'
'"   \033[1;36m-net-wall\033[0m          + by restarting the internal firewall"'
'"   \033[1;36m-refresh\033[0m           + with updated shield directives"'
'"   \033[1;36m-log-enable\033[0m        + with logging enabled"'
'"   \033[1;36m-log-disable\033[0m       + with logging disabled"'
'"   \033[1;36m-wan-no-bypass\033[0m     + without WAN network range bypass"'
'"   \033[1;36m-vpn-no-bypass\033[0m     + without VPN network range bypass"'
'" \033[1;35mdown\033[0m               - stops $SC_NAME shield protection"'
'" \033[1;35mrefresh\033[0m            - updates shield directives from sources and custom lists\033[0m"'
'" \033[1;35mlog -enable\033[0m        - enables logging"'
'" \033[1;35mlog -disable\033[0m       - disables logging"'
'" \033[1;35mlog -show\033[0m          - displays the log report"'
'"   \033[1;36m-lines=\033[0mN           + will display N last lines (N being the number of lines to show)"'
'" \033[1;35mlog -live\033[0m          - displays the log report live (CTRL-C to exit)"'
'" \033[1;35mlog -get-history\033[0m   - show the history size for the log file $LOG_FILE"'
'" \033[1;35mlog -set-history=\033[0mN - sets the history size to N records for the log file $LOG_FILE"'
'" \033[1;35munset\033[0m              - stops and unsets $SC_NAME shield"'
'"   \033[1;36m-rm-config\033[0m         + and removes $SC_NAME configuration file"'
'"   \033[1;36m-rm-symlink\033[0m        + and removes the symlink /usr/bin/$SC_NAME"'
'"   \033[1;36m-rm-web\033[0m            + and removes $WEB_NAME"'
'"   \033[1;36m-rm-log\033[0m            + and removes log file"'
'" \033[1;35mhelp\033[0m               - displays help (this)"'
'" \033[1;35minfo\033[0m               - displays info on this script"'
'" \033[1;35mstatus\033[0m             - displays status"'
'" \033[1;35mupgrade\033[0m            - downloads and installs latest version"'
'" \033[1;35mweb -install\033[0m       - downloads and installs $WEB_NAME"'
'" \033[1;35mweb -remove\033[0m        - removes $WEB_NAME"'
'"\033[7mGENERAL OPTIONS (none, one or more, can be used with any command):\033[0m"'
'" \033[1;36m-v\033[0m                 + verbose mode (level 1)"'
'" \033[1;36m-vv\033[0m                + verbose mode (level 2)"'
'" \033[1;36m-vvv\033[0m               + verbose mode (level 3)"'
'" \033[1;36m-q\033[0m                 + quiet mode (no output)"
}

###############################################
#
#    MAIN ROUTINE
#
###############################################
[ $# = 0 ] && { >&2 echo -e "\033[31m! No parameter!\033[0m"; print_help; exit 1; }
[ "$1" = "_pm" ] && [ "$2" ] && _pm # Called from post-mount.sh, go to right processing...

ARGS=" $* "

if [ -z "${ARGS##* %devmode*% *}" ]; then
  if [ "${ARGS##* %devmode% *}" ]; then
    _DEV="$(echo "$ARGS"|/bin/sed 's/[^%]*%devmode \([^%]*\)%[^%]*/\1/')"
    echo "dev: '$_DEV'"
    if [ -z "${_DEV##*cmd=*}" ]; then
      _CMD="$(echo "$_DEV"|/bin/sed 's/.*cmd=\([^,$]*\).*/\1/')"
      echo "Executing command: '$_CMD'"
      eval "$_CMD"
    fi
    if [ -z "${_DEV##*repo=*}" ]; then
      _REPO="$(echo "$_DEV"|/bin/sed 's/.*repo=\([^,$]*\).*/\1/')"
      SC_DEV_REPO="$SC_BASE_REPO/$_REPO"
      echo "Using git path: '$SC_DEV_REPO'"
    fi
  fi
  DEVMODE=1
  ARGS="${ARGS% %devmode*% *} ${ARGS#* %devmode*% }"
  echo "Arguments: '$ARGS'"
fi

PARAM="$(echo "$ARGS" | /bin/sed 's/-[[:alpha:]=]*[[:space:]]*[[:digit:]]*//g')"
case $(echo "$PARAM"|/usr/bin/wc -w) in
  0) >&2 echo -e "\033[31m! No parameter!\033[0m"; print_help; exit 1 ;;
  1) PARAM="$(echo "$PARAM"|/bin/sed 's/ //g')" ;;
  *) >&2 echo -e "\033[31m! Too many parameters!\033[0m"; print_help; exit 1 ;;
esac

[ -z "${ARGS##* -v *}" ] && VERBOSE=1
[ -z "${ARGS##* -vv *}" ] && VERBOSE=2
[ -z "${ARGS##* -vvv *}" ] && VERBOSE=3
[ -z "${ARGS##* -q *}" ] && QUIET=1
_shield_args() {
  [ -z "${ARGS##* -log-enable *}" ]    && sc_conf set log.enabled=1
  [ -z "${ARGS##* -log-disable *}" ]   && sc_conf delete log.enabled
  [ -z "${ARGS##* -wan-no-bypass *}" ] && sc_conf set wan.no_bypass=1 || sc_conf delete wan.no_bypass
  [ -z "${ARGS##* -vpn-no-bypass *}" ] && sc_conf set tun.no_bypass=1 || sc_conf delete tun.no_bypass
  
  [ -z "${ARGS##* -net-wall *}" ]      && ST_FW=1      || ST_FW=
  [ -z "${ARGS##* -refresh *}" ]       && ST_US=1      || ST_US=
  
  sc_conf commit
}
_log_args() {
  case $ARGS in
    *' -enable '*)     sc_conf set log.enabled=1; sc_conf commit; sc_conf get up >/dev/null && { shield_up; [ $VERBOSE ] && status_term; } ;;
    *' -disable '*)    sc_conf delete log.enabled; sc_conf commit; sc_conf get up >/dev/null && { shield_up; [ $VERBOSE ] && status_term; } ;;
    *' -show '*) [ -z "${ARGS##* -lines=[0-9]*}" ] && _PL=$(echo "$ARGS"|/bin/sed 's/.* -lines=\([[:digit:]]\+\) .*/\1/') || _PL=''; print_log $_PL ;;
    *' -live '*) print_log 0 ;;
    *' -get-history '*) sc_conf get log.len ;;
    *' -set-history='[0-9]*) sc_conf set log.len=$(echo "$ARGS"|/bin/sed 's/.* -set-history=\([[:digit:]]\+\) .*/\1/'); sc_conf commit ;;
  esac
}
_clean_args() {
  [ -z "${ARGS##* -rm-config *}" ]     && RM_CONF=1    || RM_CONF=
  [ -z "${ARGS##* -rm-symlink *}" ]    && RM_SYMLINK=1 || RM_SYMLINK=
  [ -z "${ARGS##* -rm-web *}" ]        && RM_WEB=1     || RM_WEB=
  [ -z "${ARGS##* -rm-log *}" ]        && RM_LOG=1     || RM_LOG=
}

[ "$QUIET" ] && exec>/dev/null

sc_init

if [ $DEVMODE ]; then echo -e "\033[7;31m$SC_NAME $SC_VERS - Developer mode\033[0m"; VERBOSE=3
elif [ $VERBOSE ]; then echo -e "\033[7;31m$SC_NAME $SC_VERS - Verbose mode [level $VERBOSE]\033[0m"; fi

case "$PARAM" in
  'up') _shield_args;
        netset_exists || { ST_US=1; [ $VERBOSE ] && echo "- No directives were found! Refresh will be made."; }
        [ $ST_US ] && update_iplist;
        shield_up "$ST_US" "$ST_FW";
        [ $VERBOSE ] && status_term ;;
  'down') shield_down; [ $VERBOSE ] && status_term ;;
  
  'unset') _clean_args; clean; [ $VERBOSE ] && status_term ;;
  'refresh') update_iplist; sc_conf get up >/dev/null && { shield_up 1; [ $VERBOSE ] && status_term; } ;;
  
  'status') status_term ;;
  'help') print_help ;;
  'info') info ;;
  'log') _log_args ;;
  'upgrade') upgrade ;;
  'web') [ -z "${ARGS##* -install *}" ] && install_web; [ -z "${ARGS##* -remove *}" ] && clean_web ;;
  
  # calls for outside helpers (html)
  '_status') status_raw ;;
  '_up') _shield_args; VERBOSE=1; shield_up '' 1 ;;
  '_refresh') _shield_args; VERBOSE=1; update_iplist; shield_up 1 ;;
  '_down') VERBOSE=1; shield_down ;;
  '_upgrade') _upgrade ;;
  
  *) >&2 echo -e "\033[31m! Unknown Parameter $2!\033[0m"; print_help; exit 1 ;;
esac

exit
