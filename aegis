#! /bin/sh
# ----------- ENVIRONMENT VARIABLES -----------
# CAN BE SOURCED INTO UTILS USING AEGIS -------
# USING: eval "$(aegis _env)" -----------------
if [ "$1" == '_env' ]; then /usr/bin/awk '$0==": ENV EOF"{exit} $0==": ENV STOP"{e=0} e{print} $0==": ENV START"{e=1}' $0; exit; fi
# ---------------------------------------------
: ENV START
# ---------------------------------------------
{
! command -v iptables && export PATH=/bin:/sbin:/usr/bin:/usr/sbin
! command -v iprange && [ -e /root/.profile ] && source /root/.profile
SC_VERS="1.6.3"
SC_NAME="aegis"
SC_ABR="aegis"
IPR_BIN="$(/usr/bin/which iprange)"
IPT_COM='iptables'
IPT_BIN="/usr/sbin/$IPT_COM"
IPTBL_SRC="${SC_ABR}_src"
IPTBL_DST="${SC_ABR}_dst"
IPSET_BL_NAME="${SC_ABR}_bl"
IPSET_WL_NAME="${SC_ABR}_wl"
IPSET_TMP="${IPSET_BL_NAME}_tmp"
ROOT_DIR="/opt/bolemo"
BL_FILE="$ROOT_DIR/etc/${SC_NAME}.bl.directives"
WL_FILE="$ROOT_DIR/etc/${SC_NAME}.wl.directives"
INFO_FILE="/tmp/${SC_ABR}_status"
LOG_FILE="/var/log/log-$SC_ABR"
SHIELD_LOCK="/tmp/${SC_ABR}_lock"
CONF_DIR="$ROOT_DIR/etc/config"
ifconfig ppp0 && WAN_IF='ppp0' || WAN_IF="$(/bin/nvram get wan_ifname)"
# VPN tunnel detection
if ifconfig wg0; then
  # WireGuard
  TUN_IF='wg0'
else
  TUN_IF="$(ps -w|/bin/grep -F -- '/usr/sbin/openvpn --dev'|/bin/grep -vE 'grep|server_tap|server_tun')"
  [ "$TUN_IF" ] && TUN_IF=${TUN_IF##* --dev } && TUN_IF=${TUN_IF%% *} # Open VPN client or no tunneling
fi
STDERR=/dev/null
} >/dev/null 2>&1

# INFO FROM (2 bits)
INFO_FROM_MASK=3
INFO_FROM_FWS=1       # _ x
INFO_FROM_PM=2        # x _
INFO_FROM_SC=3        # x x

# INFO IPSET (5 bits)
INFO_IPS_SHIFT=2
INFO_IPS_MASK=31
                      # . . . _ _  PBM, BL FILE MISSING
INFO_IPS_BL_SAME=1    # . . . _ x  KEEP
INFO_IPS_BL_MISS=2    # . . . x _  KEEP
INFO_IPS_BL_LOAD=3    # . . . x x
INFO_IPS_BL_MASK=3    # . . . x x
INFO_IPS_WL_SAME=4    # _ . x . .  SAME => KEEP
INFO_IPS_WL_KEEP=8    # _ x . . .  KEEP
INFO_IPS_WL_LOAD=16   # x _ _ . .
INFO_IPS_WL_SWAP=20   # x _ x . . = RELOAD
INFO_IPS_WL_DEL=24    # x x _ . . => was there, was deleted
                      # _ _ _ . . => was not there, was not loaded
INFO_IPS_WL_MASK=28   # x x x . .

# INFO IPTABLES (8 bits)
INFO_IPT_SHIFT=7
INFO_IPT_MASK=255
INFO_IPT_KEEP=1       # . . . . . . . x
INFO_IPT_RUN=2        # . . . . . . x .
INFO_IPT_PBM=0        # . . . . . . _ _

INFO_IPT_WIF=4        # . . . . . x . .
INFO_IPT_TIF=8        # . . . . x . . .

INFO_IPT_WIB=16       # . . . x . . . .
INFO_IPT_TIB=32       # . . x . . . . .

INFO_IPT_WL=64        # . x . . . . . .
INFO_IPT_LOG=128      # x . . . . . . .

# INFO LOGD (2 bits) and _logd_start return code
INFO_LOGD_SHIFT=15
INFO_LOGD_STARTED=0        # _ _
INFO_LOGD_STOPPED=1        # _ x
INFO_LOGD_KEEP_ON=2        # x _
INFO_LOGD_KEEP_OFF=3       # x x
INFO_LOGD_MASK=3

# --------------- ENV FUNCTIONS ---------------

sc_conf() { [ -z "$2" ] && _OPT= || _OPT=".$2" ;/sbin/uci -qc $CONF_DIR $1 $SC_ABR$_OPT; return $?; }

get_ipt() { _IPT="$($IPT_BIN -S|/bin/grep -F "$SC_ABR")"
  if $DEBUG; then debug 'get_ipt'; echo "$_IPT"|/usr/bin/awk '{print "   "$0}'; fi
} >>"$STDERR" 2>&1

inet_for_if() {
  _IP="$(/usr/sbin/ip -4 addr show $1|/usr/bin/awk 'NR==2 {print $2;exit}')"
  if [ "$IPR_BIN" ]; then echo $_IP|iprange -
  else _IP=$(/bin/ipcalc.sh $_IP|/usr/bin/awk -F= '/NETWORK|PREFIX/ {ORS="/";print $2}');echo ${_IP%?}; fi
}

# ---------------------------------------------
: ENV STOP
# ---------------------------------------------

# ------------------- DEBUG -------------------

debug() { touch $STDERR; echo "$(/bin/date +%s) $SC_ABR: $*" >>"$STDERR"; }
export DEBUG STDERR="$(sc_conf get debug)"
if [ "$STDERR" ]; then DEBUG=true
  debug "$SC_NAME $SC_VERS launched [$0 $*] ["$(/bin/cat /module_name /hardware_version /firmware_version)"]"
  sc_conf show | /usr/bin/awk '{print "   - "$0}' >>"$STDERR"
else DEBUG=false STDERR=/dev/null
fi

_exit() { $DEBUG && debug "exiting with code: $1"; exit $1; }
_warn() { $DEBUG && debug "warning: $1"; >&2 echo -e "\033[31m! $1\033[0m"; [ "$2" ] && _exit $2; }

# -------------- LOGD FUNCTIONS ---------------
# Aegis logging daemon
# ---------------------------------------------
LOGD_NAME=${SC_ABR}-logd
LOGD_PID="/var/run/${LOGD_NAME}.pid"
LOGD_TMP="/tmp/$LOGD_NAME"
_logd_logmsg() { $DEBUG && debug "_logd_logmsg"
  if   test -e '/var/log/log-message'; then echo '/var/log/log-message'; return 0
  elif test -e '/var/log/log_message'; then echo '/var/log/log_message'; return 0
  else _warn "No log-message or log_message found!"; return 1
  fi
}
_logd_start() { $DEBUG && debug "_logd_start"
if [ -e $LOGD_PID ] && kill -0 $(cat $LOGD_PID); then # logd is already running
  if _logd_logmsg >/dev/null
    then $DEBUG && debug "returning with code INFO_LOGD_KEEP_ON"; return $INFO_LOGD_KEEP_ON
    else $DEBUG && debug "stopping log daemon"; _logd_stop; return $?
  fi
fi
sc_conf get log.len >/dev/null || { sc_conf set log.len=5000; sc_conf commit; }
local LOG_MSG=$(_logd_logmsg); if [ $? -ne 0 ]; then $DEBUG && debug "returning with code INFO_LOGD_KEEP_OFF"; return $INFO_LOGD_KEEP_OFF; fi;
cat >"$LOGD_TMP" <<EOF
$($DEBUG && echo -e "debug() { touch $STDERR; echo \"\$(/bin/date +%s) logd: \$1\"; } >>$STDERR\ndebug 'log daemon starting'")
/bin/rm -f $LOGD_TMP 2>/dev/null
trapf() { $($DEBUG && echo "debug \"trap signal: \$1\";") [ -e $LOGD_PID ] || exit; PID=\$(cat $LOGD_PID); /bin/rm -f $LOGD_PID; [ -e $LOGD_TMP ] && /bin/rm -f $LOGD_TMP; $($DEBUG && echo 'debug "log daemon exiting";') exit; } 2>>$STDERR
trap "trapf TERM" TERM; trap "trapf INT" INT; trap "trapf QUIT" QUIT; trap "trapf EXIT" EXIT
touch $LOG_FILE
inode() { set -- \$(/bin/ls -i $LOG_MSG); echo \$1; }
lc() { set -- \$(/usr/bin/wc -l \$1); echo \$1; }
while :; do
  local INODE=\$(inode)
  $($DEBUG && echo "debug \"working with log-message inode: \$INODE\"")
  local NUMLINES=\$(uci -qc $CONF_DIR get $SC_ABR.log.len)
  if [ -s $LOG_FILE ]; then
    $($DEBUG && echo "debug 'log-aegis exists and is not empty'")
    local FIRST_MSG_LINE="\$(/usr/bin/awk '/\[$SC_ABR\]/{print; exit}' $LOG_MSG)" # first line in rotated message log
    if [ "\$FIRST_MSG_LINE" ]; then
      local FIRST_EXT_TS="\$(/usr/bin/awk -F':' 'NR==1{print \$1; exit}' $LOG_FILE)" # first timestamp in our log
      if [ 0\${FIRST_MSG_LINE%%:*} -gt 0\$FIRST_EXT_TS ]; then :>$LOGD_TMP
        /usr/bin/awk '\$0=="'"\$FIRST_MSG_LINE"'"{exit} {print}' $LOG_FILE >>$LOGD_TMP
        if [ 0\$NUMLINES -lt 0\$(lc $LOGD_TMP) ]
          then /usr/bin/tail -n \$NUMLINES $LOGD_TMP >$LOG_FILE
          else /bin/cat $LOGD_TMP >$LOG_FILE
        fi
        $($DEBUG && echo "debug \"log-message 1st aegis record is more recent than log-aegis 1st record: kept older records from log-aegis up to \$NUMLINES\"")
      else :>$LOG_FILE $($DEBUG && echo "; debug 'log-message 1st aegis record is older than log-aegis 1st record: emptying log-aegis'")
      fi
    elif [ 0\$NUMLINES -lt 0\$(lc $LOG_FILE) ]
       then /usr/bin/tail -n \$NUMLINES $LOG_FILE >$LOGD_TMP; cat $LOGD_TMP >$LOG_FILE
          $($DEBUG && echo "debug \"no aegis log record in log-message; kept only \$NUMLINES records\"")
    fi
  else :>$LOG_FILE $($DEBUG && echo "; debug 'aegis-log was empty or inexistant, making sure file exists'")
  fi
  /bin/rm -f $LOGD_TMP
     # using LOG_FILE>LOGD_TMP>LOG_FILE allow to keep same inode for LOG_FILE
     # now, LOG_FILE ends just before LOG_MSG starts and is no longer than NUMLINES
  local C=1; local FC=false; local D=1
  while /usr/bin/awk -F: '/\[$SC_ABR\]/{st=index(\$0," ");if (\$1==pts) {c++} else {c=0;pts=\$1}; printf("%s:%.3d:%s\n",\$1,c,substr(\$0,st)); fflush()}'; do
    sleep 2 & wait \$!
    [ "\$INODE" != "\$(inode)" ] && break
    if [ \$C -eq 10 ]; then # check every C x 2 seconds
      if ! $IPT_BIN -w -C $IPTBL_SRC -j LOG --log-prefix "[$SC_ABR] "; then
        $($DEBUG && echo "debug \"checking iptables logging rules returned: \$?\"")
        if [ -e "$SHIELD_LOCK" ]; then $($DEBUG && echo "debug 'shield is locked, waiting for next check'" || echo ":")
        elif \$FC; then $($DEBUG && echo "debug 'shield is unlocked, this is second check: killing daemon';") kill \$(cat $LOGD_PID)
        $($DEBUG && echo "else debug 'shield is unlocked but waiting for second check'"); fi
        FC=true; C=5
      else FC=false; C=1; fi
    else C=\$((C+1)); fi
    if [ \$D -eq 300 ]; then $($DEBUG && echo "debug '10 minutes in the loop; breaking it.';") break
    else D=\$((D+1)); fi
  done <$LOG_MSG >>$LOG_FILE
done 2>>"$STDERR"
EOF
cd /tmp; /bin/sh $LOGD_NAME & echo $! >$LOGD_PID
return $INFO_LOGD_STARTED
}
_logd_stop() { $DEBUG && debug "_logd_stop"; [ -e $LOGD_PID ] && kill $(cat $LOGD_PID) && return $INFO_LOGD_STOPPED || return $INFO_LOGD_KEEP_OFF; } 2>/dev/null
_logd_status() { $DEBUG && debug "_logd_status"; [ -e $LOGD_PID ] && kill -0 $(cat $LOGD_PID); return $?; }

# ------------- CIPSET FUNCTIONS --------------
# Copy ipset in /tmp to work on it
# ---------------------------------------------
_cipset_trap() { $DEBUG && debug "_cipset_trap"; _cipset_end; exit; }
_cipset_init() { _CIPSET_DIR=$(/bin/mktemp -d "/tmp/${SC_ABR}_XXXXXX"); trap "_cipset_trap" TERM INT; $DEBUG && debug "_cipset_init (dir: $_CIPSET_DIR)"; } 2>>"$STDERR"
_cipset_end() { if [ -d "$_CIPSET_DIR" ]; then /bin/rm -rf $_CIPSET_DIR; fi; trap - TERM INT; $DEBUG && debug "_cipset_end"; } 2>>"$STDERR"
_cipset_copy_set() { $DEBUG && debug "_cipset_copy_set $*"
  if [ "$IPR_BIN" ]
    then return $({ { ipset -q -L "$1" 3>&1; echo $? >&3; }|/usr/bin/awk 'NR==1,/Members:/ {next};NF' >"$_CIPSET_DIR/$1"; } 3>&1)
    else return $({ { ipset -q -L "$1" 3>&1; echo $? >&3; }|/usr/bin/awk 'NR==1,/Members:/ {next};NF'|/usr/bin/sort >"$_CIPSET_DIR/$1"; } 3>&1)
  fi
} 2>>"$STDERR"
_cipset_diff_set_file() { $DEBUG && debug "_cipset_diff_set_file $*"
  if [ "$IPR_BIN" ]; then $IPR_BIN --quiet "$_CIPSET_DIR/$1" --diff "$2"; else /usr/bin/diff -q "$_CIPSET_DIR/$1" "$2" >/dev/null; fi
  return $?
} 2>>"$STDERR"
_cipset_swap_set_file() { $DEBUG && debug "_cipset_swap_set_file $*"
  /bin/cp -f $2 "$_CIPSET_DIR/$1"
  /usr/bin/awk '{l[c++]=$0} END {print "create '$IPSET_TMP' hash:net family inet maxelem "c; while(d<c){print "add '$IPSET_TMP' "l[d++]}}' "$_CIPSET_DIR/$1" | ipset restore
  ipset swap "$1" "$IPSET_TMP"; ipset destroy $IPSET_TMP
} 2>>"$STDERR"
_cipset_create_set_file() { $DEBUG && debug "_cipset_create_set_file $*"
  /bin/cp -f $2 "$_CIPSET_DIR/$1"
  /usr/bin/awk '{l[c++]=$0} END {print "create '$1' hash:net family inet maxelem "c; while(d<c){print "add '$1' "l[d++]}}' "$_CIPSET_DIR/$1" | ipset restore
} 2>>"$STDERR"
_cipset_inet_in_bl() { $DEBUG && debug "_cipset_inet_in_bl $*"
  [ -z "$IPR_BIN" ] && return 0 # we return true because without iprange, we are not checking thus we want the BP
  [ -z "$(echo "$1" | iprange "$_CIPSET_DIR/$IPSET_BL_NAME" --common - )" ] && return 1 || return 0
} 2>>"$STDERR"
_cipset_count_set() { $DEBUG && debug "_cipset_count_set $*"
  if [ "$IPR_BIN" ]; then $IPR_BIN "$_CIPSET_DIR/$1" -C|/usr/bin/cut -d, -f2
  else /bin/grep -oE '(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\/([0-9]{1,2})' "$_CIPSET_DIR/$1"|/usr/bin/awk -F / '{ count[$2]++ } END { for (mask in count) total+=count[mask]*2^(32-mask); print total }'
  fi
} 2>>"$STDERR"

###############################################
#
#    ENGINE-START
#
###############################################

shield_uprear() { $DEBUG && debug "|---> shield_uprear $*"
  NFO_FROM=$1
  [ "$2" ] && _RELOAD_WTD=true || _RELOAD_WTD=false

  NFO_IPS=0 NFO_IPT=0 NFO_LOGD=0
  _cipset_init
  # creating ipset blocklist if needed
  if _cipset_copy_set $IPSET_BL_NAME; then
    # an ipset blocklist is already loaded
    if [ -r "$BL_FILE" ]; then
      if $_RELOAD_WTD; then _RELOAD=true
      # checking if ipset and file are identical
      elif _cipset_diff_set_file $IPSET_BL_NAME $BL_FILE
        then _RELOAD=false; NFO_IPS=$((NFO_IPS+INFO_IPS_BL_SAME))
        else _RELOAD=true
      fi
    else
      # blocklist file is missing!
      _RELOAD=false
      NFO_IPS=$((NFO_IPS+INFO_IPS_BL_MISS))
    fi
    if $_RELOAD; then
    # reload is asked for; so need to swap ipset
      _cipset_swap_set_file $IPSET_BL_NAME $BL_FILE
      NFO_IPS=$((NFO_IPS+INFO_IPS_BL_LOAD))
    # else keeping existing blocklist
    fi
  elif [ -r "$BL_FILE" ]; then
    # netset file exists, so creating blocklist ipset from it
      _cipset_create_set_file $IPSET_BL_NAME $BL_FILE
      NFO_IPS=$((NFO_IPS+INFO_IPS_BL_LOAD))
  else # no netset file, exiting with _IPS=0
    $DEBUG && debug "no ipset or file blocking directives! Exiting..."; _exit 1
  fi
  
  # creating ipset whitelist if needed
  [ -r "$WL_FILE" ] && _WL=true || _WL=false
  _DWL=false
  if _cipset_copy_set $IPSET_WL_NAME; then
    # ipset whitelist is already in place
    if $_WL; then
      if $_RELOAD_WTD; then _RELOAD=true
      # checking if ipset and file are identical
      elif _cipset_diff_set_file $IPSET_WL_NAME $WL_FILE
        then _RELOAD=false; NFO_IPS=$((NFO_IPS+INFO_IPS_WL_SAME))
        else _RELOAD=true
      fi
      if $_RELOAD; then
      # reload is asked for; so need to swap ipset
        _cipset_swap_set_file $IPSET_WL_NAME $WL_FILE
        NFO_IPS=$((NFO_IPS+INFO_IPS_WL_SWAP))
      else
      # else we want to keep it
        NFO_IPS=$((NFO_IPS+INFO_IPS_WL_KEEP))
      fi
    else _DWL=true  #it will be destroyed later
    fi
  elif $_WL; then
    # netset file exists, so creating whitelist ipset from it
    _cipset_create_set_file $IPSET_WL_NAME $WL_FILE
    NFO_IPS=$((NFO_IPS+INFO_IPS_WL_LOAD))
  fi
  
  if [ "$WAN_IF" ]; then _WIF=true; NFO_IPT=$((NFO_IPT+INFO_IPT_WIF))
    if ! sc_conf get wan.no_bypass >/dev/null; then WAN_INET=$(inet_for_if $WAN_IF)
      if _cipset_inet_in_bl $WAN_INET; then NFO_IPT=$((NFO_IPT+INFO_IPT_WIB)); _WBW=true      
    else _WBW=false; fi; else _WBW=false; fi
  else _WIF=false; _WBW=false; fi
  if [ "$TUN_IF" ]; then _TIF=true; NFO_IPT=$((NFO_IPT+INFO_IPT_TIF))
    if ! sc_conf get tun.no_bypass >/dev/null; then TUN_INET=$(inet_for_if $TUN_IF)
      if _cipset_inet_in_bl $TUN_INET; then NFO_IPT=$((NFO_IPT+INFO_IPT_TIB)); _TBW=true
    else _TBW=false; fi; else _TBW=false; fi
  else _TIF=false; _TBW=false; fi
  if sc_conf get log.enabled >/dev/null; then _LOG=true; NFO_IPT=$((NFO_IPT+INFO_IPT_LOG)); else _LOG=false; fi
  $_WL && NFO_IPT=$((NFO_IPT+INFO_IPT_WL))
  
  _cipset_end
  
  WIPTF=/tmp/aegis_wipt
  {
  echo "-N $IPTBL_DST"
  echo "-N $IPTBL_SRC"
  # IFO
  $_WIF && echo "-A INPUT -i $WAN_IF -m set --match-set $IPSET_BL_NAME src -m comment --comment \"incoming in $SC_ABR blocklist\" -j $IPTBL_SRC"
  $_TIF && echo "-A INPUT -i $TUN_IF -m set --match-set $IPSET_BL_NAME src -m comment --comment \"incoming in $SC_ABR blocklist\" -j $IPTBL_SRC"
  $_WIF && echo "-A FORWARD -i $WAN_IF -m set --match-set $IPSET_BL_NAME src -m comment --comment \"incoming in $SC_ABR blocklist\" -j $IPTBL_SRC"
  $_WIF && echo "-A FORWARD -o $WAN_IF -m set --match-set $IPSET_BL_NAME dst -m comment --comment \"outgoing in $SC_ABR blocklist\" -j $IPTBL_DST"
  $_TIF && echo "-A FORWARD -i $TUN_IF -m set --match-set $IPSET_BL_NAME src -m comment --comment \"incoming in $SC_ABR blocklist\" -j $IPTBL_SRC"
  $_TIF && echo "-A FORWARD -o $TUN_IF -m set --match-set $IPSET_BL_NAME dst -m comment --comment \"outgoing in $SC_ABR blocklist\" -j $IPTBL_DST"
  $_WIF && echo "-A OUTPUT -o $WAN_IF -m set --match-set $IPSET_BL_NAME dst -m comment --comment \"outgoing in $SC_ABR blocklist\" -j $IPTBL_DST"
  $_TIF && echo "-A OUTPUT -o $TUN_IF -m set --match-set $IPSET_BL_NAME dst -m comment --comment \"outgoing in $SC_ABR blocklist\" -j $IPTBL_DST"
  # DST
  $_WBW && echo "-A $IPTBL_DST -d $WAN_INET -o $WAN_IF -m comment --comment \"$SC_ABR inet bypass\" -j RETURN"
  $_TBW && echo "-A $IPTBL_DST -d $TUN_INET -o $TUN_IF -m comment --comment \"$SC_ABR inet bypass\" -j RETURN"
  $_WL &&  echo "-A $IPTBL_DST -m set --match-set $IPSET_WL_NAME dst -m comment --comment \"in $SC_ABR whitelist\" -j RETURN"
  $_LOG && echo "-A $IPTBL_DST -j LOG --log-prefix \"[$SC_ABR] \""
           echo "-A $IPTBL_DST -m comment --comment \"$SC_ABR reject outgoing\" -j REJECT --reject-with icmp-admin-prohibited"
  # SRC
  $_WBW && echo "-A $IPTBL_SRC -s $WAN_INET -i $WAN_IF -m comment --comment \"$SC_ABR inet bypass\" -j RETURN"
  $_TBW && echo "-A $IPTBL_SRC -s $TUN_INET -i $TUN_IF -m comment --comment \"$SC_ABR inet bypass\" -j RETURN"
  $_WL &&  echo "-A $IPTBL_SRC -m set --match-set $IPSET_WL_NAME src -m comment --comment \"in $SC_ABR whitelist\" -j RETURN"
  $_LOG && echo "-A $IPTBL_SRC -j LOG --log-prefix \"[$SC_ABR] \""
           echo "-A $IPTBL_SRC -m comment --comment \"$SC_ABR drop incoming\" -j DROP"
  } >$WIPTF

  # creating the lock file to advertise that shield IS BEING (re)-built
  get_ipt; AIPTF=$SHIELD_LOCK; echo "$_IPT" >$AIPTF
  
  if /usr/bin/diff -q $WIPTF $AIPTF >/dev/null; then NFO_IPT=$((NFO_IPT+INFO_IPT_KEEP)); else
    /usr/bin/awk '$1=="-A"{sub(/-A/,"-D"); system("'$IPT_COM' -w "$0)}' $AIPTF
    /usr/bin/awk '{system("'$IPT_COM' -w "$0)}' $WIPTF
    get_ipt; echo "$_IPT" >$AIPTF
    /usr/bin/diff -q $WIPTF $AIPTF >/dev/null && NFO_IPT=$((NFO_IPT+INFO_IPT_RUN))
  fi
  
  #Removing any trace of whitelist if not used and if any
  $_DWL && ipset -q destroy "$IPSET_WL_NAME" && NFO_IPS=$((NFO_IPS+INFO_IPS_WL_DEL))
  
  #Log daemon
  if $_LOG; then _logd_start; else _logd_stop; fi; NFO_LOGD=$?
  
  /bin/rm -f "$SHIELD_LOCK" # removing the lock file
  /bin/rm -f "$WIPTF"
  
  echo -ne "$((NFO_FROM+(NFO_IPS<<INFO_IPS_SHIFT)+(NFO_IPT<<INFO_IPT_SHIFT)+(NFO_LOGD<<INFO_LOGD_SHIFT))) $WAN_IF $TUN_IF" > "$INFO_FILE"
  $DEBUG && debug "<---| shield_uprear [$INFO_FILE -> $(/bin/cat $INFO_FILE)]"
} 2>>"$STDERR"

###############################################
#
#    CALLED FROM FIREWALL-START & POST-MOUNT
#
###############################################

#we are called from firewall_start.sh
if [ "$1" == "_fws" ]; then sc_conf get up >/dev/null && shield_uprear "$INFO_FROM_FWS"; _exit 0; fi

#when called from post-mount.sh
_pm() { $DEBUG && debug "_pm $*"
  if sc_conf get up >/dev/null; then
    [ -d "$ROOT_DIR" ] || /bin/ln -sfn /tmp/mnt/$2/bolemo $ROOT_DIR
    sc_init; shield_init; shield_uprear "$INFO_FROM_PM"
  fi
  _exit 0
}

###############################################
#
#    ADDITIONNAL GLOBALS NEEDED WHEN NOT CALLED FROM FIREWALL-START
#
###############################################
# ---------------------------------------------
: ENV START
# ---------------------------------------------
SC_NICEPATH="$ROOT_DIR/scripts/$SC_NAME"
SC_PATH="$(cd "$ROOT_DIR/scripts/">/dev/null 2>&1; pwd -P)"
SRC_LIST="$ROOT_DIR/etc/$SC_NAME.sources"
SRC_BL_CACHE="$ROOT_DIR/etc/$SC_NAME.bl.src.cache"
CUST_BL_FILE="$ROOT_DIR/etc/${SC_NAME}*.blacklist"
CUST_WL_FILE="$ROOT_DIR/etc/${SC_NAME}*.whitelist"
TMP_FILE="/tmp/$SC_NAME.tmp"
TMP_HTML="/tmp/$SC_NAME-html.tmp"
WWW_PATH="$ROOT_DIR/www"
FWS_DIR="/opt/scripts"
FWS_FILE="$FWS_DIR/firewall-start.sh"
# Check if script is installed on USB
if [ -z "${SC_PATH##/tmp/mnt/*}" ]; then EXT_DRIVE=true
  PM_DIR="${SC_PATH%${SC_PATH#/tmp/mnt/*/}}autorun/scripts"
  PM_FILE="$PM_DIR/post-mount.sh"
else EXT_DRIVE=false
fi
# ---------------------------------------------
: ENV STOP
# ---------------------------------------------

###############################################
#
#    DEALING WITH EXTERNAL SCRIPTS/CONFS
#    check, set, clean
#
###############################################

# SCRIPT: firewall-start.sh ###################
check_firewall_start() { $DEBUG && debug "check_firewall_start"
  [ -x "$FWS_FILE" ] || return 1
  [ "$(/bin/sed 's/[[:space:]]\+/ /g' "$FWS_FILE"|/bin/grep -c -- "\[ -x $SC_NICEPATH \] && $SC_NICEPATH _fws")" = 1 ] || return 1
  return 0
}

set_firewall_start() { $DEBUG && debug "set_firewall_start"
  [ -d "$FWS_DIR" ] || /bin/mkdir -p "$FWS_DIR"
  [ -e "$FWS_FILE" ] && /bin/sed -i "/$SC_NAME/d" "$FWS_FILE"
  echo -e "# Bolemo $SC_NAME\n[ -x $SC_NICEPATH ] && $SC_NICEPATH _fws" >> "$FWS_FILE"
  [ -x "$FWS_FILE" ] || /bin/chmod +x "$FWS_FILE"
}

clean_firewall_start() { $DEBUG && debug "clean_firewall_start"
  if [ -e "$FWS_FILE" ]; then
    if [ "$(/bin/grep -Fv "$SC_NAME" "$FWS_FILE"|/bin/sed '/^[[:space:]]*$/d')" ]; then
      /bin/sed -i "/$SC_NAME/d" "$FWS_FILE"
      [ $VERBOSE ] && echo "- 'firewall-start.sh' has some other rules; removed only our rules."
    else
      /bin/rm -f "$FWS_FILE" 2>/dev/null
      [ $VERBOSE ] && echo "- 'firewall-start.sh' had no other rules; removed it."
    fi
  fi
}

# SCRIPT: post-mount.sh ########################
check_postmount() { $DEBUG && debug "check_postmount"
  [ -x "$PM_FILE" ] || return 1
  [ "$(/bin/sed 's/[[:space:]]\+/ /g' "$PM_FILE"|/bin/grep -cF -- "[ -x $SC_NICEPATH ] && $SC_NICEPATH _pm \$1")" = 1 ] || return 1
  return 0
}

set_postmount() { $DEBUG && debug "set_postmount"
  $EXT_DRIVE || return 1
  [ -d "$PM_DIR" ] || /bin/mkdir -p "$PM_DIR"
  [ -e "$PM_FILE" ] && /bin/sed -i "/$SC_NAME/d" "$PM_FILE"
  echo -e "# Bolemo $SC_NAME\n[ -x $SC_NICEPATH ] && $SC_NICEPATH _pm \$1" >> "$PM_FILE"
  [ -x "$PM_FILE" ] || /bin/chmod +x "$PM_FILE"
}

clean_postmount() { $DEBUG && debug "clean_postmount"
  if $EXT_DRIVE && [ -e "$PM_FILE" ]; then
    if [ "$(/bin/grep -Fv "$SC_NAME" "$PM_FILE"|/bin/sed '/^[[:space:]]*$/d')" ]; then
      /bin/sed -i "/$SC_NAME/d" "$PM_FILE"
      [ $VERBOSE ] && echo "- 'post-mount.sh' has some other code; removed only our code."
    else
      /bin/rm -f "$PM_FILE" 2>/dev/null
      [ $VERBOSE ] && echo "- 'post-mount.sh' had no other code; removed it."
    fi
  fi
}

# SYMLINK: /usr/bin/SELF ######################
check_path() { $DEBUG && debug "check_path"
  command -v "$SC_NAME"; return $?
} >/dev/null

set_path() { $DEBUG && debug "set_path"
  [ -e "/usr/bin/$SC_NAME" ] || /bin/ln -s "$SC_NICEPATH" "/usr/bin/$SC_NAME"
}

clean_path() { $DEBUG && debug "clean_path"
  if [ -e "/usr/bin/$SC_NAME" ]; then /bin/rm -f "/usr/bin/$SC_NAME" 2>/dev/null
    [ $VERBOSE ] && echo "- '/usr/bin' symlink was removed."
  fi
}

# CONFIG: .../bolemo/etc/config/aegis #########
check_conf() { $DEBUG && debug "check_conf"
  [ -d "$ROOT_DIR/etc/config" ] && sc_conf get && sc_conf get wan && sc_conf get tun && sc_conf get log
  return $?
} >/dev/null

set_conf() { $DEBUG && debug "set_conf"
  [ -d "$ROOT_DIR/etc/config" ] || /bin/mkdir -p "$ROOT_DIR/etc/config" 2>/dev/null
  uci -qc $ROOT_DIR/etc/config import $SC_ABR << EOF
package $SC_ABR
config net-iface 'wan'
config net-iface 'tun'
config log 'log'
EOF
  sc_conf commit
}

clean_conf() { $DEBUG && debug "clean_conf"
  /bin/rm -f "$ROOT_DIR/etc/config/$SC_ABR" 2>/dev/null
  [ $VERBOSE ] && echo "- '$SC_NAME' configuration file was removed."
}

###############################################
#
#    FUNCTIONS DEPENDING ON BOLEMO GIT REPO
#
###############################################
# ---------------------------------------------
: ENV START
# ---------------------------------------------
BOLEMO_GIT_REPO='https://raw.githubusercontent.com/bolemo'
SC_BASE_REPO="$BOLEMO_GIT_REPO/$SC_NAME"
SC_MAIN_REPO="$SC_BASE_REPO/master"
SC_DEV_REPO="$SC_BASE_REPO/dev"

last_avail_version() { $DEBUG && debug "last_avail_version"
  [ "$DEVMODE" ] && VERSION_URL="$SC_DEV_REPO/version" || VERSION_URL="$SC_MAIN_REPO/version"
  /usr/bin/wget -qO- --no-check-certificate "$VERSION_URL"
}

# ---------------------------------------------
: ENV STOP
# ---------------------------------------------

_download() { # $1=URL, $2=DEST, $3=OPTS
  echo -ne "\033[35m"
  if ! /usr/bin/wget -qO "$2" $3 --show-progress --no-check-certificate "$1"; then
    echo -ne "\033[0m"
    /bin/rm -f "$2"
    _warn "Wget error code $?! Could not download $1" 1
  fi
  echo -ne "\033[0m"
}

do_upgrade() { $DEBUG && debug "do_upgrade"
echo "- Downloading:"
  DL_PATH="/tmp/$SC_NAME.dl"
  [ "$DEVMODE" ] && _PROG="--no-cache" || _PROG=''
  _download "$UPGRADE_URL" "$DL_PATH" "$_PROG"
  strip_sh_file "$DL_PATH"
  /bin/mv "$DL_PATH" "$SC_NICEPATH"
  /bin/chmod +x "$SC_NICEPATH"
  echo -e "\033[0m- Script installed to $SC_NICEPATH"
  check_web && install_web
  _exit 0
}

_upgrade() { $DEBUG && debug "_upgrade"
  UPGRADE_URL="$SC_MAIN_REPO/$SC_NAME"; UPGRADE_VER="$SC_LAST_VERS"
  do_upgrade
}

upgrade() { $DEBUG && debug "upgrade"
  echo -e "\033[1;36mUpgrading:\033[0m"
  echo "- Version installed: $SC_VERS"
  if [ "$DEVMODE" ]; then
    echo "- Devmode on, force downloading from '$SC_DEV_REPO'..."
    UPGRADE_URL="$SC_DEV_REPO/$SC_NAME"
    UPGRADE_VER=$(/usr/bin/wget -qO- --no-check-certificate "$SC_DEV_REPO/version")
    [ -z "$UPGRADE_VER" ] && _warn "Could not get version!" 1
  else
    echo -ne "- Checking latest available version...\r"
    SC_LAST_VERS="$(last_avail_version)"
    if [ "$SC_LAST_VERS" ]; then
      _LOC_VERS=$(echo "$SC_VERS"|/bin/sed 's/[^[:digit:]]//g')
      _REM_VERS=$(echo "$SC_LAST_VERS"|/bin/sed 's/[^[:digit:]]//g')
      if [ $_LOC_VERS -eq $_REM_VERS ]; then echo "- This is already the latest version.            ";_exit 0
      elif [ $_LOC_VERS -lt $_REM_VERS ]; then echo "- New version available: $SC_LAST_VERS         "
      else echo -e "\033[35m- This version is higher than than the one available: $SC_LAST_VERS         \033[0m"
      fi
    else _warn "Could not check what is the latest version online!" 1; fi
    UPGRADE_URL="$SC_MAIN_REPO/$SC_NAME"
    UPGRADE_VER="$SC_LAST_VERS"
  fi
  if [ ! "$DEVMODE" ]; then
    echo -n "? Do you want to upgrade from $SC_VERS to $SC_LAST_VERS (y/n)? "
    case "$(i=0;while [ $i -lt 2 ];do i=$((i+1));read -p '' YN </dev/tty;[ -n "$YN" ] && echo "$YN" && break;done)" in Y|y|yes|Yes|YES) : ;; *) _exit 0 ;; esac
  fi
  do_upgrade
}

# get default sources list (from bolemo github)
get_def_srclst() { $DEBUG && debug "get_def_srclst"
  if [ ! -s "$SRC_LIST" ]; then
    [ $VERBOSE ] && echo -e "! $SRC_LIST is missing or empty! Trying to download default list..."
    SRC_LIST_URL="$SC_MAIN_REPO/$SC_NAME.sources"
    [ $VERBOSE ] && _download "$SRC_LIST_URL" "$SRC_LIST" || _download "$SRC_LIST_URL" "$SRC_LIST" >/dev/null
    [ $VERBOSE ] && echo -e "- Default list was downloaded."
  fi
}

###############################################
#
#    WEB COMPANION RELATED FUNCTIONS
#
###############################################
WEB_NAME='Web Companion'
check_web() { $DEBUG && debug "check_web"
  [ -L "/www/bolemo" ] || return 1
  [ -e "/www/bolemo/aegis.htm" ] || return 1
  [ -x "/www/bolemo/cgi-bin/aegis_web.cgi" ] || return 1
  return 0
}

install_web() { $DEBUG && debug "install_web"
  [ -d "$WWW_PATH" ] || /bin/mkdir "$WWW_PATH" 2>/dev/null
  [ -d "$WWW_PATH/cgi-bin" ] || mkdir "$WWW_PATH/cgi-bin"
  if [ -z "$UPGRADE_URL" ]; then
    if [ "$DEVMODE" ]; then
      echo "- Devmode on, force downloading from '$SC_DEV_REPO'..."
      UPGRADE_URL="$SC_DEV_REPO/$SC_NAME"
    else
      UPGRADE_URL="$SC_MAIN_REPO/$SC_NAME"
    fi
  fi
  echo "- Downloading $WEB_NAME:"
  DL_PATH="/tmp/$SC_NAME.dl"
  [ "$DEVMODE" ] && _PROG='--no-cache' || _PROG=''
  _download "${UPGRADE_URL}.htm" "$DL_PATH" "$_PROG"
  /bin/mv "$DL_PATH" "$WWW_PATH/$SC_NAME.htm"
  echo -e "\033[0m- $WEB_NAME htm file installed to $WWW_PATH/$SC_NAME.htm"
  _download "${UPGRADE_URL}_web.cgi" "$DL_PATH" "$_PROG"
  strip_sh_file "$DL_PATH"
  /bin/mv "$DL_PATH" "$WWW_PATH/cgi-bin/${SC_NAME}_web.cgi"
  /bin/chmod +x "$WWW_PATH/cgi-bin/${SC_NAME}_web.cgi"
  echo -e "\033[0m- $WEB_NAME cgi file installed to $WWW_PATH/cgi-bin/${SC_NAME}_web.cgi"
  if ! check_web; then
    /bin/rm -f "/www/bolemo" 2>/dev/null
    /bin/ln -sfn "$WWW_PATH" '/www/bolemo' 2>/dev/null
    echo "- $WEB_NAME paths were repaired."
  fi
  _exit 0
}

clean_web() { $DEBUG && debug "clean_web"
  /bin/rm -f "$WWW_PATH/$SC_NAME.htm"
  eval "$WWW_PATH/cgi-bin/${SC_NAME}_web.cgi uninstall"
  /bin/rm -f "$WWW_PATH/cgi-bin/${SC_NAME}_web.cgi"
  [ $VERBOSE ] && echo "- $WEB_NAME was removed."
} 2>/dev/null

###############################################
#
#    UTILITY FUNCTIONS
#
###############################################

strip_sh_file() { /bin/sed -i 's/^[[:space:]]*// ; 1!{/^#/d;s/#[^"\}'\'']*$//;} ; s/[[:space:]]*$// ; /^$/d ; s/   *\([^"'\'']*\)$/ \1/ ; s/^\(\([^"'\'' ]\+ \)*\) \+/\1/' "$1"; }

strip_netset_file() { /usr/bin/awk -F'[#;]' 'match($1,/[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+(\/[0-9]+)?/){print substr($1,RSTART,RLENGTH)}' $*; }

###############################################
#
#    INIT FUNCTIONS
#    script init & shield init
#
###############################################

sc_init() { $DEBUG && debug "sc_init"
  check_path || set_path
  [ -d "$ROOT_DIR/etc" ] || /bin/mkdir "$ROOT_DIR/etc"
  check_conf || set_conf
  [ -d "$WWW_PATH" ] || /bin/mkdir "$WWW_PATH"
  [ -d '/www/bolemo' ] || /bin/ln -sfn "$WWW_PATH" '/www/bolemo'
} 2>/dev/null

shield_init() { $DEBUG && debug "shield_init"
  [ $VERBOSE ] && echo -e "\033[1;36mInitializing...\033[0m"
  [ -e "$SHIELD_LOCK" ] && /bin/rm -f "$SHIELD_LOCK"
  ipset -q destroy $IPSET_TMP
  if check_conf; then [ $VERBOSE ] && echo "- Configuration file is set."
  else _warn "Problem with the configuration system!" 1; fi
  if check_firewall_start; then [ $VERBOSE ] && echo "- 'firewall-start.sh' is in place and ok."
  else
    set_firewall_start
    if check_firewall_start; then [ $VERBOSE ] && echo "- 'firewall-start.sh' was edited and is now ok."
    else _warn "Problem with $FWS_FILE!" 1; fi
  fi
  if $EXT_DRIVE; then
    [ $VERBOSE ] && echo "- '$SC_NAME' is installed on external drive."
    if check_postmount; then [ $VERBOSE ] && echo "- 'post-mount.sh' is in place and ok."
    else set_postmount
      if check_postmount; then [ $VERBOSE ] && echo "- 'post-mount.sh' was edited and is now ok."
      else _warn "Problem with $PM_FILE!" 1; fi
    fi
  else [ $VERBOSE ] && echo "- '$SC_NAME' is installed on internal drive."
  fi
}

###############################################
#
#    FUNCTIONS FOR SCRIPT CMD ARGUMENTS
#
###############################################

print_log() { $DEBUG && debug "print_log"
  _UPT=$(/usr/bin/cut -d. -f1 /proc/uptime)
  _logd_status || echo -e "\033[35mLogging is disabled!\033[0m"
  echo -e "\033[1;36mLog:\033[0m"
  case "$1" in '') _TAIL=100; _LSCI=0 ;; 0) _TAIL=100; _LSCI=$_UPT ;; *) _TAIL=$1 _LSCI=0 ;; esac
  _LSC=/tmp/aegis_lsc; echo "$_LSCI">$_LSC; trap "/bin/rm -f $_LSC >/dev/null 2>&1; exit" INT TERM
  _BT=$(( $(/bin/date +%s) - _UPT ))
  _RSIZE=$(wc -l <$LOG_FILE)
while :; do while /usr/bin/awk -F: '
function namefromip(ip){
  cmd="/usr/bin/awk '"'"'$1==\""ip"\"{print $3;exit}'"'"' /tmp/netscan/attach_device";cmd|getline nm;close(cmd);
  if (!nm) {cmd="/usr/bin/awk '"'"'$1==\""ip"\"{print NF;exit}'"'"' /tmp/dhcpd_hostlist /tmp/hosts";cmd|getline nm;close(cmd)}
  if (nm) {nm=nm"("ip")"} else {nm=ip}
  return nm}
function protoname(proto){return (proto~/^[0-9]+$/)?"[protocol "proto"]":proto}
function getval(n){i=index(l[c]," "n"=");if(i==0)return;str=substr(l[c],i+length(n)+2);i=index(str," ");str=substr(str,0,i-1);return str}
function floored(a){return (a<0)?0:a}
function pline(iface){
  if (IN==iface){REM=SRC;RPT=SPT;LPT=DPT;DIR="\033[1;35mincoming\033[0m";DIR1="from";DIR2="to";
     if (OUT=="") {LOC=DST; LNM=(DST=="255.255.255.255")?"broadcast":"router"}
     else {LOC=namefromip(DST); LNM="LAN"}
  } else if (OUT==iface){REM=DST;RPT=DPT;LPT=SPT;DIR="\033[1;33moutgoing\033[0m";DIR1="to";DIR2="from";
     if (IN=="") {LOC=SRC; LNM="router"}
     else {LOC=namefromip(SRC); LNM="LAN"}
  } else return 0;
  return 1;}
$1$2>'$(cat $_LSC)'{ts[++b]=$1;l[b]=$0} END
{c=floored(b-'$_TAIL');while (c++<b){
  PT=strftime("%F %T", ('$_BT'+ts[c]));
  IN=getval("IN"); OUT=getval("OUT"); SRC=getval("SRC"); DST=getval("DST"); PROTO=protoname(getval("PROTO")); SPT=getval("SPT"); DPT=getval("DPT");
  if (pline("'$WAN_IF'")) {IFACE="WAN"} else if (pline("'$TUN_IF'")) {IFACE="VPN"}
  if (RPT) {RPT=":"RPT}; if (LPT) {LPT=":"LPT}
  printf("%s: Blocked %s %s packet %s %s:\033[1;35m%s%s\033[0m %s %s:\033[1;33m%s%s\033[0m\n",PT,DIR,PROTO,DIR1,IFACE,REM,RPT,DIR2,LNM,LOC,LPT)
} print $1$2 >"'$_LSC'"}'; do
  [ 0$_LSCI -eq 0 ] && break 2;
  _ASIZE=$(wc -l <$LOG_FILE); if [ 0$_ASIZE -ge 0$_RSIZE ]; then _RSIZE=$_ASIZE; else _RSIZE=$_ASIZE; break; fi
  sleep 1
done <$LOG_FILE; done
/bin/rm -f $_LSC >/dev/null 2>&1
}

shield_up() { $DEBUG && debug "shield_up"
  sc_conf set up=1; sc_conf commit
  shield_init
  [ $VERBOSE ] && echo -e "\033[1;36mUprearing $SC_NAME shield...\033[0m"
  if [ $1 ]; then
    [ -r "$BL_FILE" ] || _warn "$BL_FILE not readable!" 1
    [ $VERBOSE ] && echo "- Directives will be (re)loaded into $SC_NAME shield."
    _FORCE_NS_RELOAD=1
  fi
  sc_conf get log.enabled >/dev/null && [ $VERBOSE ] && echo "- Enabling logging."
  if [ $2 ]; then
    [ $VERBOSE ] && echo -e "- Restarting firewall with $SC_NAME shield.\033[0m"
    /usr/sbin/net-wall restart > /dev/null
  else shield_uprear "$INFO_FROM_SC" $_FORCE_NS_RELOAD
  fi
  [ $VERBOSE ] && echo "- Done."
}

shield_down() { $DEBUG && debug "shield_down"
  [ $VERBOSE ] && echo -e "\033[1;36mWithdrawing shield...\033[0m"
  sc_conf delete up; sc_conf commit
  /bin/rm -f "$INFO_FILE"
  /usr/sbin/net-wall restart > /dev/null; [ $VERBOSE ] && echo "- Built-in firewall restarted."
  _logd_stop; [ $VERBOSE ] && echo "- Made sure the log daemon is off."
  ipset -q destroy "$IPSET_BL_NAME"; ipset -q destroy "$IPSET_WL_NAME"; ipset -q destroy "$IPSET_TMP"; [ $VERBOSE ] && echo "- Cleaned ipsets."
  [ $VERBOSE ] && echo "- Shield down."
}

clean() { $DEBUG && debug "clean $RM_CONF|$RM_SYMLINK|$RM_WEB"
  [ $VERBOSE ] && echo -e "\033[1;36mUnsetting...\033[0m"
  clean_firewall_start
  clean_postmount
  if check_conf; then [ $RM_CONF ] && clean_conf || { sc_conf delete up; sc_conf commit; }; fi
  [ $RM_SYMLINK ] && check_path && clean_path
  [ $RM_WEB ] && check_web && clean_web
  /bin/rm -f "$INFO_FILE"
  /usr/sbin/net-wall restart > /dev/null; [ $VERBOSE ] && echo "- Built-in firewall restarted."
  _logd_stop; [ $VERBOSE ] && echo "- Made sure the log daemon is off."
  [ $RM_LOG ] && { /bin/rm -f $LOG_FILE 2>/dev/null; [ $VERBOSE ] && echo "- Removed log file."; }
  ipset -q destroy "$IPSET_BL_NAME"
  ipset -q destroy "$IPSET_WL_NAME"
  ipset -q destroy "$IPSET_TMP"
  [ $VERBOSE ] && echo "- Cleaned ipsets."
  [ -e "$SRC_BL_CACHE" ] && /bin/rm -f "$SRC_BL_CACHE"
  [ -e "$BL_FILE" ] && /bin/rm -f "$BL_FILE"
  [ -e "$WL_FILE" ] && /bin/rm -f "$WL_FILE"
  [ $VERBOSE ] && echo "- Removed directives files."
  [ -e "$TMP_FILE" ] && /bin/rm -f "$TMP_FILE"
  [ -e "$SHIELD_LOCK" ] && /bin/rm -f "$SHIELD_LOCK"
  [ $VERBOSE ] && echo -e "- Removed temporary files.\n- Done."
}

update_iplist() { $DEBUG && debug "update_iplist $*"
  [ $VERBOSE ] && echo -e "\033[1;36mUpdating blocking directives file from sources and custom lists...\033[0m"
  [ -s "$SRC_LIST" ] || get_def_srclst # change to -e when ready to deal with empty sources file
  trap "/bin/rm -f "$TMP_FILE" >/dev/null 2>&1; exit" INT TERM EXIT
  
  if [ "$1" ]; then # $1 set means using cache
    [ $VERBOSE ] && echo "- Using cached directives for sources (offline)."
    if [ -e "$SRC_BL_CACHE" ]; then /bin/cp -f "$SRC_BL_CACHE" "$TMP_FILE"
    else _warn "Blocklist sources cache is empty!" 1; fi
  elif [ -s "$SRC_LIST" ]; then
    :>"$TMP_FILE"
    # Process each source url
    [ $VERBOSE ] && echo "- Downloading lists defined in $SRC_LIST"
    [ $VERBOSE ] && WGET_OPTS='-qO- --show-progress --no-check-certificate' || WGET_OPTS='-qO- --no-check-certificate'
    _NBOK=0; _TOT=0;
    /bin/grep -v "^[[:space:]*\#]" "$SRC_LIST" | \
    { while read -r URL; do
        _TOT=$((_TOT+1))
        [ $VERBOSE ] && echo -e "$_TOT) $URL\033[35m"
        { { { { /usr/bin/wget $WGET_OPTS "$URL"; echo $? >&3; } | strip_netset_file >>"$TMP_FILE"; } 3>&1; } | { read _EC; exit $_EC; } }
        _EC=$?
        [ $VERBOSE ] && echo -e "\033[0m"
        [ $_EC -eq 0 ] && _NBOK=$((_NBOK+1)) || _warn "Wget error code $_EC! Could not download $URL"
      done
      if [ $_NBOK -eq 0 ]; then _warn "Could not get any list! Exiting!" 1; fi
      [ $_NBOK -eq $_TOT ] || _warn "Downloaded only $_NBOK / $_TOT list(s)!"
    }
    [ $VERBOSE ] && echo "- Creating offline cache for directives from sources..."
    /bin/cp -f "$TMP_FILE" "$SRC_BL_CACHE"
  else [ $VERBOSE ] && echo "- Sources file $SRC_LIST is empty or does not exists."
    :>"$TMP_FILE"
  fi
  if ( for F in $CUST_BL_FILE; do test -r $F || exit 1; done; ); then
    [ $VERBOSE ] && echo "- Adding directives from custom blocklist(s)..."
    strip_netset_file $CUST_BL_FILE >>"$TMP_FILE"
  elif [ $VERBOSE ]; then echo "- No custom custom blocklist(s) found."
  fi
  if [ ! -s "$TMP_FILE" ]; then _warn "We have no blocking directives! Exiting!" 1; fi
  if [ -x "$IPR_BIN" ]; then
    [ $VERBOSE ] && echo "- Optimizing and reducing directives (using iprange)..."
    $IPR_BIN --ipset-reduce 20 "$TMP_FILE" > "$BL_FILE"
  else
    [ $VERBOSE ] && echo -e "- iprange not installed, passing optimization and reduction process.\n- Removing duplicates..."
    /usr/bin/sort "$TMP_FILE"|/usr/bin/uniq > "$BL_FILE"
  fi
  [ $VERBOSE ] && echo "- Done."

  # processing whitelist if any
  if ( for F in $CUST_WL_FILE; do test -r $F || exit 1; done; ); then
    [ $VERBOSE ] && echo -e "\033[1;36mGenerating bypassing directives from custom list(s)...\033[0m"
    strip_netset_file $CUST_WL_FILE >"$TMP_FILE"
    
    if [ -s "$TMP_FILE" ]; then
      if [ -x "$IPR_BIN" ]; then
        if [ "$($IPR_BIN --common "$BL_FILE" "$TMP_FILE")" ]; then
          [ "$VERBOSE" ] && echo "- Optimizing and reducing directives (using iprange)..."
          $IPR_BIN --ipset-reduce 20 "$TMP_FILE" >"$WL_FILE"
        else
          echo '- No IP in common with blocking directives, skipping bypassing directives.'
        fi
      else
        [ $VERBOSE ] && echo -e "- iprange not installed, passing optimization and reduction process.\n- Removing duplicates..."
        /usr/bin/sort "$TMP_FILE"|/usr/bin/uniq >"$WL_FILE"
      fi
      else echo '- No directives were found: custom whitelist is empty.'
    fi
    [ $VERBOSE ] && echo "- Done."
  elif [ $VERBOSE ]; then echo "- No custom whitelist(s) found."
  fi
  
  /bin/rm -f "$TMP_FILE" 2>/dev/null
  trap - INT TERM EXIT
}

info() { $DEBUG && debug "info"
  echo -e "\033[1;36mInfo:\033[0m"
  if [ -r "$SRC_LIST" ] && [ -d $(dirname "$BL_FILE") ] && [ -d $(dirname "$TMP_FILE") ];
    then echo -n "- '$SC_NAME' version $SC_VERS is installed "; $EXT_DRIVE && echo 'on external drive.' || echo 'on internal drive.'
    else echo -e "\033[31m! Something is wrong with installation!\033[0m"
  fi
  echo -ne "- Checking latest available version...\r"
  SC_LAST_VERS="$(last_avail_version)";
  if [ "$SC_LAST_VERS" ]; then
    _LOC_VERS=$(echo "$SC_VERS"|/bin/sed 's/[^[:digit:]]//g')
    _REM_VERS=$(echo "$SC_LAST_VERS"|/bin/sed 's/[^[:digit:]]//g')
    if [ $_LOC_VERS -eq $_REM_VERS ]; then echo "- This is the latest version.            "
    elif [ $_LOC_VERS -lt $_REM_VERS ]; then echo -e "\033[35m- New version available: $SC_LAST_VERS       \033[0m"
    else echo -e "\033[35m- This version is higher than than the one available: $SC_LAST_VERS       \033[0m"
    fi
  else echo -e "\033[31m! Could not check what is the latest version online!\033[0m"
  fi
  if check_path
    then echo "- '$SC_NAME' is in PATH."
    else echo "- '$SC_NAME' is not in PATH (you need to use $NICE_PATH)."
  fi
  # check iprange binary
  [ "$IPR_BIN" ] && echo "- 'iprange' is installed: $($IPR_BIN --version | /usr/bin/head -n 1)" || echo "- 'iprange' is not installed."
  # check web compagnon
  check_web && echo "- $WEB_NAME is installed." || echo "- $WEB_NAME is not installed."
}

#---------------------------- _STATUS ----------------------------
# ---------------------------------------------
: ENV START
# ---------------------------------------------
# STATUS VARS
CK_FWS=1             # CK PB
CK_PM=2              # CK PB
CK_ENV_MASK=3
CK_IPS_BL=4          # CK PB
CK_IPS_WL=8          # CK PB
CK_IPT_CH=16         # CK PB
CK_IPT_WAN_BP=32     # CK PB WN
CK_IPT_TUN_BP=64     # CK PB WN
CK_IPT_WL=128        # CK PB
CK_IPT_LOG=256       # CK ..
PB_IPT_IFO=256       # .. PB
CK_IPT_TUN=512       # CK PB
CK_IPT_WAN=1024      # CK PB
PB_IPT_WAN_MISS=2048 # .. PB

WN_BL_FILE_DIFF=1   # . . . . . . _ x
WN_BL_FILE_MISS=2   # . . . . . . x _
WN_BL_FILE_NTLD=3   # . . . . . . x x
WN_WL_FILE_DIFF=4   # . . . . _ x . .
WN_WL_FILE_MISS=8   # . . . . x _ . .
WN_WL_FILE_NTLD=12  # . . . . x x . .
WN_TUN_MISS=16      # . . . x . . . .
# 32 CK_IPT_WAN_BP -> WAN BYPASS MISSING
# 64 CK_IPT_TUN_BP -> TUN BYPASS MISSING
WN_LOG_DIFF=128     # x . . . . . . .

CK_MASK=2047 #11 bits
PB_MASK=4095 #12 bits
WN_MASK=255  #8 bits

# ---------------------------------------------
: ENV EOF
# ---------------------------------------------

chain_status() { $DEBUG && debug "chain_status $*"
  if [ "$1" == 'src' ]; then _DIR='-s'; _PUT='-i'; _IPTBL_CH=$IPTBL_SRC; _RULE='DROP'
                        else _DIR='-d'; _PUT='-o'; _IPTBL_CH=$IPTBL_DST; _RULE='REJECT'; fi
  _CH_CK=0
  _CH_PB=0
  _CH_IPT="$(echo "$_IPT"|/bin/grep -nF -- "-A $_IPTBL_CH")"
  _SL=$(echo $_CH_IPT|/usr/bin/cut -d: -f1)
  if [ "$_CH_IPT" ]; then
    _LL=$((_SL+$(echo "$_CH_IPT"|/usr/bin/wc -l)-1))
    if [ 0$(echo "$_CH_IPT"|/bin/grep -F -- "-j $_RULE"|/usr/bin/cut -d: -f1) -eq 0$_LL ]; then _CH_CK=$((_CH_CK+CK_IPT_CH))
      _CL=$_SL # current line
      local _MKTMP="$(/bin/mktemp /tmp/${SC_ABR}_tmp_XXXXXX)"
      echo "$_CH_IPT"|/bin/grep -F -- "-m comment --comment \"$SC_ABR inet bypass\"" >$_MKTMP
      while read -r _BPL; do
        [ -z "$_BPL" ] && break
        if [ 0$(echo $_BPL|/usr/bin/cut -d: -f1) -ne 0$_CL ]; then _CH_PB=$((_CH_PB+CK_IPT_CH)); break 2; fi
        case "$_BPL" in
          *"$_DIR $_WAN_INET $_PUT $WAN_IF"*) # we have WAN with correct inet
            if [ $((_CH_CK&CK_IPT_WAN_BP)) -eq 0 ]; then                          _CH_CK=$((_CH_CK+CK_IPT_WAN_BP))
            elif [ $((_CH_PB&CK_IPT_WAN_BP)) -eq 0 ]; then                        _CH_PB=$((_CH_PB+CK_IPT_WAN_BP))
            fi ;;
          *"$_PUT $WAN_IF "*) # we have WAN with wrong inet
            [ $((_CH_PB&CK_IPT_WAN_BP)) -eq 0 ] &&                                _CH_PB=$((_CH_PB+CK_IPT_WAN_BP))
            ;;
          *"$_DIR $_TUN_INET $_PUT $TUN_IF "*)
            if [ $((_CH_CK&CK_IPT_TUN_BP)) -eq 0 ]; then                          _CH_CK=$((_CH_CK+CK_IPT_TUN_BP))
            elif [ $((_CH_PB&CK_IPT_TUN_BP)) -eq 0 ]; then                        _CH_PB=$((_CH_PB+CK_IPT_TUN_BP))
            fi ;;
          *"$_PUT $TUN_IF "*) # we have TUN with wrong inet
            [ $((_CH_PB&CK_IPT_TUN_BP)) -eq 0 ] &&                                _CH_PB=$((_CH_PB+CK_IPT_TUN_BP))
            ;;
          *) # we found a non matching interface
            _CH_PB=$((_CH_PB+CK_IPT_CH)); break 2
            ;;
        esac
        _CL=$((_CL+1))
      done <$_MKTMP; /bin/rm -f $_MKTMP
      if [ 0$(echo "$_CH_IPT"|/bin/grep -F -- "$IPSET_WL_NAME"|/usr/bin/cut -d: -f1) -eq 0$_CL ]; then _CH_CK=$((_CH_CK+CK_IPT_WL))
        _CL=$((_CL+1))
      fi
      if [ 0$(echo "$_CH_IPT"|/bin/grep -F -- 'LOG'|/usr/bin/cut -d: -f1) -eq 0$_CL ]; then            _CH_CK=$((_CH_CK+CK_IPT_LOG))
        _CL=$((_CL+1))
      fi
      [ 0$_CL -eq 0$_LL ] ||                                                     _CH_PB=$((_CH_PB+CK_IPT_CH))
    else                                                                         _CH_PB=$((_CH_PB+CK_IPT_CH))
    fi
  fi
  if [ "$1" == 'src' ]; then _S_CK=$_CH_CK; _S_PB=$_CH_PB; _S_IPT=$_CH_IPT
                        else _D_CK=$_CH_CK; _D_PB=$_CH_PB; _D_IPT=$_CH_IPT; fi
}

_status() { $DEBUG && debug "|---> _status"
  _CK=0; _WN=0; _PB=0
  _BLC=0; _WLC=0
  _logd_status; _LOGD=$?
  _cipset_init
  
  # CHECK ENVIRONMENT
  # check firewall-start.sh script
  check_firewall_start &&                                                        _CK=$((_CK+CK_FWS))
  # check post-mount.sh script if script on external drive
  $EXT_DRIVE && check_postmount &&                                               _CK=$((_CK+CK_PM))

  # CHECK BLOCKLIST (IPS, FILE)
  if _cipset_copy_set $IPSET_BL_NAME; then                                       _CK=$((_CK+CK_IPS_BL))
    _BLC=$(_cipset_count_set $IPSET_BL_NAME)
    if [ -r "$BL_FILE" ]; then
      _cipset_diff_set_file $IPSET_BL_NAME $BL_FILE ||                           _WN=$((_WN+WN_BL_FILE_DIFF))
    else                                                                         _WN=$((_WN+WN_BL_FILE_MISS))
    fi
  elif [ -r "$BL_FILE" ]; then                                                   _WN=$((_WN+WN_BL_FILE_NTLD))
  fi

  # CHECK WHITELIST (IPS, FILE)
  if _cipset_copy_set $IPSET_WL_NAME; then                                       _CK=$((_CK+CK_IPS_WL))
    _WLC=$(_cipset_count_set $IPSET_WL_NAME)
    if [ -r "$WL_FILE" ]; then
      _cipset_diff_set_file $IPSET_WL_NAME $WL_FILE ||                           _WN=$((_WN+WN_WL_FILE_DIFF))
    else                                                                         _WN=$((_WN+WN_WL_FILE_MISS))
    fi
  elif [ -r "$WL_FILE" ]; then                                                   _WN=$((_WN+WN_WL_FILE_NTLD))
  fi

  # CHECK IPTABLES
  get_ipt
  _WAN_INET=$(inet_for_if $WAN_IF)
  [ "$TUN_IF" ] && _TUN_INET=$(inet_for_if $TUN_IF)
  # -- SRC CHAIN
  chain_status src
  # -- DST CHAIN
  chain_status dst
  # -- SRC & DST
  if [ $_S_CK -eq $_D_CK ]; then                                                 _CK=$((_CK+_S_CK))
    if [ $_S_PB -eq $_D_PB ]; then                                               _PB=$((_PB+_S_PB))
    else                                                                         _PB=$((_PB+(_S_PB|_D_PB)))
    fi
  else                                                                           _PB=$((_PB+CK_IPT_CH))                                                                           
  fi
  # -- IFO (INPUT, FORWARD, OUTPUT)
  _IFO_IPT="$(echo "$_IPT"|/bin/grep -F -- "-m set --match-set $IPSET_BL_NAME")"
  if [ "$_IFO_IPT" ]; then
    _TCT=$(echo "$_IFO_IPT"|/usr/bin/wc -l)
    # checking VPN tunnel interface rules
    if [ "$TUN_IF" ]; then
      _CT=$(echo "$_IFO_IPT"|/bin/grep -cF -- "$TUN_IF"); _TCT=$((_TCT-_CT))
      case "$_CT" in
        4)                                                                       _CK=$((_CK+CK_IPT_TUN));;
        0)                                                                       _WN=$((_WN+WN_TUN_MISS));;
        *)                                                                       _PB=$((_PB+CK_IPT_TUN));;
      esac
    fi
    # checking WAN interface rules
    _CT=$(echo "$_IFO_IPT"|/bin/grep -cF -- "$WAN_IF"); _TCT=$((_TCT-_CT))
    case "$_CT" in
      4)                                                                         _CK=$((_CK+CK_IPT_WAN));;
      0)                                                                         _PB=$((_PB+PB_IPT_WAN_MISS));;
      *)                                                                         _PB=$((_PB+CK_IPT_WAN));;
    esac
    # checking if old rules exists or if corrupted
    [ $_TCT -ne 0 ] &&                                                           _PB=$((_PB+PB_IPT_IFO))
  fi

  # DEEPER CHECK
  if [ $_CK -gt $CK_ENV_MASK ]; then
  # -- PROBLEMS / WARNINGS
    # ENV
    [ $((_CK&CK_FWS)) -eq 0 ] &&                                                 _PB=$((_PB+CK_FWS))
    $EXT_DRIVE && [ $((_CK&CK_PM)) -eq 0 ] &&                                    _PB=$((_PB+CK_PM))
    # BL
    [ $((_CK&CK_IPS_BL)) -eq 0 ] &&                                              _PB=$((_PB+CK_IPS_BL))
    # CH
    [ $(((_CK&CK_IPT_CH)+(_PB&CK_IPT_CH))) -eq 0 ] &&                            _PB=$((_PB+CK_IPT_CH))
    if [ $((_PB&CK_IPT_CH)) -eq 0 ]; then
      # BP
      _cipset_inet_in_bl $_WAN_INET && [ $(((_CK|_PB)&CK_IPT_WAN_BP)) -eq 0 ] &&                  _WN=$((_WN+CK_IPT_WAN_BP))
      [ "$TUN_IF" ] && _cipset_inet_in_bl $_TUN_INET && [ $(((_CK|_PB)&CK_IPT_TUN_BP)) -eq 0 ] && _WN=$((_WN+CK_IPT_TUN_BP))
      # WL
      _OK=$((CK_IPS_WL+CK_IPT_WL))
      if [ $((_CK&_OK)) -ne 0 ] && [ $((_CK&_OK)) -ne $_OK ]; then
        [ $((_CK&CK_IPS_WL)) -eq 0 ] &&                                                           _PB=$((_PB+CK_IPS_WL))
        [ $((_CK&CK_IPT_WL)) -eq 0 ] &&                                                           _PB=$((_PB+CK_IPT_WL))
      fi
      # LOG
      if [ $((_PB&CK_IPT_CH)) -eq 0 ]; then if sc_conf get log.enabled >/dev/null
        then [ $((_CK&CK_IPT_LOG)) -eq 0 ] &&                                                     _WN=$((_WN+WN_LOG_DIFF))
        else [ $((_CK&CK_IPT_LOG)) -ne 0 ] &&                                                     _WN=$((_WN+WN_LOG_DIFF))
      fi fi
    fi
    # IFO
  else
    [ $((_WN&WN_WL_FILE_NTLD)) -ne 0 ] && _WN=$((_WN-WN_WL_FILE_NTLD))
    [ $((_WN&WN_BL_FILE_NTLD)) -ne 0 ] && _WN=$((_WN-WN_BL_FILE_NTLD))
  fi
  
  _cipset_end
  
  echo -n "$_CK $_PB $_WN $_BLC $_WLC $_LOGD"
  $DEBUG && debug "<---| _status [$_CK $_PB $_WN $_BLC $_WLC $_LOGD]"
} 2>>"$STDERR"

netset_exists() { test -e "$BL_FILE"; return $?; }

status_term() { $DEBUG && debug "status_term"
# variables are already set when calling _status from here. so no need to set variables from stdout here.
#  set -- $(_status); _CK=$1; _PB=$2; _WN=$3; _BLC=$4; _WLC=$5; _LOGD=$6
_status >/dev/null

  echo -e '\033[1;36mStatus:\033[0m'
  if [ $((_CK+_PB)) -eq 0 ]; then _RETVAL=1
    echo "- Shield is unset."
  elif [ $_CK -le $CK_ENV_MASK ] && [ $_PB -eq 0 ]; then _RETVAL=2
    echo "- Shield is down."
  else if [ $_CK -ne 0 ] && [ $_PB -eq 0 ]; then _RETVAL=0
      echo -ne "- \033[1;32mShield is up\033[0m"
      [ $((_CK&CK_IPT_WAN)) -ne 0 ] && echo -n " for WAN interface ($WAN_IF)"
      [ $((_CK&CK_IPT_TUN)) -ne 0 ] && echo -n " and VPN tunnel ($TUN_IF)"
      echo -e ".\n- Filtering $_BLC IP adresses."
      [ $((_CK&CK_IPT_WL)) -ne 0 ] && echo "- Bypassing $_WLC IP adresses."
    else _RETVAL=3
       echo -e "- \033[1;31mSomething is not right!\033[0m"
    fi
    if [ $_LOGD -eq 0 ]; then echo "- Logging is enabled."; else echo "- Logging is disabled."; fi
  fi
  
  if [ $_PB -ne 0 ]; then
    echo -ne '\033[1;31mErrors:\033[0m'; [ 0$VERBOSE -ge 2 ] && echo " (CODE: $_PB)" || echo ''
    [ $((_PB&CK_FWS)) -ne 0 ] &&     echo -e "\033[31m- set: firewall-start.sh is not set properly for $SC_NAME!\033[0m"
    [ $((_PB&CK_PM)) -ne 0 ] &&      echo -e "\033[31m- set: post-mount.sh is not set properly for $SC_NAME!\033[0m"
    [ $((_PB&CK_IPS_BL)) -ne 0 ] &&  echo -e "\033[31m- ipset: no blocklist is set!\033[0m"
    [ $((_PB&CK_IPS_WL)) -ne 0 ] &&  echo -e "\033[31m- ipset: no whitelist is set!\033[0m"
    [ $((_PB&CK_IPT_CH)) -ne 0 ] &&  echo -e "\033[31m- iptables: shield chains are not right!\033[0m"
    [ $((_PB&CK_IPT_WAN_BP)) -ne 0 ] &&  echo -e "\033[31m- iptables: WAN network range bypass rules are not right!\033[0m"
    [ $((_PB&CK_IPT_TUN_BP)) -ne 0 ] &&  echo -e "\033[31m- iptables: VPN network range bypass rules are not right!\033[0m"
    [ $((_PB&CK_IPT_WL)) -ne 0 ] &&  echo -e "\033[31m- iptables: whitelist rules are not right!\033[0m"
    [ $((_PB&CK_IPT_TUN)) -ne 0 ] &&      echo -e "\033[31m- iptables: VPN tunnel IFO rules are corrupted!\033[0m"
    [ $((_PB&CK_IPT_WAN)) -ne 0 ] &&      echo -e "\033[31m- iptables: WAN interface IFO rules are corrupted!\033[0m"
    [ $((_PB&PB_IPT_WAN_MISS)) -ne 0 ] && echo -e "\033[31m- iptables: WAN interface ($WAN_IF) IFO rules are missing!\033[0m"
    [ $((_PB&PB_IPT_IFO)) -ne 0 ] &&      echo -e "\033[31m- iptables: Extra shield IFO rules were found (likely from an old interface)!\033[0m"
  fi
  
  if [ $((_CK+_PB)) -ne 0 ] && [ $_WN -ne 0 ]; then
    echo -ne '\033[1;35mWarnings:\033[0m'; [ 0$VERBOSE -ge 2 ] && echo " (CODE: $_WN)" || echo ''
    case "$((_WN&WN_BL_FILE_NTLD))" in
      $WN_BL_FILE_DIFF) echo -e "\033[35m- directives: shield blocklist is different than file.\033[0m";;
      $WN_BL_FILE_MISS) echo -e "\033[35m- directives: shield blocklist is set but file is missing.\033[0m";;
      $WN_BL_FILE_NTLD) echo -e "\033[35m- directives: no shield blocklist is set but file exists.\033[0m";;
    esac
    case "$((_WN&WN_WL_FILE_NTLD))" in
      $WN_WL_FILE_DIFF) echo -e "\033[35m- directives: ipset whitelist set is different than file.\033[0m";;
      $WN_WL_FILE_MISS) echo -e "\033[35m- directives: ipset whitelist is set but file is missing.\033[0m";;
      $WN_WL_FILE_NTLD) echo -e "\033[35m- directives: no ipset whitelist is set but file exists.\033[0m";;
    esac
    [ $((_WN&CK_IPT_WAN_BP)) -ne 0 ] && echo -e "\033[31m- iptables: WAN network range bypass rules are missing!\033[0m"
    [ "$TUN_IF" ] && [ $((_WN&CK_IPT_TUN_BP)) -ne 0 ] && echo -e "\033[31m- iptables: VPN network range bypass rules are missing!\033[0m"
    [ $((_WN&WN_TUN_MISS)) -ne 0 ] && echo -e "\033[31m- iptables: VPN tunnel ($TUN_IF) IFO rules are missing!\033[0m"
    [ $((_WN&WN_LOG_DIFF)) -ne 0 ] && echo -e "\033[35m- current logging settings differs from last time shield was upreared.\033[0m"
  fi
 
  [ $VERBOSE ] || return 0

  echo -ne '\033[1;36mDetailed status:\033[0m'; [ 0$VERBOSE -ge 2 ] && echo " (CODE: $_CK)" || echo ''
  echo "- Active WAN interface is '$WAN_IF'."
  [ "$TUN_IF" ] && echo "- Active VPN tunnel is '$TUN_IF'." || echo "- no VPN tunnel found."
  # dates
  echo "- Actual router time: $(/bin/date +'%Y-%m-%d %X')"
  [ -e "$SRC_BL_CACHE" ] && echo "- Sources cache directives update time: $(/bin/date +'%Y-%m-%d %X' -r $SRC_BL_CACHE)"
  [ -e "$BL_FILE" ] && echo "- Blocklist directives generation time: $(/bin/date +'%Y-%m-%d %X' -r $BL_FILE)"
  [ -e "$WL_FILE" ] && echo "- Whitelist directives generation time: $(/bin/date +'%Y-%m-%d %X' -r $WL_FILE)"
  if [ $_CK -ne 0 ]; then
    [ $((_CK&CK_FWS)) -ne 0 ] &&        echo "- set: firewall-start.sh is set for $SC_NAME."
    [ $((_CK&CK_PM)) -ne 0 ] &&         echo "- set: post-mount.sh is set for $SC_NAME."
    [ $((_CK&CK_IPS_BL)) -ne 0 ] &&     echo "- ipset: blocklist is set."
    [ $((_CK&CK_IPS_WL)) -ne 0 ] &&     echo "- ipset: whitelist is set."
    [ $((_CK&CK_IPT_CH)) -ne 0 ] &&     echo "- iptables: shield chains are set."
    [ $((_CK&CK_IPT_WAN_BP)) -ne 0 ] && echo "- iptables: WAN network range bypass rules are set."
    [ $((_CK&CK_IPT_TUN_BP)) -ne 0 ] && echo "- iptables: VPN network range bypass rules are set."
    [ $((_CK&CK_IPT_WL)) -ne 0 ] &&     echo "- iptables: whitelist rules are set."
    [ $((_CK&CK_IPT_LOG)) -ne 0 ] &&    echo "- iptables: $SC_NAME logging rules are set."
    [ $((_CK&CK_IPT_TUN)) -ne 0 ] &&    echo "- iptables: VPN tunnel IFO rules are set."
    [ $((_CK&CK_IPT_WAN)) -ne 0 ] &&    echo "- iptables: WAN interface IFO rules are set."
  fi
  
  [ 0$VERBOSE -lt 2 ] && return 0

  # Status file
  echo -ne "\033[1;36mLast shield uprear report:\033[0m"
  if [ -r "$INFO_FILE" ]; then
    read INFO INFO_WAN INFO_TUN<"$INFO_FILE"
    INFO_FROM=$((INFO&INFO_FROM_MASK))
    INFO_IPS=$(((INFO>>INFO_IPS_SHIFT)&INFO_IPS_MASK))
    INFO_IPT=$(((INFO>>INFO_IPT_SHIFT)&INFO_IPT_MASK))
    INFO_LOGD=$(((INFO>>INFO_LOGD_SHIFT)&INFO_LOGD_MASK))
    echo " (CODE: $INFO_FROM-$INFO_IPS-$INFO_IPT-$INFO_LOGD)"
    case "$INFO_FROM" in
      $INFO_FROM_SC) FROM="$SC_NAME script" ;;
      $INFO_FROM_PM) FROM="post-mount.sh" ;;
      $INFO_FROM_FWS) FROM="firewall-start.sh" ;;
    esac
    echo "- shield was upreared from: $FROM @ $(/bin/date +'%Y-%m-%d %X' -r $INFO_FILE)"
    echo "- WAN interface was '$INFO_WAN'."
    [ "$INFO_TUN" ] && echo "- VPN tunnel was '$INFO_TUN'." || echo '- No VPN tunnel was found.'
    case $((INFO_IPS&INFO_IPS_BL_MASK)) in
      0) echo '! directives: blocklist file was not found!' ;;
      $INFO_IPS_BL_SAME) echo '- directives: ipset blocklist was already set and identical to file.' ;;
      $INFO_IPS_BL_MISS) echo '- directives: blocklist file was not found! The one already in ipset was kept.' ;;
      $INFO_IPS_BL_LOAD) echo '- directives: ipset blocklist was set from file.' ;;
    esac
    case $((INFO_IPS&INFO_IPS_WL_MASK)) in
      0) echo '- directives: no whitelist file was found.' ;;
      $((INFO_IPS_WL_SAME+INFO_IPS_WL_KEEP))) echo '- directives: ipset whitelist was already set and identical to file.' ;;
      $INFO_IPS_WL_KEEP) echo '- directives: ipset whitelist was kept.' ;;
      $INFO_IPS_WL_LOAD) echo '- directives: ipset whitelist was set from file.' ;;
      $INFO_IPS_WL_SWAP) echo '- directives: ipset whitelist was updated from file.' ;;
      $INFO_IPS_WL_DEL) echo '- directives: ipset whitelist was unset.' ;;
    esac
    if  [ $((INFO_IPT&INFO_IPT_KEEP)) -ne 0 ]; then echo "- iptables: rules were already set."; _P_IPT=true
    elif [ $((INFO_IPT&INFO_IPT_RUN)) -ne 0 ]; then echo "- iptables: rules were (re)set."; _P_IPT=true
    else _P_IPT=false; fi
    if $_P_IPT; then
      [ $((INFO_IPT&INFO_IPT_WIF)) -ne 0 ] && echo "- iptables: rules for WAN interface in place."
      [ $((INFO_IPT&INFO_IPT_TIF)) -ne 0 ] && echo "- iptables: rules for VPN interface in place."
      [ $((INFO_IPT&INFO_IPT_WIB)) -ne 0 ] && echo "- iptables: WAN network range bypass rules in place."
      [ $((INFO_IPT&INFO_IPT_TIB)) -ne 0 ] && echo "- iptables: VPN network range bypass rules in place."
      [ $((INFO_IPT&INFO_IPT_WL)) -ne 0 ]  && echo "- iptables: whitelist bypass rules in place."
      [ $((INFO_IPT&INFO_IPT_LOG)) -ne 0 ] && echo "- iptables: logging rules in place."
    else echo "! iptables: rules were UNSUCCESSFULLY (re)set!"; fi
 
    case "$INFO_LOGD" in
      $INFO_LOGD_KEEP_OFF) echo '- log daemon: was already off.';;
      $INFO_LOGD_KEEP_ON)  echo '- log daemon: was already on.';;
      $INFO_LOGD_STOPPED)  echo '- log daemon: was turned off.';;
      $INFO_LOGD_STARTED)  echo '- log daemon: was turned on.';;
    esac
    
    echo -ne "\033[0m"
  else
    echo -e '\n- No status file found.'
  fi
  
  [ 0$VERBOSE -lt 3 ] && return 0
  
  if [ $((_CK+_PB)) -ne 0 ]; then
    echo -e "\033[1;36miptables:\033[0m"
    [ -z "$_IPT" ] && echo "- no $SC_NAME rules are set." || echo "$_IPT"|/bin/sed 's/^/- iptables /'
    ipset -L -n|/bin/grep -F -- "$SC_ABR"|while read _SET; do
      case "$_SET" in
        "$IPSET_BL_NAME") _NAME='blocklist' ;;
        "$IPSET_WL_NAME") _NAME='whitelist' ;;
        *) _NAME="$_SET" ;;
      esac
      echo -e "\033[1;36mipset '$_NAME':\033[0m"
      ipset -L -t $_SET|/bin/sed 's/^/- /'
    done
  fi
  _exit $_RETVAL
}

status_raw() { $DEBUG && debug "status_raw"
  echo "$(_status) '$WAN_IF' '$TUN_IF'"; _exit 0
}
#---------------------------- END _STATUS ----------------------------

print_help() { $DEBUG && debug "print_help"
echo -e "\033[1;36m$SC_NAME $SC_VERS\033[0m"'
'"Usage: \033[1m$SC_NAME \033[35mCOMMAND \033[36m[OPTION(S)]\033[0m"'
'"\033[7mCOMMANDS (only one) and their specific options:\033[0m"'
'"\033[1;35mup\033[0m                  - (re)starts $SC_NAME shield protection"'
'"   \033[1;36m-net-wall\033[0m          + by restarting the internal firewall"'
'"   \033[1;36m-refresh\033[0m           + with updated shield directives"'
'"   \033[1;36m-log-enable\033[0m        + with logging enabled"'
'"   \033[1;36m-log-disable\033[0m       + with logging disabled"'
'"   \033[1;36m-wan-no-bypass\033[0m     + without WAN network range bypass"'
'"   \033[1;36m-vpn-no-bypass\033[0m     + without VPN network range bypass"'
'" \033[1;35mdown\033[0m               - stops $SC_NAME shield protection"'
'" \033[1;35mrefresh\033[0m            - updates shield directives from sources and custom lists\033[0m"'
'"   \033[1;36m-custom-only\033[0m       + will refresh directives only from custom lists (using offline cache for sources)"'
'" \033[1;35mlog -enable\033[0m        - enables logging"'
'" \033[1;35mlog -disable\033[0m       - disables logging"'
'" \033[1;35mlog -show\033[0m          - displays the log report"'
'"   \033[1;36m-lines=\033[0mN           + will display N last lines (N being the number of lines to show)"'
'" \033[1;35mlog -live\033[0m          - displays the log report live (CTRL-C to exit)"'
'" \033[1;35mlog -get-history\033[0m   - show the history size for the log file $LOG_FILE"'
'" \033[1;35mlog -set-history=\033[0mN - sets the history size to N records for the log file $LOG_FILE"'
'" \033[1;35munset\033[0m              - stops and unsets $SC_NAME shield"'
'"   \033[1;36m-rm-config\033[0m         + and removes $SC_NAME configuration file"'
'"   \033[1;36m-rm-symlink\033[0m        + and removes the symlink /usr/bin/$SC_NAME"'
'"   \033[1;36m-rm-web\033[0m            + and removes $WEB_NAME"'
'"   \033[1;36m-rm-log\033[0m            + and removes log file"'
'" \033[1;35mhelp\033[0m               - displays help (this)"'
'" \033[1;35minfo\033[0m               - displays info on this script"'
'" \033[1;35mstatus\033[0m             - displays status"'
'" \033[1;35mupgrade\033[0m            - downloads and installs latest version"'
'" \033[1;35mweb -install\033[0m       - downloads and installs $WEB_NAME"'
'" \033[1;35mweb -remove\033[0m        - removes $WEB_NAME"'
'"\033[7mGENERAL OPTIONS (none, one or more, can be used with any command):\033[0m"'
'" \033[1;36m-v\033[0m                 + verbose mode (level 1)"'
'" \033[1;36m-vv\033[0m                + verbose mode (level 2)"'
'" \033[1;36m-vvv\033[0m               + verbose mode (level 3)"'
'" \033[1;36m-q\033[0m                 + quiet mode (no output)"
}

###############################################
#
#    MAIN ROUTINE
#
###############################################
if [ $# -eq 0 ]; then _warn "No parameter!"; print_help; _exit 1; fi
[ "$1" == "_pm" ] && [ "$2" ] && _pm # Called from post-mount.sh, go to right processing...

ARGS=" $* "

$DEBUG && debug "main routing with args: $ARGS"

if [ -z "${ARGS##* %devmode*% *}" ]; then
  if [ "${ARGS##* %devmode% *}" ]; then
    _DEV="$(echo "$ARGS"|/bin/sed 's/[^%]*%devmode \([^%]*\)%[^%]*/\1/')"
    echo "dev: '$_DEV'"
    if [ -z "${_DEV##*cmd=*}" ]; then
      _CMD="$(echo "$_DEV"|/bin/sed 's/.*cmd=\([^,$]*\).*/\1/')"
      echo "Executing command: '$_CMD'"
      eval "$_CMD"
    fi
    if [ -z "${_DEV##*repo=*}" ]; then
      _REPO="$(echo "$_DEV"|/bin/sed 's/.*repo=\([^,$]*\).*/\1/')"
      SC_DEV_REPO="$SC_BASE_REPO/$_REPO"
      echo "Using git path: '$SC_DEV_REPO'"
    fi
  fi
  DEVMODE=1
  ARGS="${ARGS% %devmode*% *} ${ARGS#* %devmode*% }"
  echo "Arguments: '$ARGS'"
fi

PARAM="$(echo "$ARGS" | /bin/sed 's/-[[:alpha:]=]*[[:space:]]*[[:digit:]]*//g')"
case $(echo "$PARAM"|/usr/bin/wc -w) in
  0) _warn "No parameter!"; print_help; _exit 1 ;;
  1) PARAM="$(echo "$PARAM"|/bin/sed 's/ //g')" ;;
  *) _warn "Too many parameters!"; print_help; _exit 1 ;;
esac

# Verbosity
case $ARGS in
  *' -q '*)   unset VERBOSE ;;
  *' -v '*)   VERBOSE=1 ;;
  *' -vv '*)  VERBOSE=2 ;;
  *' -vvv '*) VERBOSE=3 ;;
  *) VERBOSE= ;;
esac

_refresh_args() {
  [ -z "${ARGS##* -custom-only *}" ]   && RF_OFFLN=1   || RF_OFFLN=
}
_shield_args() {
  [ -z "${ARGS##* -log-enable *}" ]    && sc_conf set log.enabled=1
  [ -z "${ARGS##* -log-disable *}" ]   && sc_conf delete log.enabled
  [ -z "${ARGS##* -wan-no-bypass *}" ] && sc_conf set wan.no_bypass=1 || sc_conf delete wan.no_bypass
  [ -z "${ARGS##* -vpn-no-bypass *}" ] && sc_conf set tun.no_bypass=1 || sc_conf delete tun.no_bypass
  
  [ -z "${ARGS##* -net-wall *}" ]      && ST_FW=1      || ST_FW=
  [ -z "${ARGS##* -refresh *}" ]       && ST_US=1      || ST_US=
  
  sc_conf commit
}

_log_args() { case $ARGS in
  *' -enable '*)           sc_conf set log.enabled=1; sc_conf commit; sc_conf get up >/dev/null && { shield_up; [ $VERBOSE ] && status_term; } ;;
  *' -disable '*)          sc_conf delete log.enabled; sc_conf commit; sc_conf get up >/dev/null && { shield_up; [ $VERBOSE ] && status_term; } ;;
  *' -show '*)             [ -z "${ARGS##* -lines=[0-9]*}" ] && _PL=$(echo "$ARGS"|/bin/sed 's/.* -lines=\([[:digit:]]\+\) .*/\1/') || _PL=''; print_log $_PL ;;
  *' -live '*)             print_log 0 ;;
  *' -get-history '*)      sc_conf get log.len ;;
  *' -set-history='[0-9]*) sc_conf set log.len=$(echo "$ARGS"|/bin/sed 's/.* -set-history=\([[:digit:]]\+\) .*/\1/'); sc_conf commit ;;
esac; }
  
_clean_args() {
  [ -z "${ARGS##* -rm-config *}" ]     && RM_CONF=1    || RM_CONF=
  [ -z "${ARGS##* -rm-symlink *}" ]    && RM_SYMLINK=1 || RM_SYMLINK=
  [ -z "${ARGS##* -rm-web *}" ]        && RM_WEB=1     || RM_WEB=
  [ -z "${ARGS##* -rm-log *}" ]        && RM_LOG=1     || RM_LOG=
}

[ -z ${VERBOSE+x} ] && exec >/dev/null

sc_init

if [ $DEVMODE ]; then echo -e "\033[7;31m$SC_NAME $SC_VERS - Developer mode\033[0m"; VERBOSE=3
elif [ $VERBOSE ]; then echo -e "\033[7;31m$SC_NAME $SC_VERS - Verbose mode [level $VERBOSE]\033[0m"; fi

case "$PARAM" in
  'up') _shield_args;
        netset_exists || { ST_US=1; [ $VERBOSE ] && echo "- No directives were found! Refresh will be made."; }
        [ $ST_US ] && update_iplist;
        shield_up "$ST_US" "$ST_FW";
        [ $VERBOSE ] && status_term ;;
  'down') shield_down; [ $VERBOSE ] && status_term ;;
  
  'unset') _clean_args; clean; [ $VERBOSE ] && status_term ;;
  'refresh') _refresh_args; update_iplist $RF_OFFLN; sc_conf get up >/dev/null && { shield_up 1; [ $VERBOSE ] && status_term; } ;;
  
  'status') status_term ;;
  'help') print_help ;;
  'info') info ;;
  'log') _log_args ;;
  'upgrade') upgrade ;;
  'web') [ -z "${ARGS##* -install *}" ] && install_web; [ -z "${ARGS##* -remove *}" ] && clean_web ;;
  
  # calls for outside helpers (html)
  '_status') status_raw ;;
  '_up') _shield_args; VERBOSE=1; shield_up '' 1 ;;
  '_refresh') _refresh_args; _shield_args; VERBOSE=1; update_iplist $RF_OFFLN; shield_up 1 ;;
  '_down') VERBOSE=1; shield_down ;;
  '_upgrade') _upgrade ;;
  
  *) _warn "Unknown Parameter $2!"; print_help; _exit 1 ;;
esac

_exit 0
