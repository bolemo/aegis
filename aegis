#! /bin/sh
command -v iptables>/dev/null 2>&1 || export PATH=/bin:/sbin:/usr/bin:/usr/sbin

SC_VERS="1.1.5"
SC_NAME="aegis"
SC_ABR="aegis"
IPTBL_SRC="${SC_ABR}_src"
IPTBL_DST="${SC_ABR}_dst"
[ "$(nvram get aegis_log)" = "1" ] && IPTBL_LOGGING='y' || IPTBL_LOGGING=''
IPSET_BL_NAME="${SC_ABR}_bl"
IPSET_WL_NAME="${SC_ABR}_wl"
IPSET_WG_NAME="${SC_ABR}_wg"
IPSET_TMP="${IPSET_BL_NAME}_tmp"
ROOT_DIR="/opt/bolemo"
BL_FILE="$ROOT_DIR/etc/${SC_NAME}-bl.netset"
WL_FILE="$ROOT_DIR/etc/${SC_NAME}-wl.netset"
INFO_FILE="/tmp/${SC_ABR}_status"
ifconfig ppp0 >/dev/null 2>/dev/null && WAN_IF='ppp0' || WAN_IF="$(nvram get wan_ifname)"
WAN_GW="$(nvram get wan_gateway)"
WAN_NM="$(nvram get wan_netmask)"
# VPN tunnel detection
if ifconfig wg0 >/dev/null 2>/dev/null; then
  # WireGuard
  TUN_IF='wg0'
elif ps -w|grep -vE 'grep|server_tap|server_tun'|grep -qF -- '/usr/sbin/openvpn --dev'; then
  # Open VPN client
  TUN_IF="$(ps -w|grep -F -- '/usr/sbin/openvpn --dev'|grep -vE 'grep|server_tap|server_tun'|sed -n -- 's/.*openvpn --dev \([[:alnum:]]*\).*/\1/p')"
else
  # No tunneling
  TUN_IF=''
fi
INFO_IPS_BL_LOAD='1'
INFO_IPS_BL_NEW='2'
INFO_IPS_BL_KEEP='3'
INFO_IPS_BL_WGW='4'
INFO_IPS_WL_LOAD='5'
INFO_IPS_WL_KEEP='7'
INFO_IPS_WG_ADD='8'
INFO_IPS_WG_KEEP='9'
INFO_IPT_SRC_KEEP='a'
INFO_IPT_DST_KEEP='b'
INFO_IPT_LOG='c'
INFO_IPT_WL='d'
INFO_IPT_WG='f'
INFO_IPT_WAN='e'
INFO_IPT_TUN='g'
INFO_IPT_WAN_PBM='h'
INFO_IPT_TUN_PBM='i'
INFO_FROM_FWS='j'
INFO_FROM_PM='k'
INFO_FROM_SC='l'
###############################################
#
#    ENGINE-START
#
###############################################

_set_ipt_for_if_pos() {
  _IF="$1"
  _POS=$2
  _CT=$(iptables -S 2>/dev/null | grep -cF -- "$IF -m set --match-set $IPSET_BL_NAME")
  if [ $_CT -ne 4 ]; then
    if [ $_CT -ne 0 ]; then
      # something is messed up with rules; deleting what is left
      iptables -S 2>/dev/null | grep -F -- "$_IF -m set --match-set $IPSET_BL_NAME" | sed 's/^-A/iptables -D/' | while read _CMD; do eval "$_CMD 2>/dev/null"; done
      _RET=2
    else
      _RET=1
    fi
    iptables -I INPUT $_POS -i $_IF -m set --match-set "$IPSET_BL_NAME" src -j "$IPTBL_SRC"
    iptables -I OUTPUT $_POS -o $_IF -m set --match-set "$IPSET_BL_NAME" dst -j "$IPTBL_DST"
    iptables -I FORWARD $_POS -i $_IF -m set --match-set "$IPSET_BL_NAME" src -j "$IPTBL_SRC"
    iptables -I FORWARD $((_POS+1)) -o $_IF -m set --match-set "$IPSET_BL_NAME" dst -j "$IPTBL_DST"
  else
    _RET=0
  fi
  return $_RET
}

engine_start() {
  _FROM=$1
  echo "$_FROM" > "$INFO_FILE"
  [ "$_FROM" = "$INFO_FROM_SC" ] && _RELOAD='y'

  # creating ipset blocklist if needed
  if ipset -q -n list "$IPSET_BL_NAME">/dev/null; then
    if [ "$_RELOAD" ]; then
    # reload is asked for; so need to swap ipset
      echo -e "create $IPSET_TMP hash:net family inet maxelem $(wc -l < "$BL_FILE")\n$(sed "s/^/add $IPSET_TMP /" $BL_FILE)" | ipset restore
      ipset swap "$IPSET_BL_NAME" "$IPSET_TMP"
      ipset destroy $IPSET_TMP
      echo "$INFO_IPS_BL_LOAD" >> "$INFO_FILE"
    else
    # blocklist already loaded, keeping it
      echo "$INFO_IPS_BL_KEEP" >> "$INFO_FILE"
    fi
  else
    if [ -r "$BL_FILE" ]; then
    # netset file exists, so creating blocklist ipset from it
      echo -e "create $IPSET_BL_NAME hash:net family inet maxelem $(wc -l < "$BL_FILE")\n$(sed "s/^/add $IPSET_BL_NAME /" "$BL_FILE")" | ipset restore
      echo "$INFO_IPS_BL_LOAD" >> "$INFO_FILE"
    else
    # no netset file, creating empty blocklist ipset
      ipset -q create "$IPSET_BL_NAME" hash:net family inet
      echo "$INFO_IPS_BL_NEW" >> "$INFO_FILE"
    fi
  fi
  
  # checking if WAN gateway is in blocklist
  if [ "$WAN_GW" != '0.0.0.0' ] && ipset -q test "$IPSET_BL_NAME" "$WAN_GW"; then
    _WG='y'
    echo "$INFO_IPS_BL_WGW" >> "$INFO_FILE"
    if ! ipset -q test "$IPSET_WG_NAME" "$WAN_GW"; then
      # Calculate WAN_RANGE (IP & CIDR)
      _CIDR=0
      for _OCTET in $(echo "$WAN_NM"| sed 's/\./ /g'); do
        _BINBITS=$(echo "obase=2; ibase=10; ${_OCTET}"| bc | sed 's/0//g')
        let _CIDR+=${#_BINBITS}
      done
      WAN_RANGE="$WAN_GW/$_CIDR"
      ipset -q create "$IPSET_WG_NAME" hash:net family inet
      ipset -q flush "$IPSET_WG_NAME"
      ipset -q add "$IPSET_WG_NAME" "$WAN_RANGE"
      echo "$INFO_IPS_WG_ADD" >> "$INFO_FILE"
    else
      echo "$INFO_IPS_WG_KEEP" >> "$INFO_FILE"
    fi
  fi
  
  # creating ipset whitelist if needed
  if ipset -q -n list "$IPSET_WL_NAME">/dev/null; then
    # ipset whitelist is already in place
    if [ -r "$WL_FILE" ]; then
      _WL='y'
      if [ "$_RELOAD" ]; then
      # reload is asked for; so need to swap ipset
        echo -e "create $IPSET_TMP hash:net family inet\n$(sed "s/^/add $IPSET_TMP /" $WL_FILE)" | ipset restore
        ipset swap "$IPSET_WL_NAME" "$IPSET_TMP"
        ipset destroy "$IPSET_TMP"
        echo "$INFO_IPS_WL_LOAD" >> "$INFO_FILE"
      else
      # we want to keep it
        echo "$INFO_IPS_WL_KEEP" >> "$INFO_FILE"
      fi
    fi
  else
    if [ -r "$WL_FILE" ]; then
      # netset file exists, so creating whitelist ipset from it
      _WL='y'
      echo -e "create $IPSET_WL_NAME hash:net family inet\n$(sed "s/^/add $IPSET_WL_NAME /" "$WL_FILE")" | ipset restore
      echo "$INFO_IPS_WL_LOAD" >> "$INFO_FILE"
    fi
  fi

  #Creating our iptables chains if not already set
  iptables -L "$IPTBL_SRC" >/dev/null 2>/dev/null && echo "$INFO_IPT_SRC_KEEP" >> "$INFO_FILE" || iptables -N "$IPTBL_SRC"
  iptables -L "$IPTBL_DST" >/dev/null 2>/dev/null && echo "$INFO_IPT_DST_KEEP" >> "$INFO_FILE" || iptables -N "$IPTBL_DST"
  
  if [ "$IPTBL_LOGGING" ]; then
    iptables -S "$IPTBL_SRC" | grep -qF -- "-j LOG" || iptables -A "$IPTBL_SRC" -j LOG --log-prefix "[$SC_NAME] "
    iptables -S "$IPTBL_DST" | grep -qF -- "-j LOG" || iptables -A "$IPTBL_DST" -j LOG --log-prefix "[$SC_NAME] "
    echo "$INFO_IPT_LOG" >> "$INFO_FILE"
  else
    iptables -D "$IPTBL_SRC" -j LOG --log-prefix "[$SC_NAME] " 2>/dev/null
    iptables -D "$IPTBL_DST" -j LOG --log-prefix "[$SC_NAME] " 2>/dev/null
  fi
  iptables -S "$IPTBL_SRC" | grep -qF -- "-j DROP" || iptables -A "$IPTBL_SRC" -j DROP
  iptables -S "$IPTBL_DST" | grep -qF -- "-j DROP" || iptables -A "$IPTBL_DST" -j DROP
  
  if [ "$_WL" ]; then
    # apply whitelist
    iptables -S "$IPTBL_SRC" | grep -qF -- "$IPSET_WL_NAME" || iptables -I "$IPTBL_SRC" -m set --match-set "$IPSET_WL_NAME" src -j ACCEPT
    iptables -S "$IPTBL_DST" | grep -qF -- "$IPSET_WL_NAME" || iptables -I "$IPTBL_DST" -m set --match-set "$IPSET_WL_NAME" dst -j ACCEPT
    echo "$INFO_IPT_WL" >> "$INFO_FILE"
  else
    #Removing any trace of whitelist if any
    iptables -S 2>/dev/null | grep -F -- "$IPSET_WL_NAME" | sed 's/^-A/iptables -D/' | while read _CMD; do eval "$_CMD 2>/dev/null"; done
    ipset -q destroy "$IPSET_WL_NAME"
  fi
  
  if [ "$_WG" ]; then
    # apply whitelist
    iptables -S "$IPTBL_SRC" | grep -qF -- "$IPSET_WG_NAME" || iptables -I "$IPTBL_SRC" -i $WAN_IF -m set --match-set "$IPSET_WG_NAME" src -j ACCEPT
    iptables -S "$IPTBL_DST" | grep -qF -- "$IPSET_WG_NAME" || iptables -I "$IPTBL_DST" -o $WAN_IF -m set --match-set "$IPSET_WG_NAME" dst -j ACCEPT
    echo "$INFO_IPT_WG" >> "$INFO_FILE"
  else
    #Removing any trace of WAN gareway whitelist if any
    iptables -S 2>/dev/null | grep -F -- "$IPSET_WG_NAME" | sed 's/^-A/iptables -D/' | while read _CMD; do eval "$_CMD 2>/dev/null"; done
    ipset -q destroy "$IPSET_WG_NAME"
  fi
  
  # creating the required iptables rules for wan interface
  case $(_set_ipt_for_if_pos "$WAN_IF" 1) in
    2) echo "$INFO_IPT_WAN_PBM" >> "$INFO_FILE"; echo "$INFO_IPT_WAN" >> "$INFO_FILE" ;;
    1) echo "$INFO_IPT_WAN" >> "$INFO_FILE" ;;
  esac
  
  # creating the required iptables rules for vpn tunnel interface (if needed)
  [ "$TUN_IF" ] && case $(_set_ipt_for_if_pos "$TUN_IF" 2) in
    2) echo "$INFO_IPT_TUN_PBM" >> "$INFO_FILE"; echo "$INFO_IPT_TUN" >> "$INFO_FILE" ;;
    1) echo "$INFO_IPT_TUN" >> "$INFO_FILE" ;;
  esac
}

###############################################
#
#    CALLED FROM FIREWALL-START & POST-MOUNT
#
###############################################

#we are called from firewall_start.sh
if [ "$1" ] && [ "$1" = "_fws" ]; then
  engine_start "$INFO_FROM_FWS"
  exit 0
fi

#when called from post-mount.sh
_pm() {
  [ -d /opt/bolemo ] || /bin/ln -sfn /tmp/mnt/$2/bolemo /opt/bolemo
  pre_init
  init
  engine_start "$INFO_FROM_PM"
  exit 0
}

###############################################
#
#    ADDITIONNAL GLOBALS NEEDED WHEN NOT CALLED FROM FIREWALL-START
#
###############################################
command -v iprange>/dev/null 2>&1 || [ -e /root/.profile ] && source /root/.profile
SC_PATH="$(cd "$(\ls -l "$0"|sed 's/.* \([^ ]*\)\/[^/]*$/\1/')">/dev/null 2>&1; pwd -P)"
IPR_BIN="$(command -v iprange)"
SC_NICEPATH="$ROOT_DIR/scripts/$SC_NAME"
SRC_LIST="$ROOT_DIR/etc/$SC_NAME.sources"
CUST_BL_FILE="$ROOT_DIR/etc/$SC_NAME.custom-blacklist.netset"
CUST_WL_FILE="$ROOT_DIR/etc/$SC_NAME.custom-whitelist.netset"
TMP_FILE="/tmp/$SC_NAME.tmp"
TMP_HTML="/tmp/$SC_NAME-html.tmp"
WWW_PATH="$ROOT_DIR/www"
FWS_DIR="/opt/scripts"
FWS_FILE="$FWS_DIR/firewall-start.sh"
# Check if scriot is installed on USB
if echo "$SC_PATH" | grep -q '^/tmp/mnt/'; then
  PM_DIR="$(echo "$SC_PATH" | sed "s|\(/tmp/mnt/[[:alnum:]]*\)/.*|\1|")/autorun/scripts"
  PM_FILE="$PM_DIR/post-mount.sh"
  EXT_DRIVE='y'
else
  EXT_DRIVE=''
fi

###############################################
#
#    DEALING WITH EXTERNAL SCRIPTS/CONFS
#    check, set, clean
#
###############################################

# SCRIPT: firewall-start.sh ###################
check_firewall_start() {
  [ -x $FWS_FILE ] || return 1
  [ "$(sed 's/[[:space:]]\+/ /g' $FWS_FILE | grep -c -- "\[ -x $SC_NICEPATH \] && $SC_NICEPATH _fws")" = 1 ] || return 1
  return 0
}

set_firewall_start() {
  [ -d "$FWS_DIR" ] || mkdir -p "$FWS_DIR"
  [ -e "$FWS_FILE" ] && sed -i "/$SC_NAME/d" "$FWS_FILE"
  echo -e "# Bolemo $SC_NAME\n[ -x $SC_NICEPATH ] && $SC_NICEPATH _fws" >> "$FWS_FILE"
  [ -x "$FWS_FILE" ] || chmod +x "$FWS_FILE"
}

clean_firewall_start() {
  if [ -e "$FWS_FILE" ]; then
    if [ "$(grep -Fv "$SC_NAME" "$FWS_FILE" | sed '/^[[:space:]]*$/d')" ]; then
      sed -i "/$SC_NAME/d" "$FWS_FILE"
      [ "$VERBOSE" ] && echo "- 'firewall-start.sh' has some other rules; removed only our rules."
    else
      rm "$FWS_FILE" 2>/dev/null
      [ "$VERBOSE" ] && echo "- 'firewall-start.sh' had no other rules; removed it."
    fi
  fi
}

# SCRIPT: post-mount.sh ########################
check_postmount() {
  [ -x "$PM_FILE" ] || return 1
  [ "$(sed 's/[[:space:]]\+/ /g' $PM_FILE | grep -cF -- "[ -x $SC_NICEPATH ] && $SC_NICEPATH _pm \$1")" = 1 ] || return 1
  return 0
}

set_postmount() {
  [ "$EXT_DRIVE" ] || return 1
  [ -d "$PM_DIR" ] || mkdir -p "$PM_DIR"
  [ -e "$PM_FILE" ] && sed -i "/$SC_NAME/d" "$PM_FILE"
  echo -e "# Bolemo $SC_NAME\n[ -x $SC_NICEPATH ] && $SC_NICEPATH _pm \$1" >> "$PM_FILE"
  [ -x "$PM_FILE" ] || chmod +x "$PM_FILE"
}

clean_postmount() {
  if [ "$EXT_DRIVE" ] && [ -e "$PM_FILE" ]; then
    if [ "$(grep -Fv "$SC_NAME" "$PM_FILE" | sed '/^[[:space:]]*$/d')" ]; then
      sed -i "/$SC_NAME/d" "$PM_FILE"
      [ "$VERBOSE" ] && echo "- 'post-mount.sh' has some other code; removed only our code."
    else
      rm "$PM_FILE" 2>/dev/null
      [ "$VERBOSE" ] && echo "- 'post-mount.sh' had no other code; removed it."
    fi
  fi
}

# SYMLINK: /usr/bin/SELF ######################
check_path() {
  command -v "$SC_NAME" > /dev/null && return 0 || return 1
}

set_path() {
  [ -e "/usr/bin/$SC_NAME" ] || ln -s "/opt/bolemo/scripts/$SC_NAME" "/usr/bin/$SC_NAME"
}

clean_path() {
  if [ -e "/usr/bin/$SC_NAME" ]; then
    rm "/usr/bin/$SC_NAME" 2>/dev/null
    [ "$VERBOSE" ] && echo "- '/usr/bin' symlink was removed."
  fi
}

###############################################
#
#    FUNCTIONS DEPENDING ON BOLEMO GIT REPO
#
###############################################
BOLEMO_GIT_REPO='https://raw.githubusercontent.com/bolemo'
SC_BASE_REPO="$BOLEMO_GIT_REPO/$SC_NAME"
SC_MAIN_REPO="$SC_BASE_REPO/master"
SC_DEV_REPO="$SC_BASE_REPO/dev"

last_avail_version() {
  wget -qO- "$SC_MAIN_REPO/version"
}

upgrade() {
  echo -e "\033[1;36mUpgrading:\033[0m"
  echo "- Version installed: $SC_VERS"
  if [ "$DEVMODE" ]; then
    echo "- Devmode on, force downloading dev version..."
    UPGRADE_URL="$SC_DEV_REPO/$SC_NAME"
  else
    echo -ne "- Checking latest available version...\r"
    SC_LAST_VERS="$(last_avail_version)";
    if [ "$SC_LAST_VERS" ]
      then if [ "$SC_VERS" = "$SC_LAST_VERS" ]
        then echo "- This is already the last version.         "; exit 0
        else echo "- Version found: $SC_LAST_VERS                    "
      fi
      else
        >&2 echo -e "\033[31m! Could not check what is the last version online!\033[0m"
        exit 1
    fi
    UPGRADE_URL="UPGRADE_URL="$SC_MAIN_REPO/$SC_NAME""
  fi
  if [ ! "$DEVMODE" ]; then
    echo -n "? Do you want to upgrade from $SC_VERS to $SC_LAST_VERS (y/n)? "
    case "$(i=0;while [ $i -lt 2 ];do i=$((i+1));read -p "" yn </dev/tty;[ -n "$yn" ] && echo "$yn" && break;done)" in Y|y|yes|Yes|YES) : ;; *) exit 0 ;; esac
  fi
  echo "- Downloading:"

  DL_PATH="/tmp/$SC_NAME.dl"
  _PROG='--show-progress';
  [ "$DEVMODE" ] && _PROG="--no-cache $_PROG"
  echo -ne "\033[35m"
  if wget -qO "$DL_PATH" $_PROG "$UPGRADE_URL"; then
    sed -i 's/^[[:space:]]*// ; /^#/d ; /^$/d' "$DL_PATH"
    \mv "$DL_PATH" "$SC_NICEPATH"
    chmod +x "$SC_NICEPATH"
    echo -e "\033[0m- Script installed to $SC_NICEPATH"
  else
    echo -ne "\033[0m"
    >&2 echo -e "\033[31m! Wget error code $?! Could not download $DL_PATH\033[0m"
    rm -f "$DL_PATH"
    exit 1
  fi

  exit 0
}

# get default sources list (from bolemo github)
get_def_srclst() {
  if [ ! -e "$SRC_LIST" ]; then
    [ "$VERBOSE" ] && echo -e "! $SRC_LIST is missing!"
    SRC_LIST_URL="$SC_MAIN_REPO/$SC_NAME.sources"
    if wget -qO "$SRC_LIST" "$SRC_LIST_URL"; then
      [ "$VERBOSE" ] && echo -e "- Default list was downloaded."
    else
      >&2 echo -e "\033[31m! Wget error code $?! Could not download $SRC_LIST_URL\033[0m"
      rm -f "$SRC_LIST"
      exit 1
    fi
  fi
}

###############################################
#
#    UTILITY FUNCTIONS
#
###############################################

count_ip_in_file() {
  if [ -x "$IPR_BIN" ]
    then $IPR_BIN -C "$1" | sed -n 's/.*,//p'
    else grep -oE '(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\/([0-9]{1,2})' "$1" | awk -F / '{ count[$2]++ } END { for (mask in count) total+=count[mask]*2^(32-mask); print total }'
  fi
}

count_ip_in_ipset() {
  if [ -x "$IPR_BIN" ]
    then ipset list "$1" | sed -n '/Members:/,$p' | tail -n +2 | $IPR_BIN -C | sed -n 's/.*,//p'
    else ipset list "$1" | sed -n '/Members:/,$p' | tail -n +2 | grep -oE '(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\/([0-9]{1,2})' | awk -F / '{ count[$2]++ } END { for (mask in count) total+=count[mask]*2^(32-mask); print total }'
  fi
}

###############################################
#
#    INIT FUNCTIONS
#    script init & when using firewall init
#
###############################################

pre_init() {
  check_path || set_path
  [ -d "$ROOT_DIR/etc" ] || mkdir "$ROOT_DIR/etc" 2>/dev/null
  [ -d "$ROOT_DIR/www" ] || mkdir "$ROOT_DIR/www" 2>/dev/null
  [ -d '/www/bolemo' ] || ln -sfn "$ROOT_DIR/www" '/www/bolemo' 2>/dev/null
}

init() {
  [ "$VERBOSE" ] && echo -e "\033[1;36mInitializing...\033[0m"
  ipset -q destroy $IPSET_TMP
  if check_firewall_start; then
    [ "$VERBOSE" ] && echo "- 'firewall-start.sh' is in place and ok."
  else
    set_firewall_start
    check_firewall_start || { >&2 echo -e "\033[31m! Problem with $FWS_FILE!\033[0m"; exit 1; }
    [ "$VERBOSE" ] && echo "- 'firewall-start.sh' was edited and is now ok."
  fi
  if [ "$EXT_DRIVE" ]; then
    [ "$VERBOSE" ] && echo "- '$SC_NAME' is installed on external drive."
    if check_postmount; then
      [ "$VERBOSE" ] && echo "- 'post-mount.sh' is in place and ok."
    else
      set_postmount
      check_postmount || { >&2 echo -e "\033[31m! Problem with $PM_FILE!\033[0m"; exit 1; }
      [ "$VERBOSE" ] && echo "- 'post-mount.sh' was edited and is now ok."
    fi
  else
    [ "$VERBOSE" ] && echo "- '$SC_NAME' is installed on internal drive."
  fi
}

fw_restart() {
  [ "$VERBOSE" ] && echo -e "\033[1;36mRestarting firewall...\033[0m"
  /usr/sbin/net-wall restart > /dev/null
  [ "$VERBOSE" ] && echo "- Firewall restarted."
}

###############################################
#
#    FUNCTIONS FOR SCRIPT CMD ARGUMENTS
#
###############################################

info() {
  echo -e "\033[1;36mInfo:\033[0m"
  if [ -r "$SRC_LIST" ] && [ -d $(dirname "$BL_FILE") ] && [ -d $(dirname "$TMP_FILE") ];
    then echo -n "- '$SC_NAME' version $SC_VERS is installed "; [ "$EXT_DRIVE" ] && echo 'on external drive.' || echo 'on internal drive.'
    else echo -e "\033[31m! Something is wrong with installation!\033[0m"
  fi
  if check_path
    then echo "- '$SC_NAME' is in PATH."
    else echo "- '$SC_NAME' is not in PATH (you need to use $NICE_PATH)."
  fi
  echo -ne "- Checking latest available version...\r"
  SC_LAST_VERS="$(last_avail_version)";
  if [ "$SC_LAST_VERS" ]
    then if [ "$SC_VERS" = "$SC_LAST_VERS" ]
      then echo "- This is the last version.            "
      else echo -e "\033[35m- Lastest version available: $SC_LAST_VERS       \033[0m"
    fi
    else echo -e "\033[31m! Could not check what is the last version online!\033[0m"
  fi
  [ "$IPR_BIN" ] && echo "- 'iprange' is installed: $($IPR_BIN --version | head -n 1)" || echo "- 'iprange' is not installed."
}

print_log() {
  echo -e "\033[1;36mLog:\033[0m"
  echo -e "\033[35mIf the log is empty, to be sure it is enabled, use the \033[1mstatus\033[0;35m parameter.\033[0m"
  dmesg | grep -F "$SC_NAME"
}

set_log_state() {
  if [ "$1" ]; then
    [ "$VERBOSE" ] && echo -e "\033[1;36mLogging state set:\033[0m"
    if [ "$1" = 'ON' ]; then
      [ "$VERBOSE" ] && echo "- Enabling logging."
      nvram set aegis_log=1
    else
      [ "$VERBOSE" ] && echo "- Disabling logging."
      nvram unset aegis_log
    fi
  fi
}

clean() {
  [ "$VERBOSE" ] && echo -e "\033[1;36mCleaning...\033[0m"
  clean_firewall_start
  clean_postmount
  [ "$RM_SYMLINK" ] && check_path && clean_path
  rm "$INFO_FILE" 2>/dev/null
  /usr/sbin/net-wall restart > /dev/null
  [ "$VERBOSE" ] && echo "- Built-in firewall restarted."
  ipset -q destroy "$IPSET_BL_NAME"
  ipset -q destroy "$IPSET_WL_NAME"
  ipset -q destroy "$IPSET_WG_NAME"
  ipset -q destroy "$IPSET_TMP"
  [ "$VERBOSE" ] && echo "- Cleaned ipsets."
  [ -e "$TMP_FILE" ] && rm "$TMP_FILE"
  nvram unset log_firewall_blocklist
  [ "$VERBOSE" ] && echo -e "- Removed temporary files.\n- Cleaning done."
}

set_ipset() {
  [ -r "$BL_FILE" ] || { >&2 echo -e "\033[31m! $BL_FILE not readable!\033[0m"; exit 1; }
  [ "$VERBOSE" ] && echo "- Starting $SC_NAME engine..."
  engine_start "$INFO_FROM_SC"
  [ "$VERBOSE" ] && echo "- Done."
}

update_iplist() {
  [ "$VERBOSE" ] && echo -e "\033[1;36mUpdating blocklist from sources...\033[0m"
  [ -e "$SRC_LIST" ] || get_def_srclst

  :>"$TMP_FILE"
  # Process each source url
  [ "$VERBOSE" ] && echo "- Downloading lists defined in $SRC_LIST"
  [ "$VERBOSE" ] && WGET_OPTS='-qO- --show-progress' || WGET_OPTS='-qO-'
  _NBOK=0; _TOT=0;
  grep -v "^[[:space:]*\#]" "$SRC_LIST" | \
  { while read -r URL; do
      _TOT=$((_TOT+1))
      [ "$VERBOSE" ] && echo -e "$_TOT) $URL\033[35m"
      { { { { wget $WGET_OPTS "$URL"; echo $? >&3; } | grep '^[0-9]' | sed 's/;.*//' >>"$TMP_FILE"; } 3>&1; } | { read _EC; exit $_EC; } } 4>&1
      _EC=$?
      [ "$VERBOSE" ] && echo -e "\033[0m"
      [ $_EC = 0 ] && _NBOK=$((_NBOK+1)) || >&2 echo -e "\033[31m! Wget error code $_EC! Could not download $URL\033[0m"
    done
    [ $_NBOK = 0 ] && { >&2 echo -e "\033[31m! Could not get any list!\033[0m"; rm "$TMP_FILE"; exit 1; }
    [ $_NBOK = $_TOT ] || >&2 echo -e "\033[31m! Downloaded only $_NBOK / $_TOT list(s)!\033[0m"
  }
  if [ -r "$CUST_BL_FILE" ]; then
    [ "$VERBOSE" ] && echo "- Adding netset from custom blacklist ($CUST_BL_FILE)"
    grep '^[0-9]' "$CUST_BL_FILE" | sed 's/;.*//' >>"$TMP_FILE"
  fi
  if [ -x "$IPR_BIN" ]; then
    [ "$VERBOSE" ] && echo "- Optimizing and reducing netset (using iprange)..."
    $IPR_BIN --ipset-reduce 20 "$TMP_FILE" > "$BL_FILE"
  else
    [ "$VERBOSE" ] && echo -e "- iprange not installed, passing optimization and reduction process.\n- Removing duplicates..."
    sort "$TMP_FILE" | uniq > "$BL_FILE"
  fi
  rm "$TMP_FILE" 2>/dev/null
  [ "$VERBOSE" ] && echo "- Done."

  # processing whitelist if any
  if [ -r "$CUST_WL_FILE" ]; then
    [ "$VERBOSE" ] && echo -e "\033[1;36mGenerating whitelist from custom list...\033[0m"
    grep '^[0-9]' "$CUST_WL_FILE" | sed 's/;.*//' >"$TMP_FILE"
    
    if [ -s "$TMP_FILE" ]; then
      if [ -x "$IPR_BIN" ]; then
        if [ "$($IPR_BIN --common "$BL_FILE" "$TMP_FILE")" ]; then
          [ "$VERBOSE" ] && echo "- Optimizing and reducing netset (using iprange)..."
          $IPR_BIN --ipset-reduce 20 "$TMP_FILE"  > "$WL_FILE"
        else
          echo '- No IP in common with blocklist, skipping whitelist.'
        fi
      else
        [ "$VERBOSE" ] && echo -e "- iprange not installed, passing optimization and reduction process.\n- Removing duplicates..."
        sort "$TMP_FILE" | uniq > "$WL_FILE"
      fi
      else echo '- No IP set found, custom whitelist is empty.'
    fi
    rm "$TMP_FILE"
    [ "$VERBOSE" ] && echo "- Done."
  else
    rm "$WL_FILE" 2>/dev/null
  fi
}

status() {
  echo -e "\033[1;36mStatus:\033[0m\n- '$SC_NAME' version: $SC_VERS"
  
  # check iprange binary
  [ "$IPR_BIN" ] && echo "- 'iprange' is installed: $($IPR_BIN --version | head -n 1)" || echo "- 'iprange' is not installed."
  
  # check firewall-start.sh script
  check_firewall_start && STAT_FWS='ok' || STAT_FWS=''
  
  # check post-mount.sh script if script on external drive
  if [ "$EXT_DRIVE" ]; then check_postmount && STAT_PM='ok' || STAT_PM=''; else STAT_PM='na'; fi
  
  # check iptables
  STAT_IPT="$(iptables -S 2>/dev/null | grep -F "$SC_ABR")"
  if [ "$STAT_IPT" ]; then
    _CT=$(echo "$STAT_IPT"|grep -c -- "-A ${SC_ABR}_... -j DROP")
    [ $_CT = 2 ] && STAT_IPT_PBM='' || STAT_IPT_PBM='y'
    
    _CT=$(echo "$STAT_IPT" | grep -cv -- "^-. $SC_ABR")
    if [ "$TUN_IF" ]
      then [ $_CT = 8 ] || STAT_IPT_PBM='y'
      else [ $_CT = 4 ] || STAT_IPT_PBM='y'
    fi
  
    case $(echo "$STAT_IPT"|grep -Fc -- "$IPSET_WL_NAME") in
      2) STAT_IPT_WL='y' ;;
      0) STAT_IPT_WL='' ;;
      *) STAT_IPT_PBM='y' ;;
    esac
  
    case $(echo "$STAT_IPT"|grep -Fc -- "$IPSET_WG_NAME") in
      2) STAT_IPT_WG='y' ;;
      0) STAT_IPT_WG='' ;;
      *) STAT_IPT_PBM='y' ;;
    esac
  
    _CT=$(echo "$STAT_IPT" | grep -cF -- "$WAN_IF -m set --match-set $IPSET_BL_NAME")
    [ $_CT = 4 ] && STAT_IPT_WAN='ok'
  
    if [ "$TUN_IF" ]; then
      _CT=$(echo "$STAT_IPT" | grep -cF -- "$TUN_IF -m set --match-set $IPSET_BL_NAME")
      [ $_CT = 4 ] && STAT_IPT_TUN='ok'
    else
      STAT_IPT_TUN='na'
    fi
  
    # check log    
    case $(echo "$STAT_IPT"| grep -c -- "-A ${SC_ABR}_... -j LOG --log-prefix") in
      2) STAT_LOG='y' ;;
      0) STAT_LOG='' ;;
      *) STAT_IPT_PBM='y' ;;
    esac
  fi
  # end check iptables
  
  # check ipset blocklist
  STAT_IPS="$(ipset -q list $IPSET_BL_NAME -t)"
  
  # check ipset whitelist
  STAT_IPS_WL="$(ipset -q list $IPSET_WL_NAME -t)"
  
  # check ipset WAN gateway whitelist
  STAT_IPS_WG="$(ipset -q list $IPSET_WG_NAME -t)"
  
  if [ "$WAN_GW" = '0.0.0.0' ]; then
    STAT_GW_IN_BL=''; STAT_GW_IN_WG=''
  else
    # check WAN gateway in ipset blocklist
    ipset -q test "$IPSET_BL_NAME" "$WAN_GW" && STAT_GW_IN_BL='y' || STAT_GW_IN_BL=''

    # check WAN gatewan in WAN gateway ipset whitelist
    ipset -q test "$IPSET_WG_NAME" "$WAN_GW" && STAT_GW_IN_WG='y' || STAT_GW_IN_WG=''
  fi
  
  # are settings clean?
  [ -z "$STAT_IPT$STAT_IPS$STAT_IPS_WL$STAT_IPS_WG$STAT_FWS$STAT_PM" ] && STAT_CLEAN='y' || STAT_CLEAN=''
  
  # master check
  if   [ "$STAT_IPT_PBM" ]; then
    _RETVAL=2
    echo -e "- \033[1;31mSomething is not right with iptables setup!\033[0m Use '$SC_NAME status -v' for more details"
  elif [ "$STAT_CLEAN" ]; then
    _RETVAL=2
    echo "- '$SC_NAME' is not active; Settings are clean."
  elif [ "$STAT_IPT_WAN" -a "$STAT_IPT_TUN" -a "$STAT_IPS" -a "$STAT_FWS" -a "$STAT_PM" ]; then
    _RETVAL=0
    echo -ne "- \033[1m'$SC_NAME' is set and active\033[0m"
    [ "$STAT_IPT_WAN" ] && echo -n " for WAN interface ($WAN_IF)"
    [ "$STAT_IPT_TUN" = 'ok' ] && echo -n " and VPN tunnel ($TUN_IF)"
    echo -e ".\n- Filtering $(count_ip_in_ipset $IPSET_BL_NAME) IP adresses."
    [ "$STAT_IPT_WL" ] && if [ "$STAT_IPS_WL" ]; then
      echo "- Bypassing $(count_ip_in_ipset $IPSET_WL_NAME) IP adresses."
    else
      _RETVAL=2
      echo -e "- \033[1;31mWhitelist is defined in ipset but not in iptables!\033[0m Use '$SC_NAME status -v' for more details"
    fi
    if [ "$STAT_GW_IN_BL" -a "$STAT_GW_IN_WG" -a "$STAT_IPT_WG" ]; then
      echo "- WAN gateway IP range is bypassed (because in blocklist)."
    elif [ -z "$STAT_GW_IN_BL$STAT_GW_IN_WG$STAT_IPT_WG" ]; then
      echo "- WAN gateway IP range does not need to be bypassed."
    else
      _RETVAL=2
      echo -e "- \033[1;31mSomething is not right with the WAN gateway bypass!\033[0m Use '$SC_NAME status -v' for more details"
    fi
  else
    _RETVAL=2
    echo -e "- \033[1;31mSomething is not right!\033[0m Use '$SC_NAME -v status' for more details"
  fi
  [ "$STAT_LOG" ] && echo "- Logging is on." || echo "- Logging is off."
  [ "$VERBOSE" ] || return 0
  
  # details
  echo -e "\033[1;36mDetailed status:\033[0m"
  if [ "$STAT_FWS" ]; then
    echo "- 'firewall-start.sh' exists with correct settings."
  else
    if [ "$STAT_CLEAN" ]
      then echo "- 'firewall-start.sh' does not exist or does not have '$SC_NAME' settings."
      else echo -e "- \033[1;31m'firewall-start.sh' does not exist or does not have '$SC_NAME' settings!\033[0m"
    fi
  fi

  if [ "$STAT_PM" ]; then
    [ "$STAT_PM" = 'ok' ] && echo "- 'post-mount.sh' exists with correct settings."
  else
    if [ "$STAT_CLEAN" ]
      then echo "- 'post-mount.sh' does not exist or does not have '$SC_NAME' settings."
      else echo -e "- \033[1;31m'post-mount.sh' does not exist or does not have '$SC_NAME' settings!\033[0m"
    fi
  fi
  
  # dates
  echo "- Actual router time: $(/bin/date +'%Y-%m-%d %X')"
  [ -e "$BL_FILE" ] && echo "- Blocklist generation time: $(/bin/date +'%Y-%m-%d %X' -r $BL_FILE)"
  [ -e "$WL_FILE" ] && echo "- Whitelist generation time: $(/bin/date +'%Y-%m-%d %X' -r $WL_FILE)"
  
  # Status file
  if [ -r "$INFO_FILE" ]; then
    echo "- $SC_NAME engine last launch report:"
    echo -e "\033[35m     $SC_NAME engine was started: $(/bin/date +'%Y-%m-%d %X' -r $INFO_FILE)"
    grep -qF "$INFO_FROM_SC" "$INFO_FILE" && echo "     $SC_NAME engine was started from $SC_NAME script."
    grep -qF "$INFO_FROM_PM" "$INFO_FILE" && echo "     $SC_NAME engine was started from post-mount.sh."
    grep -qF "$INFO_FROM_FWS" "$INFO_FILE" && echo "     $SC_NAME engine was started from a firewall-start.sh."
    grep -qF "$INFO_IPS_BL_LOAD" "$INFO_FILE" && echo '     ipset blocklist was loaded from blocklist file.'
    grep -qF "$INFO_IPS_BL_NEW" "$INFO_FILE" && echo '     ipset blocklist was created empty.'
    grep -qF "$INFO_IPS_BL_KEEP" "$INFO_FILE" && echo '     ipset blocklist was already loaded.'
    grep -qF "$INFO_IPS_BL_WGW" "$INFO_FILE" && echo '     WAN gateway was found in ipset blocklist.'
    grep -qF "$INFO_IPS_WG_ADD" "$INFO_FILE" && echo '     ipset WAN gateway bypass was set.'
    grep -qF "$INFO_IPS_WG_KEEP" "$INFO_FILE" && echo '     ipset WAN gateway bypass was already set.'
    grep -qF "$INFO_IPS_WL_LOAD" "$INFO_FILE" && echo '     ipset whitelist was loaded from whitelist file.'
    grep -qF "$INFO_IPS_WL_KEEP" "$INFO_FILE" && echo '     ipset whitelist was already loaded and was kept.'
    grep -qF "$INFO_IPT_SRC_KEEP" "$INFO_FILE" && echo '     inbound iptables rules were already set!'
    grep -qF "$INFO_IPT_DST_KEEP" "$INFO_FILE" && echo '     outbound iptables rules were already set!'
    grep -qF "$INFO_IPT_LOG" "$INFO_FILE" && echo '     iptables logging rules were set.'
    grep -qF "$INFO_IPT_WG" "$INFO_FILE" && echo '     iptables WAN gateway bypass rules were set.'
    grep -qF "$INFO_IPT_WL" "$INFO_FILE" && echo '     iptables whitelist rules were set.'
    grep -qF "$INFO_IPT_WAN_PBM" "$INFO_FILE" && echo '     iptables WAN rules had problems and were reset.'
    grep -qF "$INFO_IPT_TUN_PBM" "$INFO_FILE" && echo '     iptables VPN rules had problems and were reset.'
    grep -qF "$INFO_IPT_WAN" "$INFO_FILE" && echo '     iptables WAN rules were set.'
    grep -qF "$INFO_IPT_TUN" "$INFO_FILE" && echo '     iptables VPN rules were set.'
    echo -ne "\033[0m"
  else
    echo '- No status file found.'
  fi
  
  if [ "$STAT_IPT" ]; then
    if [ "$STAT_IPT_PBM" ]; then
      echo -e "- \033[31miptables rules are not set properly\033[0m:"
      [ -z "$STAT_IPT_TUN" ] && echo -e "     \033[31miptables rules are not set for VPN tunnel ($TUN_IF)\033[0m"
    else
      echo "- iptables rules are set:"
    fi
    [ "$STAT_IPT_WAN" ] && echo -e "     \033[36mWAN interface ($WAN_IF) rules are set\033[0m"
    [ "$STAT_IPT_TUN" = 'ok' ] && echo -e "     \033[36mVPN tunnel interface ($TUN_IF) rules are set\033[0m"
    [ "$STAT_IPT_WL" ] && echo -e "     \033[36mwhitelist rules are set\033[0m"
    [ "$STAT_IPT_WG" ] && echo -e "     \033[36mWAN gateway bypass rules are set\033[0m"
    echo -ne "\033[35m"
    echo "$STAT_IPT" | sed -e 's/^/     iptables /g'
    echo -ne "\033[0m"
  else
    echo "- iptables rules are not set."
  fi
  if [ "$STAT_LOG" ];
    then echo "- Logging is active."
    else echo "- Logging is inactive."
  fi
  if [ "$STAT_IPS" ]; then
    echo "- ipset blocklist is set:"
    if [ "$STAT_GW_IN_BL" ]
      then if [ "$STAT_GW_IN_WG" ]
        then echo -e "     \033[36mWAN gateway ($WAN_GW) is in blocklist\033[0m"
        else echo -e "     \033[31mWAN gateway ($WAN_GW) is in blocklist (but not bypassed)!\033[0m"
      fi
    fi
    echo -e "\033[35m$STAT_IPS\033[0m" | sed -e 's/^/     /g'
  else
    echo "- ipset blocklist is not set."
  fi
  
  if [ "$STAT_IPS_WL" ]; then
    echo "- ipset whitelist is set:"
    echo -e "\033[35m$STAT_IPS_WL\033[0m" | sed -e 's/^/     /g'
  else
    echo "- ipset whitelist is not set."
  fi
  
  if [ "$STAT_IPS_WG" ]; then
    echo "- ipset WAN gateway bypass is set:"
    [ "$STAT_GW_IN_BL" ] || echo -e "     \033[31mWAN gateway IP ($WAN_GW) is NOT in blocklist!\033[0m"
    if [ "$STAT_GW_IN_WG" ]
        then echo -e "     \033[36mWAN gateway ($WAN_GW) is in bypass list\033[0m"
        else echo -e "     \033[31mWAN gateway ($WAN_GW) is NOT in bypass list!\033[0m"
    fi
    echo -e "\033[35m$STAT_IPS_WG\033[0m" | sed -e 's/^/     /g'
  else
    [ "$STAT_GW_IN_BL" ] && _CLR='\033[31m' || _CLR='\033[0m'
    echo -e "${_CLR}- ipset WAN gateway bypass is not set.\033[0m"
  fi
}

print_help() {
  echo -e "\033[1;36m$SC_NAME $SC_VERS\033[0m"
  echo -e "Usage: \033[1m$SC_NAME \033[35mCOMMAND \033[36m[OPTION(S)]\033[0m"
  echo -e "\033[7mCOMMANDS (use only one):\033[0m"
  echo -e " \033[1;35mrestart\033[0m    - setup ipset and iptables then restarts internal firewall"
  echo -e " \033[1;35mupdate_set\033[0m - generates blocklist set from servers in $SRC_LIST"
  echo -e " \033[1;35mload_set\033[0m   - loads blocklist set into ipset then restarts internal firewall"
  echo -e " \033[1;35mupdate\033[0m     - update_set then load_set \033[1;36m[probably what you want to use]\033[0m"
  echo -e " \033[1;35mclean\033[0m      - clean ipset and iptables rules from setup created by this script"
  echo -e " \033[1;35mhelp\033[0m       - displays help (this)"
  echo -e " \033[1;35minfo\033[0m       - displays info on this script"
  echo -e " \033[1;35mstatus\033[0m     - displays status"
  echo -e " \033[1;35mlog\033[0m        - displays log"
  echo -e " \033[1;35mupgrade\033[0m    - download and install latest version"
  echo -e "\033[7mOPTIONS (none, one or more):\033[0m"
  echo -e " \033[1;36m-v\033[0m          - verbose mode"
  echo -e " \033[1;36m-q\033[0m          - quiet mode"
  echo -e " \033[1;36m-html\033[0m       - sends output to router's web: http://routerlogin.net/bolemo/$SC_NAME.htm"
  echo -e " \033[1;36m-log=on\033[0m/\033[1;36moff\033[0m - when used with restart, load_set or update, will enable/disable logging"
  echo -e " \033[1;36m-rm-symlink\033[0m - when used with clean, removes the symlink /usr/bin/$SC_NAME"
}

###############################################
#
#    MAIN ROUTINE
#
###############################################
_RETVAL=0

[ $# = 0 ] && { >&2 echo -e "\033[31m! No parameter!\033[0m"; print_help; exit 1; }
[ "$1" = "_pm" ] && [ "$2" ] && _pm

PARAM="$(echo "$*" | /bin/sed 's/-[[:alpha:]=]*//g')"
case $(echo "$PARAM" | wc -w) in
  0) >&2 echo -e "\033[31m! No parameter!\033[0m"; print_help; exit 1 ;;
  1) PARAM="$(echo "$PARAM" | sed 's/ //g')" ;;
  *) >&2 echo -e "\033[31m! Too many parameters!\033[0m"; print_help; exit 1 ;;
esac

ARGS=" $* "
[ -z "${ARGS##* -v *}" ] && VERBOSE='y'
[ -z "${ARGS##* -q *}" ] && QUIET='y'
[ -z "${ARGS##* --devmode *}" ] && DEVMODE='y'
[ -z "${ARGS##* -log=on *}" ] && set_log_state 'ON'
[ -z "${ARGS##* -log=off *}" ] && set_log_state 'OFF'
[ -z "${ARGS##* -rm-symlink *}" ] && RM_SYMLINK='y'
[ -z "${ARGS##* -html *}" ] && _HTML="$WWW_PATH/$SC_NAME.htm"

[ "$QUIET" ] && exec>/dev/null

if [ "$_HTML" ]; then
  echo -e '<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">\n<title>aegis page</title>\n<pre>'>$_HTML
  echo -e "Time: $(/bin/date +'%Y-%m-%d %X')\nCommand: $0 $@\nOutput:\n">>$_HTML
  exec>>$TMP_HTML
fi

pre_init

if [ $DEVMODE ]; then echo -e "\033[7;31m$SC_NAME $SC_VERS - Developer mode\033[0m"; VERBOSE='y'
elif [ $VERBOSE ]; then echo -e "\033[7;31m$SC_NAME $SC_VERS - Verbose mode\033[0m"; fi

case "$PARAM" in
  "restart") init; fw_restart; [ $VERBOSE ] && status ;;
  "clean") clean; [ $VERBOSE ] && status ;;
  "load_set") init; set_ipset; [ $VERBOSE ] && status ;;
  "update_set") update_iplist ;;
  "update") init; update_iplist; set_ipset; [ $VERBOSE ] && status ;;
  "status") status ;;
  "help") print_help ;;
  "info") info ;;
  "log") print_log ;;
  "upgrade") upgrade ;;
  *) >&2 echo -e "\033[31m! Unknown Parameter $2!\033[0m"; print_help; exit 1 ;;
esac

if [ "$_HTML" ]; then
  sed 's/[[:cntrl:]]\[\([^m]*\)m//g' $TMP_HTML>>$_HTML
  \rm $TMP_HTML 2>/dev/null
fi

exit $_RETVAL
