#! /bin/sh
command -v iptables>/dev/null 2>&1 || export PATH=/bin:/sbin:/usr/bin:/usr/sbin
command -v iprange>/dev/null 2>&1 || [ -e /root/.profile ] && source /root/.profile
SC_VERS="1.2.0"
SC_NAME="aegis"
SC_ABR="aegis"
IPR_BIN="$(command -v iprange)"
IPTBL_SRC="${SC_ABR}_src"
IPTBL_DST="${SC_ABR}_dst"
[ "$(nvram get aegis_log)" = "1" ] && IPTBL_LOGGING='y' || IPTBL_LOGGING=''
IPSET_BL_NAME="${SC_ABR}_bl"
IPSET_WL_NAME="${SC_ABR}_wl"
IPSET_WG_NAME="${SC_ABR}_wg"
IPSET_TMP="${IPSET_BL_NAME}_tmp"
ROOT_DIR="/opt/bolemo"
BL_FILE="$ROOT_DIR/etc/${SC_NAME}-bl.netset"
WL_FILE="$ROOT_DIR/etc/${SC_NAME}-wl.netset"
INFO_FILE="/tmp/${SC_ABR}_status"
ifconfig ppp0 >/dev/null 2>/dev/null && WAN_IF='ppp0' || WAN_IF="$(nvram get wan_ifname)"
WAN_GW="$(nvram get wan_gateway)"
WAN_NM="$(nvram get wan_netmask)"
# VPN tunnel detection
if ifconfig wg0 >/dev/null 2>/dev/null; then
  # WireGuard
  TUN_IF='wg0'
elif ps -w|grep -vE 'grep|server_tap|server_tun'|grep -qF -- '/usr/sbin/openvpn --dev'; then
  # Open VPN client
  TUN_IF="$(ps -w|grep -F -- '/usr/sbin/openvpn --dev'|grep -vE 'grep|server_tap|server_tun'|sed -n -- 's/.*openvpn --dev \([[:alnum:]]*\).*/\1/p')"
else
  # No tunneling
  TUN_IF=''
fi

# INFO FROM (2 bits)
INFO_FROM_MASK=3
INFO_FROM_FWS=1       # _ x
INFO_FROM_PM=2        # x _
INFO_FROM_SC=3        # x x

# INFO IPSET (8 bits)
INFO_IPS_MASK=255
                      # . . . . . . _ _  PBM, BL FILE MISSING
INFO_IPS_BL_SAME=1    # . . . . . . _ x  KEEP
INFO_IPS_BL_MISS=2    # . . . . . . x _  KEEP
INFO_IPS_BL_LOAD=3    # . . . . . . x x
INFO_IPS_BL_MASK=3    # . . . . . . x x

INFO_IPS_WL_SAME=4    # . . . _ . x . .  SAME => KEEP
INFO_IPS_WL_KEEP=8    # . . . _ x . . .  KEEP
INFO_IPS_WL_LOAD=16   # . . . x _ _ . .
INFO_IPS_WL_SWAP=20   # . . . x _ x . . = RELOAD
INFO_IPS_WL_DEL=24    # . . . x x _ . . => was there, was deleted
                      # . . . _ _ _ . . => was not there, was not loaded
INFO_IPS_WL_MASK=28   # . . . x x x . .

INFO_IPS_WG_ADD=32    # _ _ x . . . . . => IN BL
INFO_IPS_WG_KEEP=64   # _ x _ . . . . . => IN BK
INFO_IPS_WG_DEL=128   # x _ _ . . . . .
INFO_IPS_WG_MASK=224  # x x x . . . . .
                      # _ _ _ . . . . . => was not there, was not loaded

# INFO IPTABLES (16 bits)
INFO_IPT_MASK=65535
INFO_IPT_SRC_KEEP=1        # . . . . . . . . . . . . . . . x (or NEW)
INFO_IPT_DST_KEEP=2        # . . . . . . . . . . . . . . x . (or NEW)
INFO_IPT_WG=4              # . . . . . . . . . . . . . x . .
INFO_IPT_WG_SRC_NEW=8      # . . . . . . . . . . . . x . . . (or KEEP)
INFO_IPT_WG_DST_NEW=16     # . . . . . . . . . . . x . . . . (or KEEP)
INFO_IPT_WL=32             # . . . . . . . . . . x . . . . .
INFO_IPT_WL_SRC_NEW=64     # . . . . . . . . . x . . . . . . (or KEEP)
INFO_IPT_WL_DST_NEW=128    # . . . . . . . . x . . . . . . . (or KEEP)
INFO_IPT_LOG=256           # . . . . . . . x . . . . . . . .
INFO_IPT_LOG_SRC_NEW=512   # . . . . . . x . . . . . . . . . (or KEEP)
INFO_IPT_LOG_DST_NEW=1024  # . . . . . x . . . . . . . . . . (or KEEP)

INFO_IPT_WAN_NEW=2048      # . . . _ x . . . . . . . . . . .
INFO_IPT_WAN_KEEP=4096     # . . . x _ . . . . . . . . . . .
INFO_IPT_WAN_PBM=6144      # . . . x x . . . . . . . . . . .

INFO_IPT_TUN_NEW=8192      # . _ x . . . . . . . . . . . . .
INFO_IPT_TUN_KEEP=16384    # . x _ . . . . . . . . . . . . .
INFO_IPT_TUN_PBM=24576     # . x x . . . . . . . . . . . . .

INFO_IPT_IFO_PBM=32768     # x . . . . . . . . . . . . . . .

###############################################
#
#    ENGINE-START
#
###############################################

ipset_list_members() {
  ipset -L "$1"|sed -n '/Members:/,$p'|tail -n+2
}

diff_ipset_file() {
  if [ "$IPR_BIN" ]
    then ipset_list_members "$1"|iprange --quiet - --diff "$2"
    else ipset_list_members "$1"|sort|diff -q - "$2" >/dev/null
  fi
  return $?
}

_set_ipt_for_if_pos() {
  _IF="$1"
  _POS=$2
  _CT=$(iptables -S 2>/dev/null|grep -cF -- "$_IF -m set --match-set $IPSET_BL_NAME")
  if [ $_CT -ne 4 ]; then
    if [ $_CT -ne 0 ]; then
      # something is messed up with rules; deleting what is left
      iptables -S 2>/dev/null|grep -F -- "$_IF -m set --match-set $IPSET_BL_NAME"|sed 's/^-A/iptables -D/'|while read _CMD; do eval "$_CMD 2>/dev/null"; done
      _RET=2
    else
      _RET=1
    fi
    iptables -I INPUT $_POS -i $_IF -m set --match-set "$IPSET_BL_NAME" src -j "$IPTBL_SRC"
    iptables -I OUTPUT $_POS -o $_IF -m set --match-set "$IPSET_BL_NAME" dst -j "$IPTBL_DST"
    iptables -I FORWARD $_POS -i $_IF -m set --match-set "$IPSET_BL_NAME" src -j "$IPTBL_SRC"
    iptables -I FORWARD $((_POS*2)) -o $_IF -m set --match-set "$IPSET_BL_NAME" dst -j "$IPTBL_DST"
  else
    _RET=0
  fi
  return $_RET
}

engine_start() {
  _FROM=$1
  [ $_FROM = $INFO_FROM_SC ] && _RELOAD_WTD='y'

  _IPS=0; _IPT=0;
  # creating ipset blocklist if needed
  if ipset -q -n list "$IPSET_BL_NAME">/dev/null; then
    # an ipset blocklist is already loaded
    if [ -r "$BL_FILE" ]; then
      [ "$_RELOAD_WTD" ] && _RELOAD='y'
      # checking if ipset and file are identical
      if [ "$IPR_BIN" ] && ipset_list_members "$IPSET_BL_NAME"|iprange --quiet - --diff "$BL_FILE"
        then _RELOAD=''; _IPS=$((_IPS+INFO_IPS_BL_SAME))
        else _RELOAD='y'
      fi
    else
      # blocklist file is missing!
      _RELOAD=''
      _IPS=$((_IPS+INFO_IPS_BL_MISS))
    fi
    if [ "$_RELOAD" ]; then
    # reload is asked for; so need to swap ipset
      echo -e "create $IPSET_TMP hash:net family inet maxelem $(wc -l < "$BL_FILE")\n$(sed "s/^/add $IPSET_TMP /" $BL_FILE)" | ipset restore
      ipset swap "$IPSET_BL_NAME" "$IPSET_TMP"
      ipset destroy $IPSET_TMP
      _IPS=$((_IPS+INFO_IPS_BL_LOAD))
    # else keeping existing blocklist
    fi
  else
    if [ -r "$BL_FILE" ]; then
    # netset file exists, so creating blocklist ipset from it
      echo -e "create $IPSET_BL_NAME hash:net family inet maxelem $(wc -l < "$BL_FILE")\n$(sed "s/^/add $IPSET_BL_NAME /" "$BL_FILE")" | ipset restore
      _IPS=$((_IPS+INFO_IPS_BL_LOAD))
    else
    # no netset file, exiting with _IPS=0
      exit 1
    fi
  fi
  
  # checking if WAN gateway is in blocklist
  if [ "$WAN_GW" != '0.0.0.0' ] && ipset -q test "$IPSET_BL_NAME" "$WAN_GW"; then
    _WG='y'
    _IPS=$((_IPS+INFO_IPS_BL_WGW))
    if ! ipset -q test "$IPSET_WG_NAME" "$WAN_GW"; then
      # Calculate WAN_RANGE (IP & CIDR)
      _CIDR=0
      for _OCTET in $(echo "$WAN_NM"| sed 's/\./ /g'); do
        _BINBITS=$(echo "obase=2; ibase=10; ${_OCTET}"| bc | sed 's/0//g')
        let _CIDR+=${#_BINBITS}
      done
      WAN_RANGE="$WAN_GW/$_CIDR"
      ipset -q create "$IPSET_WG_NAME" hash:net family inet
      ipset -q flush "$IPSET_WG_NAME"
      ipset -q add "$IPSET_WG_NAME" "$WAN_RANGE"
      _IPS=$((_IPS+INFO_IPS_WG_ADD))
    else
      _IPS=$((_IPS+INFO_IPS_WG_KEEP))
    fi
  fi
  
  # creating ipset whitelist if needed
  if ipset -q -n list "$IPSET_WL_NAME">/dev/null; then
    # ipset whitelist is already in place
    if [ -r "$WL_FILE" ]; then
      _WL='y'
      [ "$_RELOAD_WTD" ] && _RELOAD='y' || _RELOAD=''
      # checking if ipset and file are identical
      if [ "$IPR_BIN" ] && ipset_list_members "$IPSET_WL_NAME"|iprange --quiet - --diff "$WL_FILE"
        then _RELOAD=''; _IPS=$((_IPS+INFO_IPS_WL_SAME))
        else _RELOAD='y'
      fi
      if [ "$_RELOAD" ]; then
      # reload is asked for; so need to swap ipset
        echo -e "create $IPSET_TMP hash:net family inet\n$(sed "s/^/add $IPSET_TMP /" $WL_FILE)" | ipset restore
        ipset swap "$IPSET_WL_NAME" "$IPSET_TMP"
        ipset destroy "$IPSET_TMP"
        _IPS=$((_IPS+INFO_IPS_WL_SWAP))
      else
      # else we want to keep it
        _IPS=$((_IPS+INFO_IPS_WL_KEEP))
      fi
    #else it will be destroyed later
    fi
  else
    if [ -r "$WL_FILE" ]; then
      # netset file exists, so creating whitelist ipset from it
      _WL='y'
      echo -e "create $IPSET_WL_NAME hash:net family inet\n$(sed "s/^/add $IPSET_WL_NAME /" "$WL_FILE")" | ipset restore
      _IPS=$((_IPS+INFO_IPS_WL_LOAD))
    fi
  fi

  #Creating our iptables chains if not already set
  iptables -L "$IPTBL_SRC" >/dev/null 2>/dev/null && _IPT=$((_IPT+INFO_IPT_SRC_KEEP)) || iptables -N "$IPTBL_SRC"
  iptables -L "$IPTBL_DST" >/dev/null 2>/dev/null && _IPT=$((_IPT+INFO_IPT_DST_KEEP)) || iptables -N "$IPTBL_DST"

  if [ "$_WG" ]; then
    # apply wan gateway whitelist
    _POS=1
    if ! iptables -S "$IPTBL_SRC" $_POS | grep -qF -- "$IPSET_WG_NAME"; then
      iptables -S "$IPTBL_SRC" 2>/dev/null | grep -F -- "$IPSET_WG_NAME" | sed 's/^-A/iptables -D/' | while read _CMD; do eval "$_CMD 2>/dev/null"; done
      iptables -I "$IPTBL_SRC" $_POS -i $WAN_IF -m set --match-set "$IPSET_WG_NAME" src -j ACCEPT
      _IPT=$((_IPT+INFO_IPT_WG_SRC_NEW))
    fi
    if ! iptables -S "$IPTBL_DST" $_POS | grep -qF -- "$IPSET_WG_NAME"; then
      iptables -S "$IPTBL_DST" 2>/dev/null | grep -F -- "$IPSET_WG_NAME" | sed 's/^-A/iptables -D/' | while read _CMD; do eval "$_CMD 2>/dev/null"; done
      iptables -I "$IPTBL_DST" $_POS -o $WAN_IF -m set --match-set "$IPSET_WG_NAME" dst -j ACCEPT
      _IPT=$((_IPT+INFO_IPT_WG_DST_NEW))
    fi
    _IPT=$((_IPT+INFO_IPT_WG))
  else
    #Removing any trace of WAN gateway bypass if any
    iptables -S 2>/dev/null | grep -F -- "$IPSET_WG_NAME" | sed 's/^-A/iptables -D/' | while read _CMD; do eval "$_CMD 2>/dev/null"; done
    ipset -q destroy "$IPSET_WG_NAME" && _IPS=$((_IPS+INFO_IPS_WG_DEL))
    _POS=0
  fi

  if [ "$_WL" ]; then
    # apply whitelist
    _POS=$((1+_POS))
    if ! iptables -S "$IPTBL_SRC" $_POS | grep -qF -- "$IPSET_WL_NAME"; then
      iptables -S "$IPTBL_SRC" 2>/dev/null | grep -F -- "$IPSET_WL_NAME" | sed 's/^-A/iptables -D/' | while read _CMD; do eval "$_CMD 2>/dev/null"; done
      iptables -I "$IPTBL_SRC" $_POS -m set --match-set "$IPSET_WL_NAME" src -j ACCEPT
      _IPT=$((_IPT+INFO_IPT_WL_SRC_NEW))
    fi
    if ! iptables -S "$IPTBL_DST" $_POS | grep -qF -- "$IPSET_WL_NAME"; then
      iptables -S "$IPTBL_DST" 2>/dev/null | grep -F -- "$IPSET_WL_NAME" | sed 's/^-A/iptables -D/' | while read _CMD; do eval "$_CMD 2>/dev/null"; done
      iptables -I "$IPTBL_DST" $_POS -m set --match-set "$IPSET_WL_NAME" dst -j ACCEPT
      _IPT=$((_IPT+INFO_IPT_WL_DST_NEW))
    fi
    _IPT=$((_IPT+INFO_IPT_WL))
  else
    #Removing any trace of whitelist if any
    iptables -S 2>/dev/null | grep -F -- "$IPSET_WL_NAME" | sed 's/^-A/iptables -D/' | while read _CMD; do eval "$_CMD 2>/dev/null"; done
    ipset -q destroy "$IPSET_WL_NAME" && _IPS=$((_IPS+INFO_IPS_WL_DEL))
  fi

  if [ "$IPTBL_LOGGING" ]; then
    _POS=$((1+_POS))
    if ! iptables -S "$IPTBL_SRC" $_POS | grep -qF -- "-j LOG"; then
      iptables -D "$IPTBL_SRC" -j LOG --log-prefix "[$SC_NAME] " 2>/dev/null
      iptables -I "$IPTBL_SRC" $_POS -j LOG --log-prefix "[$SC_NAME] "
      _IPT=$((_IPT+INFO_IPT_LOG_SRC_NEW))
    fi
    if ! iptables -S "$IPTBL_DST" $_POS | grep -qF -- "-j LOG"; then
      iptables -D "$IPTBL_DST" -j LOG --log-prefix "[$SC_NAME] " 2>/dev/null
      iptables -I "$IPTBL_DST" $_POS -j LOG --log-prefix "[$SC_NAME] "
      _IPT=$((_IPT+INFO_IPT_LOG_DST_NEW))
    fi
    _IPT=$((_IPT+INFO_IPT_LOG))
  else
    iptables -D "$IPTBL_SRC" -j LOG --log-prefix "[$SC_NAME] " 2>/dev/null
    iptables -D "$IPTBL_DST" -j LOG --log-prefix "[$SC_NAME] " 2>/dev/null
  fi
  iptables -S "$IPTBL_SRC" | grep -qF -- "-j DROP" || iptables -A "$IPTBL_SRC" -j DROP
  iptables -S "$IPTBL_DST" | grep -qF -- "-j DROP" || iptables -A "$IPTBL_DST" -j DROP
  
  # checking and cleaning anything that is not WAN_IF or TUN_IF in IFO chains
  IFO_IPT="$(iptables -S 2>/dev/null|grep -- "-A \(INPUT\|FORWARD\|OUTPUT\) -\(i\|o\) [[:alnum:]]\+ -m set --match-set $IPSET_BL_NAME"|grep -v "\($WAN_IF\|$TUN_IF\)")"
  if [ "$IFO_IPT" ]; then
    # we have some unwanted rules (likely old WAN_IF or TUN_IF)
    echo "$IFO_IPT"|sed 's/^-A/iptables -D/'|while read _CMD; do eval "$_CMD 2>/dev/null"; done
    _IPT=$((_IPT+INFO_IPT_IFO_PBM))
  fi
  
  # creating the required iptables rules for wan interface
  _set_ipt_for_if_pos "$WAN_IF" 1
  case $? in
    2) _IPT=$((_IPT+INFO_IPT_WAN_PBM)) ;;
    1) _IPT=$((_IPT+INFO_IPT_WAN_NEW)) ;;
    0) _IPT=$((_IPT+INFO_IPT_WAN_KEEP)) ;;
  esac
  
  # creating the required iptables rules for vpn tunnel interface (if needed)
  if [ "$TUN_IF" ]; then
    _set_ipt_for_if_pos "$TUN_IF" 2
    case $? in
      2) _IPT=$((_IPT+INFO_IPT_TUN_PBM)) ;;
      1) _IPT=$((_IPT+INFO_IPT_TUN_NEW)) ;;
      0) _IPT=$((_IPT+INFO_IPT_TUN_KEEP)) ;;
    esac
  fi
  
  echo -e "$((_FROM+(_IPS<<2)+(_IPT<<10)))" > "$INFO_FILE"
}

###############################################
#
#    CALLED FROM FIREWALL-START & POST-MOUNT
#
###############################################

#we are called from firewall_start.sh
if [ "$1" ] && [ "$1" = "_fws" ]; then
  engine_start "$INFO_FROM_FWS"
  exit 0
fi

#when called from post-mount.sh
_pm() {
  [ -d /opt/bolemo ] || /bin/ln -sfn /tmp/mnt/$2/bolemo /opt/bolemo
  pre_init
  init
  engine_start "$INFO_FROM_PM"
  exit 0
}

###############################################
#
#    ADDITIONNAL GLOBALS NEEDED WHEN NOT CALLED FROM FIREWALL-START
#
###############################################
SC_PATH="$(cd "$(\ls -l "$0"|sed 's/.* \([^ ]*\)\/[^/]*$/\1/')">/dev/null 2>&1; pwd -P)"
SC_NICEPATH="$ROOT_DIR/scripts/$SC_NAME"
SRC_LIST="$ROOT_DIR/etc/$SC_NAME.sources"
CUST_BL_FILE="$ROOT_DIR/etc/$SC_NAME.custom-blacklist.netset"
CUST_WL_FILE="$ROOT_DIR/etc/$SC_NAME.custom-whitelist.netset"
TMP_FILE="/tmp/$SC_NAME.tmp"
TMP_HTML="/tmp/$SC_NAME-html.tmp"
WWW_PATH="$ROOT_DIR/www"
FWS_DIR="/opt/scripts"
FWS_FILE="$FWS_DIR/firewall-start.sh"
# Check if scriot is installed on USB
if echo "$SC_PATH" | grep -q '^/tmp/mnt/'; then
  PM_DIR="$(echo "$SC_PATH" | sed "s|\(/tmp/mnt/[[:alnum:]]*\)/.*|\1|")/autorun/scripts"
  PM_FILE="$PM_DIR/post-mount.sh"
  EXT_DRIVE='y'
else
  EXT_DRIVE=''
fi

###############################################
#
#    DEALING WITH EXTERNAL SCRIPTS/CONFS
#    check, set, clean
#
###############################################

# SCRIPT: firewall-start.sh ###################
check_firewall_start() {
  [ -x $FWS_FILE ] || return 1
  [ "$(sed 's/[[:space:]]\+/ /g' $FWS_FILE | grep -c -- "\[ -x $SC_NICEPATH \] && $SC_NICEPATH _fws")" = 1 ] || return 1
  return 0
}

set_firewall_start() {
  [ -d "$FWS_DIR" ] || mkdir -p "$FWS_DIR"
  [ -e "$FWS_FILE" ] && sed -i "/$SC_NAME/d" "$FWS_FILE"
  echo -e "# Bolemo $SC_NAME\n[ -x $SC_NICEPATH ] && $SC_NICEPATH _fws" >> "$FWS_FILE"
  [ -x "$FWS_FILE" ] || chmod +x "$FWS_FILE"
}

clean_firewall_start() {
  if [ -e "$FWS_FILE" ]; then
    if [ "$(grep -Fv "$SC_NAME" "$FWS_FILE" | sed '/^[[:space:]]*$/d')" ]; then
      sed -i "/$SC_NAME/d" "$FWS_FILE"
      [ "$VERBOSE" ] && echo "- 'firewall-start.sh' has some other rules; removed only our rules."
    else
      rm "$FWS_FILE" 2>/dev/null
      [ "$VERBOSE" ] && echo "- 'firewall-start.sh' had no other rules; removed it."
    fi
  fi
}

# SCRIPT: post-mount.sh ########################
check_postmount() {
  [ -x "$PM_FILE" ] || return 1
  [ "$(sed 's/[[:space:]]\+/ /g' $PM_FILE | grep -cF -- "[ -x $SC_NICEPATH ] && $SC_NICEPATH _pm \$1")" = 1 ] || return 1
  return 0
}

set_postmount() {
  [ "$EXT_DRIVE" ] || return 1
  [ -d "$PM_DIR" ] || mkdir -p "$PM_DIR"
  [ -e "$PM_FILE" ] && sed -i "/$SC_NAME/d" "$PM_FILE"
  echo -e "# Bolemo $SC_NAME\n[ -x $SC_NICEPATH ] && $SC_NICEPATH _pm \$1" >> "$PM_FILE"
  [ -x "$PM_FILE" ] || chmod +x "$PM_FILE"
}

clean_postmount() {
  if [ "$EXT_DRIVE" ] && [ -e "$PM_FILE" ]; then
    if [ "$(grep -Fv "$SC_NAME" "$PM_FILE" | sed '/^[[:space:]]*$/d')" ]; then
      sed -i "/$SC_NAME/d" "$PM_FILE"
      [ "$VERBOSE" ] && echo "- 'post-mount.sh' has some other code; removed only our code."
    else
      rm "$PM_FILE" 2>/dev/null
      [ "$VERBOSE" ] && echo "- 'post-mount.sh' had no other code; removed it."
    fi
  fi
}

# SYMLINK: /usr/bin/SELF ######################
check_path() {
  command -v "$SC_NAME" > /dev/null && return 0 || return 1
}

set_path() {
  [ -e "/usr/bin/$SC_NAME" ] || ln -s "/opt/bolemo/scripts/$SC_NAME" "/usr/bin/$SC_NAME"
}

clean_path() {
  if [ -e "/usr/bin/$SC_NAME" ]; then
    rm "/usr/bin/$SC_NAME" 2>/dev/null
    [ "$VERBOSE" ] && echo "- '/usr/bin' symlink was removed."
  fi
}

###############################################
#
#    FUNCTIONS DEPENDING ON BOLEMO GIT REPO
#
###############################################
BOLEMO_GIT_REPO='https://raw.githubusercontent.com/bolemo'
SC_BASE_REPO="$BOLEMO_GIT_REPO/$SC_NAME"
SC_MAIN_REPO="$SC_BASE_REPO/master"
SC_DEV_REPO="$SC_BASE_REPO/Dev2"

last_avail_version() {
  wget -qO- "$SC_MAIN_REPO/version"
}

upgrade() {
  echo -e "\033[1;36mUpgrading:\033[0m"
  echo "- Version installed: $SC_VERS"
  if [ "$DEVMODE" ]; then
    echo "- Devmode on, force downloading dev version..."
    UPGRADE_URL="$SC_DEV_REPO/$SC_NAME"
  else
    echo -ne "- Checking latest available version...\r"
    SC_LAST_VERS="$(last_avail_version)"
    if [ "$SC_LAST_VERS" ]; then
      _LOC_VERS=$(echo "$SC_VERS"|sed 's/[^[:digit:]]//g')
      _REM_VERS=$(echo "$SC_LAST_VERS"|sed 's/[^[:digit:]]//g')
      if [ $_LOC_VERS -eq $_REM_VERS ]; then echo "- This is already the last version.            "; exit 0
      elif [ $_LOC_VERS -lt $_REM_VERS ]; then echo "- New version available: $SC_LAST_VERS       "
      else echo -e "\033[35m- This version is higher than than the one available: $SC_LAST_VERS       \033[0m"
      fi
    else
      >&2 echo -e "\033[31m! Could not check what is the last version online!\033[0m"
      exit 1
    fi
    UPGRADE_URL="UPGRADE_URL="$SC_MAIN_REPO/$SC_NAME""
  fi
  if [ ! "$DEVMODE" ]; then
    echo -n "? Do you want to upgrade from $SC_VERS to $SC_LAST_VERS (y/n)? "
    case "$(i=0;while [ $i -lt 2 ];do i=$((i+1));read -p '' YN </dev/tty;[ -n "$YN" ] && echo "$YN" && break;done)" in Y|y|yes|Yes|YES) : ;; *) exit 0 ;; esac
  fi
  echo "- Downloading:"

  DL_PATH="/tmp/$SC_NAME.dl"
  _PROG='--show-progress';
  [ "$DEVMODE" ] && _PROG="--no-cache $_PROG"
  echo -ne "\033[35m"
  if wget -qO "$DL_PATH" $_PROG "$UPGRADE_URL"; then
    sed -i 's/^[[:space:]]*// ; 1!{/^#/d;} ; /^$/d' "$DL_PATH"
    \mv "$DL_PATH" "$SC_NICEPATH"
    chmod +x "$SC_NICEPATH"
    echo -e "\033[0m- Script installed to $SC_NICEPATH"
  else
    echo -ne "\033[0m"
    >&2 echo -e "\033[31m! Wget error code $?! Could not download $DL_PATH\033[0m"
    rm -f "$DL_PATH"
    exit 1
  fi

  exit 0
}

# get default sources list (from bolemo github)
get_def_srclst() {
  if [ ! -e "$SRC_LIST" ]; then
    [ "$VERBOSE" ] && echo -e "! $SRC_LIST is missing!"
    SRC_LIST_URL="$SC_MAIN_REPO/$SC_NAME.sources"
    if wget -qO "$SRC_LIST" "$SRC_LIST_URL"; then
      [ "$VERBOSE" ] && echo -e "- Default list was downloaded."
    else
      >&2 echo -e "\033[31m! Wget error code $?! Could not download $SRC_LIST_URL\033[0m"
      rm -f "$SRC_LIST"
      exit 1
    fi
  fi
}

###############################################
#
#    UTILITY FUNCTIONS
#
###############################################

count_ip_in_file() {
  if [ -x "$IPR_BIN" ]
    then $IPR_BIN -C "$1" | sed -n 's/.*,//p'
    else grep -oE '(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\/([0-9]{1,2})' "$1" | awk -F / '{ count[$2]++ } END { for (mask in count) total+=count[mask]*2^(32-mask); print total }'
  fi
}

count_ip_in_ipset() {
  if [ -x "$IPR_BIN" ]
    then ipset_list_members "$1" | $IPR_BIN -C | sed -n 's/.*,//p'
    else ipset_list_members "$1" | grep -oE '(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\/([0-9]{1,2})' | awk -F / '{ count[$2]++ } END { for (mask in count) total+=count[mask]*2^(32-mask); print total }'
  fi
}

###############################################
#
#    INIT FUNCTIONS
#    script init & when using firewall init
#
###############################################

pre_init() {
  check_path || set_path
  [ -d "$ROOT_DIR/etc" ] || mkdir "$ROOT_DIR/etc" 2>/dev/null
  [ -d "$ROOT_DIR/www" ] || mkdir "$ROOT_DIR/www" 2>/dev/null
  [ -d '/www/bolemo' ] || ln -sfn "$ROOT_DIR/www" '/www/bolemo' 2>/dev/null
}

init() {
  [ "$VERBOSE" ] && echo -e "\033[1;36mInitializing...\033[0m"
  ipset -q destroy $IPSET_TMP
  if check_firewall_start; then
    [ "$VERBOSE" ] && echo "- 'firewall-start.sh' is in place and ok."
  else
    set_firewall_start
    check_firewall_start || { >&2 echo -e "\033[31m! Problem with $FWS_FILE!\033[0m"; exit 1; }
    [ "$VERBOSE" ] && echo "- 'firewall-start.sh' was edited and is now ok."
  fi
  if [ "$EXT_DRIVE" ]; then
    [ "$VERBOSE" ] && echo "- '$SC_NAME' is installed on external drive."
    if check_postmount; then
      [ "$VERBOSE" ] && echo "- 'post-mount.sh' is in place and ok."
    else
      set_postmount
      check_postmount || { >&2 echo -e "\033[31m! Problem with $PM_FILE!\033[0m"; exit 1; }
      [ "$VERBOSE" ] && echo "- 'post-mount.sh' was edited and is now ok."
    fi
  else
    [ "$VERBOSE" ] && echo "- '$SC_NAME' is installed on internal drive."
  fi
}

fw_restart() {
  [ "$VERBOSE" ] && echo -e "\033[1;36mRestarting firewall...\033[0m"
  set_log_state
  /usr/sbin/net-wall restart > /dev/null
  [ "$VERBOSE" ] && echo "- Firewall restarted."
}

###############################################
#
#    FUNCTIONS FOR SCRIPT CMD ARGUMENTS
#
###############################################

print_log() {
  echo -e "\033[1;36mLog:\033[0m"
  echo -e "\033[35mIf the log is empty, to be sure it is enabled, use the \033[1mstatus\033[0;35m parameter.\033[0m"
  dmesg | grep -F "$SC_NAME"
}

set_log_state() {
  if [ "$LOG_ACT" ]; then
    if [ "$LOG_ACT" = 'ON' ]; then
      [ "$VERBOSE" ] && echo "- Enabling logging."
      nvram set aegis_log=1
      IPTBL_LOGGING='y'
    else
      [ "$VERBOSE" ] && echo "- Disabling logging."
      nvram unset aegis_log
      IPTBL_LOGGING=''
    fi
  fi
}

clean() {
  [ "$VERBOSE" ] && echo -e "\033[1;36mCleaning...\033[0m"
  clean_firewall_start
  clean_postmount
  [ "$RM_SYMLINK" ] && check_path && clean_path
  rm "$INFO_FILE" 2>/dev/null
  /usr/sbin/net-wall restart > /dev/null
  [ "$VERBOSE" ] && echo "- Built-in firewall restarted."
  ipset -q destroy "$IPSET_BL_NAME"
  ipset -q destroy "$IPSET_WL_NAME"
  ipset -q destroy "$IPSET_WG_NAME"
  ipset -q destroy "$IPSET_TMP"
  [ "$VERBOSE" ] && echo "- Cleaned ipsets."
  [ -e "$TMP_FILE" ] && rm "$TMP_FILE"
  nvram unset log_firewall_blocklist
  [ "$VERBOSE" ] && echo -e "- Removed temporary files.\n- Cleaning done."
}

set_ipset() {
  [ -r "$BL_FILE" ] || { >&2 echo -e "\033[31m! $BL_FILE not readable!\033[0m"; exit 1; }
  [ "$VERBOSE" ] && echo -e "\033[1;36mLoading blocklist into engine:\033[0m"
  set_log_state
  [ "$VERBOSE" ] && echo "- Starting $SC_NAME engine, forcing reload of blocklist..."
  engine_start "$INFO_FROM_SC"
}

update_iplist() {
  [ "$VERBOSE" ] && echo -e "\033[1;36mUpdating blocklist from sources...\033[0m"
  [ -e "$SRC_LIST" ] || get_def_srclst

  :>"$TMP_FILE"
  # Process each source url
  [ "$VERBOSE" ] && echo "- Downloading lists defined in $SRC_LIST"
  [ "$VERBOSE" ] && WGET_OPTS='-qO- --show-progress' || WGET_OPTS='-qO-'
  _NBOK=0; _TOT=0;
  grep -v "^[[:space:]*\#]" "$SRC_LIST" | \
  { while read -r URL; do
      _TOT=$((_TOT+1))
      [ "$VERBOSE" ] && echo -e "$_TOT) $URL\033[35m"
      { { { { wget $WGET_OPTS "$URL"; echo $? >&3; } | grep '^[0-9]' | sed 's/;.*//' >>"$TMP_FILE"; } 3>&1; } | { read _EC; exit $_EC; } }
      _EC=$?
      [ "$VERBOSE" ] && echo -e "\033[0m"
      [ $_EC = 0 ] && _NBOK=$((_NBOK+1)) || >&2 echo -e "\033[31m! Wget error code $_EC! Could not download $URL\033[0m"
    done
    [ $_NBOK = 0 ] && { >&2 echo -e "\033[31m! Could not get any list!\033[0m"; rm "$TMP_FILE"; exit 1; }
    [ $_NBOK = $_TOT ] || >&2 echo -e "\033[31m! Downloaded only $_NBOK / $_TOT list(s)!\033[0m"
  }
  if [ -r "$CUST_BL_FILE" ]; then
    [ "$VERBOSE" ] && echo "- Adding netset from custom blacklist ($CUST_BL_FILE)"
    grep '^[0-9]' "$CUST_BL_FILE" | sed 's/;.*//' >>"$TMP_FILE"
  fi
  if [ -x "$IPR_BIN" ]; then
    [ "$VERBOSE" ] && echo "- Optimizing and reducing netset (using iprange)..."
    $IPR_BIN --ipset-reduce 20 "$TMP_FILE" > "$BL_FILE"
  else
    [ "$VERBOSE" ] && echo -e "- iprange not installed, passing optimization and reduction process.\n- Removing duplicates..."
    sort "$TMP_FILE" | uniq > "$BL_FILE"
  fi
  rm "$TMP_FILE" 2>/dev/null
  [ "$VERBOSE" ] && echo "- Done."

  # processing whitelist if any
  if [ -r "$CUST_WL_FILE" ]; then
    [ "$VERBOSE" ] && echo -e "\033[1;36mGenerating whitelist from custom list...\033[0m"
    grep '^[0-9]' "$CUST_WL_FILE" | sed 's/;.*//' >"$TMP_FILE"
    
    if [ -s "$TMP_FILE" ]; then
      if [ -x "$IPR_BIN" ]; then
        if [ "$($IPR_BIN --common "$BL_FILE" "$TMP_FILE")" ]; then
          [ "$VERBOSE" ] && echo "- Optimizing and reducing netset (using iprange)..."
          $IPR_BIN --ipset-reduce 20 "$TMP_FILE"  > "$WL_FILE"
        else
          echo '- No IP in common with blocklist, skipping whitelist.'
        fi
      else
        [ "$VERBOSE" ] && echo -e "- iprange not installed, passing optimization and reduction process.\n- Removing duplicates..."
        sort "$TMP_FILE" | uniq > "$WL_FILE"
      fi
      else echo '- No IP set found, custom whitelist is empty.'
    fi
    rm "$TMP_FILE"
    [ "$VERBOSE" ] && echo "- Done."
  else
    rm "$WL_FILE" 2>/dev/null
  fi
}

info() {
  echo -e "\033[1;36mInfo:\033[0m"
  if [ -r "$SRC_LIST" ] && [ -d $(dirname "$BL_FILE") ] && [ -d $(dirname "$TMP_FILE") ];
    then echo -n "- '$SC_NAME' version $SC_VERS is installed "; [ "$EXT_DRIVE" ] && echo 'on external drive.' || echo 'on internal drive.'
    else echo -e "\033[31m! Something is wrong with installation!\033[0m"
  fi
  echo -ne "- Checking latest available version...\r"
  SC_LAST_VERS="$(last_avail_version)";
  if [ "$SC_LAST_VERS" ]; then
    _LOC_VERS=$(echo "$SC_VERS"|sed 's/[^[:digit:]]//g')
    _REM_VERS=$(echo "$SC_LAST_VERS"|sed 's/[^[:digit:]]//g')
    if [ $_LOC_VERS -eq $_REM_VERS ]; then echo "- This is the last version.            "
    elif [ $_LOC_VERS -lt $_REM_VERS ]; then echo -e "\033[35m- New version available: $SC_LAST_VERS       \033[0m"
    else echo -e "\033[35m- This version is higher than than the one available: $SC_LAST_VERS       \033[0m"
    fi
  else echo -e "\033[31m! Could not check what is the last version online!\033[0m"
  fi
  if check_path
    then echo "- '$SC_NAME' is in PATH."
    else echo "- '$SC_NAME' is not in PATH (you need to use $NICE_PATH)."
  fi
  # check iprange binary
  [ "$IPR_BIN" ] && echo "- 'iprange' is installed: $($IPR_BIN --version | head -n 1)" || echo "- 'iprange' is not installed."
}

#---------------------------- _STATUS ----------------------------
# STATUS VARS
CK_FWS=1          # CK PB
CK_PM=2           # CK PB
CK_IPS_BL=4       # CK PB
CK_IPS_WL=8       # CK PB
CK_WG_IN_BL=16    # CK ..
PB_WG_SNE=16      # .. PB
CK_WG_BP=32       # CK PB
CK_IPT_CH=64      # CK PB
CK_IPT_WG=128     # CK PB
CK_IPT_WL=256     # CK PB
CK_IPT_LOG=512    # CK ..
PB_IPT_IFO=512    # .. PB
CK_IPT_TUN=1024   # CK PB
CK_IPT_WAN=2048   # CK PB

WN_DIFF_IMP=1
WN_DIFF_BL=2
WN_FILE_BL=4
WN_DIFF_WL=8
WN_FILE_WL=16
WN_LOG=32

CK_MASK=4095 #12 bits

_status() {
  _CK=0; _WN=0; _PB=0
  
  # CHECK ENVIRONMENT
  # check firewall-start.sh script
  check_firewall_start &&                                                          _CK=$((_CK+CK_FWS))
  # check post-mount.sh script if script on external drive
  [ "$EXT_DRIVE" ] && check_postmount &&                                           _CK=$((_CK+CK_PM))
  # check if we can compare ip sets
  [ "$IPR_BIN" ] ||                                                                _WN=$((_WN+WN_DIFF_IMP))

  # CHECK BLOCKLIST (IPS, FILE)
  if ipset -q -n -L "$IPSET_BL_NAME">/dev/null; then                               _CK=$((_CK+CK_IPS_BL))
    if [ -r "$BL_FILE" ]; then
      if [ "$IPR_BIN" ]; then
        ipset_list_members "$IPSET_BL_NAME"|iprange --quiet - --diff "$BL_FILE" || _WN=$((_WN+WN_DIFF_BL))
      fi
    else                                                                           _WN=$((_WN+WN_FILE_BL))
    fi
  elif [ -r "$BL_FILE" ]; then                                                     _WN=$((_WN+WN_FILE_BL))
  fi

  # CHECK WHITELIST (IPS, FILE)
  if ipset -q -n -L "$IPSET_WL_NAME">/dev/null; then                               _CK=$((_CK+CK_IPS_WL))
    if [ -r "$WL_FILE" ]; then
      if [ "$IPR_BIN" ]; then
        ipset_list_members "$IPSET_WL_NAME"|iprange --quiet - --diff "$WL_FILE" || _WN=$((_WN+WN_DIFF_WL))
      fi
    else                                                                           _WN=$((_WN+WN_FILE_WL))
    fi
  elif [ -r "$WL_FILE" ]; then                                                     _WN=$((_WN+WN_FILE_WL))
  fi

  # CHECK WAN GATEWAY
  if [ "$WAN_GW" != '0.0.0.0' ] && ipset -q -T "$IPSET_BL_NAME" "$WAN_GW"; then    _CK=$((_CK+CK_WG_IN_BL))
    if ipset -q -T "$IPSET_WG_NAME" "$WAN_GW"; then                                _CK=$((_CK+CK_WG_BP))
    else                                                                           _PB=$((_PB+CK_WG_BP))
    fi
  elif ipset -q -n -L "$IPSET_WG_NAME">/dev/null; then                             _PB=$((_PB+PB_WG_SNE))
  fi

  # CHECK IPTABLES OWN CHAINS (CH)
  # -- SRC CHAIN
  _S_CK=0
  _S_PB=0
  _IPT="$(iptables -S "$IPTBL_SRC" 2>/dev/null)"
  if [ "$_IPT" ]; then
    _LL=$(echo "$_IPT"|wc -l)
    if [ "$(echo "$_IPT"|grep -nF -- "-N "|cut -d: -f1)" = 1 ] && [ "$(echo "$_IPT"|grep -nF -- "-j DROP"|cut -d: -f1)" = $_LL ]; then
                                                                                     _S_CK=$((_S_CK+CK_IPT_CH))
      _CL=2 # current line
      if [ "$(echo "$_IPT"|grep -nF -- "$IPSET_WG_NAME"|cut -d: -f1)" = $_CL ]; then _S_CK=$((_S_CK+CK_IPT_WG))
        echo "$_IPT"|grep -qF -- "$WAN_IF" ||                                        _S_PB=$((_S_PB+CK_IPT_WG))
        _CL=3
      fi
      if [ "$(echo "$_IPT"|grep -nF -- "$IPSET_WL_NAME"|cut -d: -f1)" = $_CL ]; then _S_CK=$((_S_CK+CK_IPT_WL))
        _CL=$((_CL+1))
      fi
      if [ "$(echo "$_IPT"|grep -nF -- 'LOG'|cut -d: -f1)" = $_CL ]; then            _S_CK=$((_S_CK+CK_IPT_LOG))
        _CL=$((_CL+1))
      fi
      [ $_CL = $_LL ] ||                                                             _S_PB=$((_S_PB+CK_IPT_CH))
    else                                                                             _S_PB=$((_S_PB+CK_IPT_CH))
    fi
  fi
  # -- DST CHAIN
  _D_CK=0
  _D_PB=0
  _IPT="$(iptables -S "$IPTBL_DST" 2>/dev/null)"
  if [ "$_IPT" ]; then
    _LL=$(echo "$_IPT"|wc -l)
    if [ "$(echo "$_IPT"|grep -nF -- "-N "|cut -d: -f1)" = 1 ] && [ "$(echo "$_IPT"|grep -nF -- "-j DROP"|cut -d: -f1)" = $_LL ]; then
                                                                                     _D_CK=$((_D_CK+CK_IPT_CH))
      _CL=2 # current line
      if [ "$(echo "$_IPT"|grep -nF -- "$IPSET_WG_NAME"|cut -d: -f1)" = $_CL ]; then _D_CK=$((_D_CK+CK_IPT_WG))
        echo "$_IPT"|grep -qF -- "$WAN_IF" ||                                        _D_PB=$((_D_PB+CK_IPT_WG))
        _CL=3
      fi
      if [ "$(echo "$_IPT"|grep -nF -- "$IPSET_WL_NAME"|cut -d: -f1)" = $_CL ]; then _D_CK=$((_D_CK+CK_IPT_WL))
        _CL=$((_CL+1))
      fi
      if [ "$(echo "$_IPT"|grep -nF -- 'LOG'|cut -d: -f1)" = $_CL ]; then            _D_CK=$((_D_CK+CK_IPT_LOG))
        _CL=$((_CL+1))
      fi
      [ $_CL = $_LL ] ||                                                             _D_PB=$((_D_PB+CK_IPT_CH))
    else                                                                             _D_PB=$((_D_PB+CK_IPT_CH))
    fi
  fi
  # -- SRC & DST
  if [ $_S_CK -eq $_D_CK ]; then                                                   _CK=$((_CK+_S_CK))
    if [ $_S_PB -eq $_D_PB ]; then                                                 _PB=$((_PB+_S_PB))
    else
      [ $((_S_PB&CK_IPT_WG)) -ne 0 ] || [ $((_D_PB&CK_IPT_WG)) -ne 0 ] &&          _PB=$((_PB+CK_IPT_WG))
      [ $((_S_PB&CK_IPT_CH)) -ne 0 ] || [ $((_D_PB&CK_IPT_CH)) -ne 0 ] &&          _PB=$((_PB+CK_IPT_CH))
    fi
  else                                                                             _PB=$((_PB+CK_IPT_CH))                                                                           
  fi
  # -- IFO (INPUT, FORWARD, OUTPUT)
  _IPT="$(iptables -S 2>/dev/null|grep -F -- "-m set --match-set $IPSET_BL_NAME")"
  if [ "$_IPT" ]; then
    _TCT=$(echo "$_IPT"|wc -l)
    # checking VPN tunnel interface rules
    if [ "$TUN_IF" ]; then
      _CT=$(echo "$_IPT"|grep -cF -- "$TUN_IF"); _TCT=$((_TCT-_CT))
      if [ "$_CT" = 4 ]; then _CK=$((_CK+CK_IPT_TUN))
      elif [ "$_CT" != 0 ]; then _PB=$((_PB+CK_IPT_TUN)); _PB=$((_PB+PB_IPT_IFO))
      fi
    fi
    # checking WAN interface rules
    _CT=$(echo "$_IPT"|grep -cF -- "$WAN_IF"); _TCT=$((_TCT-_CT))
    if [ "$_CT" = 4 ]; then _CK=$((_CK+CK_IPT_WAN))
    elif [ "$_CT" != 0 ]; then _PB=$((_PB+CK_IPT_WAN)); _PB=$((_PB+PB_IPT_IFO))
    fi
    # checking if old rules exists or if corrupted
    [ $_TCT -ne 0 ] && _PB=$((_PB+PB_IPT_IFO))
  fi

  # DEEPER CHECK
  if [ $_CK -ne 0 ]; then
  # -- PROBLEMS / WARNINGS
    # ENV
    [ $((_CK&CK_FWS)) -eq 0 ] &&                                                   _PB=$((_PB+CK_FWS))
    [ "$EXT_DRIVE" ] && [ $((_CK&CK_PM)) -eq 0 ] &&                                _PB=$((_PB+CK_PM))
    # WG: we already have CK_WG_BP, PB_WG_SNE, CK_IPT_WG
    # WL
    _OK=$((CK_IPS_WL+CK_IPT_WL))
    if [ $((_CK&_OK)) -ne 0 ] && [ $((_CK&_OK)) -ne $_OK ]; then
      [ $((_CK&CK_IPS_WL)) -eq 0 ] &&                                              _PB=$((_PB+CK_IPS_WL))
      [ $((_CK&CK_IPT_WL)) -eq 0 ] &&                                              _PB=$((_PB+CK_IPT_WL))
    fi
    # BL
    [ $((_CK&CK_IPS_BL)) -eq 0 ] &&                                                _PB=$((_PB+CK_IPS_BL))
    # LOG
    if [ "$IPTBL_LOGGING" ]; then [ $((_CK&CK_IPT_LOG)) -eq 0 ] &&                 _WN=$((_WN+WN_LOG))
    else [ $((_CK&CK_IPT_LOG)) -ne 0 ] &&                                          _WN=$((_WN+WN_LOG))
    fi
    # CH, IFO
    [ $(((_CK&CK_IPT_CH)+(_PB&CK_IPT_CH))) -eq 0 ] &&                              _PB=$((_PB+CK_IPT_CH))
    [ $(((_CK&CK_IPT_WAN)+(_PB&CK_IPT_WAN))) -eq 0 ] &&                            _PB=$((_PB&CK_IPT_WAN))
    [ "$TUN_IF" ] && [ $(((_CK&CK_IPT_TUN)+(_PB&CK_IPT_TUN))) -eq 0 ] &&           _PB=$((_PB&CK_IPT_TUN))
  fi
  
  # calculating return value
  _RET=$((_CK+(_PB<<12)+(_WN<<24)))
  return $_RET
}

status_term() {
  _status; _STAT=$?; _CK=$((_STAT&CK_MASK)); _PB=$(((_STAT>>12)&CK_MASK)); _WN=$(((_STAT>>24)&CK_MASK))

  echo -e "\033[1;36mStatus:\033[0m"
  if [ $((_CK+_PB)) -eq 0 ]; then
    _RETVAL=1
    echo "- '$SC_NAME' is not active; Settings are clean."
  elif [ $_CK -ne 0 ] && [ $_PB -eq 0 ]; then
    _RETVAL=0
    echo -ne "- \033[1m'$SC_NAME' is set and active\033[0m"
    [ $((_CK&CK_IPT_WAN)) -ne 0 ] && echo -n " for WAN interface ($WAN_IF)"
    [ $((_CK&CK_IPT_TUN)) -ne 0 ] && echo -n " and VPN tunnel ($TUN_IF)"
    echo -e ".\n- Filtering $(count_ip_in_ipset $IPSET_BL_NAME) IP adresses."
    [ $((_CK&CK_IPT_WL)) -ne 0 ] && echo "- Bypassing $(count_ip_in_ipset $IPSET_WL_NAME) IP adresses."
  else
    _RETVAL=2
    echo -e "- \033[1;31mSomething is not right!\033[0m"
  fi
  
  if [ $_PB -ne 0 ]; then
    echo -e "\033[1;31mErrors:\033[0m (CODE: $_PB)"
    [ $((_PB&CK_FWS)) -ne 0 ] &&     echo -e "\033[31m- 'firewall-start.sh' is not set properly for $SC_NAME!\033[0m"
    [ $((_PB&CK_PM)) -ne 0 ] &&      echo -e "\033[31m- 'post-mount.sh' is not set properly for $SC_NAME!\033[0m"
    [ $((_PB&CK_IPS_BL)) -ne 0 ] &&  echo -e "\033[31m- ipset: no blocklist is set!\033[0m"
    [ $((_PB&CK_IPS_WL)) -ne 0 ] &&  echo -e "\033[31m- ipset: no whitelist is set!\033[0m"
    [ $((_PB&PB_WG_SNE)) -ne 0 ] &&  echo -e "\033[31m- ipset: a gateway bypass is set but should not!\033[0m"
    [ $((_PB&CK_WG_BP)) -ne 0 ] &&   echo -e "\033[31m- ipset: WAN gateway bypass is not set!\033[0m"
    [ $((_PB&CK_IPT_CH)) -ne 0 ] &&  echo -e "\033[31m- iptables: engine chains are not right!\033[0m"
    [ $((_PB&CK_IPT_WG)) -ne 0 ] &&  echo -e "\033[31m- iptables: WAN gateway bypass rules are not right!\033[0m"
    [ $((_PB&CK_IPT_WL)) -ne 0 ] &&  echo -e "\033[31m- iptables: whitelist rules are not right!\033[0m"
    if [ $((_PB&PB_IPT_IFO)) -ne 0 ]; then echo -e "\033[31m- iptables: engine IFO rules are not right!\033[0m"
      [ $((_PB&CK_IPT_TUN)) -ne 0 ] &&     echo -e "\033[31m- iptables: VPN tunnel IFO rules are not right!\033[0m"
      [ $((_PB&CK_IPT_WAN)) -ne 0 ] &&     echo -e "\033[31m- iptables: WAN interface IFO rules are not right!\033[0m"
    else
      [ $((_PB&CK_IPT_TUN)) -ne 0 ] &&     echo -e "\033[31m- iptables: VPN tunnel IFO rules are missing!\033[0m"
      [ $((_PB&CK_IPT_WAN)) -ne 0 ] &&     echo -e "\033[31m- iptables: WAN interface IFO rules are missing!\033[0m"
    fi
  fi
  
  if [ $((_CK+_PB)) -ne 0 ] && [ $_WN -ne 0 ]; then
    echo -e "\033[1;35mWarnings:\033[0m (CODE: $_WN)"
    [ $((_WN&WN_DIFF_IMP)) -ne 0 ] && echo -e "\033[35m- 'iprange' is not installed: file/ipset comparison skipped.\033[0m"
    [ $((_WN&WN_DIFF_BL)) -ne 0 ] &&  echo -e "\033[35m- blocklist set is different than file.\033[0m"
    if [ $((_WN&WN_FILE_BL)) -ne 0 ]; then
      [ $((_CK&CK_IPS_BL)) -ne 0 ] && echo -e "\033[35m- blocklist is set but file is missing.\033[0m" ||
                                      echo -e "\033[35m- blocklist file exists but is not loaded.\033[0m"
    fi
    [ $((_WN&WN_DIFF_WL)) -ne 0 ] &&  echo -e "\033[35m- whitelist set is different than file.\033[0m"
    if [ $((_WN&WN_FILE_WL)) -ne 0 ]; then
      [ $((_CK&CK_IPS_WL)) -ne 0 ] && echo -e "\033[35m- whitelist is set but file is missing.\033[0m" ||
                                      echo -e "\033[35m- whitelist file exists bit is not loaded.\033[0m"
    fi
    [ $((_WN&WN_LOG)) -ne 0 ] &&      echo -e "\033[35m- current logging settings differs from last time engine was started.\033[0m"
  fi
 
  [ "$VERBOSE" ] || return 0

  echo -e "\033[1;36mDetailed status:\033[0m (CODE: $_CK)"
  # dates
  echo "- Actual router time: $(/bin/date +'%Y-%m-%d %X')"
  [ -e "$BL_FILE" ] && echo "- Blocklist generation time: $(/bin/date +'%Y-%m-%d %X' -r $BL_FILE)"
  [ -e "$WL_FILE" ] && echo "- Whitelist generation time: $(/bin/date +'%Y-%m-%d %X' -r $WL_FILE)"
  if [ $_CK -ne 0 ]; then
    [ $((_CK&CK_FWS)) -ne 0 ] &&      echo "- 'firewall-start.sh' is set for $SC_NAME."
    [ $((_CK&CK_PM)) -ne 0 ] &&       echo "- 'post-mount.sh' is set for $SC_NAME."
    [ $((_CK&CK_IPS_BL)) -ne 0 ] &&   echo "- ipset: blocklist is set."
    [ $((_CK&CK_IPS_WL)) -ne 0 ] &&   echo "- ipset: whitelist is set."
    [ $((_CK&CK_WG_IN_BL)) -ne 0 ] && echo "- ipset: WAN gateway is in blocklist."
    [ $((_CK&CK_WG_BP)) -ne 0 ] &&    echo "- ipset: WAN gateway bypass is set."
    [ $((_CK&CK_IPT_CH)) -ne 0 ] &&   echo "- iptables: engine chains are set."
    [ $((_CK&CK_IPT_WG)) -ne 0 ] &&   echo "- iptables: WAN gateway bypass rules are set."
    [ $((_CK&CK_IPT_WL)) -ne 0 ] &&   echo "- iptables: whitelist rules are set."
    [ $((_CK&CK_IPT_LOG)) -ne 0 ] &&  echo "- iptables: $SC_NAME logging is on."
    [ $((_CK&CK_IPT_TUN)) -ne 0 ] &&  echo "- iptables: VPN tunnel IFO rules are set."
    [ $((_CK&CK_IPT_WAN)) -ne 0 ] &&  echo "- iptables: WAN interface IFO rules are set."
  fi
  
  [ "$VERBOSE" -lt 2 ] && return 0

  # Status file
  echo -ne "\033[1;36m'$SC_NAME' engine last launch report:\033[0m"
  if [ -r "$INFO_FILE" ]; then
    INFO=$(cat "$INFO_FILE")
    INFO_FROM=$((INFO&INFO_FROM_MASK))
    INFO_IPS=$(((INFO>>2)&INFO_IPS_MASK))
    INFO_IPT=$(((INFO>>10)&INFO_IPT_MASK))
    echo " (CODE: $INFO_FROM-$INFO_IPS-$INFO_IPT)"
    case "$INFO_FROM" in
      $INFO_FROM_SC) FROM="$SC_NAME script" ;;
      $INFO_FROM_PM) FROM="post-mount.sh" ;;
      $INFO_FROM_FWS) FROM="firewall-start.sh" ;;
    esac
    echo "- engine was launched from: $FROM @ $(/bin/date +'%Y-%m-%d %X' -r $INFO_FILE)"
    case $((INFO_IPS&INFO_IPS_BL_MASK)) in
      0) echo '! blocklist file was not found!' ;;
      $INFO_IPS_BL_SAME) echo '- ipset: blocklist was already set and identical to file.' ;;
      $INFO_IPS_BL_MISS) echo '- ipset: blocklist file was not found! The one already set was kept.' ;;
      $INFO_IPS_BL_LOAD) echo '- ipset: blocklist was set from file.' ;;
    esac
    case $((INFO_IPS&INFO_IPS_WL_MASK)) in
      0) echo '- no whitelist file was found.' ;;
      $((INFO_IPS_WL_SAME+INFO_IPS_WL_KEEP))) echo '- ipset: whitelist was already set and identical to file.' ;;
      $INFO_IPS_WL_KEEP) echo '- ipset: whitelist was kept.' ;;
      $INFO_IPS_WL_LOAD) echo '- ipset: whitelist was set from file.' ;;
      $INFO_IPS_WL_SWAP) echo '- ipset: whitelist was updated from file.' ;;
      $INFO_IPS_WL_DEL) echo '- ipset: whitelist was unset.' ;;
    esac
    case $((INFO_IPS&INFO_IPS_WG_MASK)) in
      0) echo '- WAN gateway was not in blocklist set and therefore was not bypassed.' ;;
      $INFO_IPS_WG_ADD) echo '- ipset: WAN gateway was in blocklist and was bypassed.' ;;
      $INFO_IPS_WG_KEEP) echo '- ipset: WAN gateway bypass was already properly set.' ;;
      $INFO_IPS_WG_DEL) echo '- ipset: WAN gateway bypass was unset.' ;;
    esac
    if [ $((INFO_IPT & INFO_IPT_SRC_KEEP)) -eq 0 ]
      then echo "- iptables: engine inbound chain was set."
      else echo "- iptables: engine inbound chain was already set."
    fi
    if [ $((INFO_IPT & INFO_IPT_DST_KEEP)) -eq 0 ]
      then echo '- iptables: engine outbound chain was set.'
      else echo '- iptables: engine outbound chain was already set.'
    fi
    if [ $((INFO_IPT & INFO_IPT_WG)) -ne 0 ]; then
      if [ $((INFO_IPT & INFO_IPT_WG_SRC_NEW)) -ne 0 ]
        then echo '- iptables: inbound WAN gateway bypass rules were set.'
        else echo '- iptables: inbound WAN gateway bypass rules were kept.'
      fi
      if [ $((INFO_IPT & INFO_IPT_WG_DST_NEW)) -ne 0 ]
        then echo '- iptables: outbound WAN gateway bypass rules were set.'
        else echo '- iptables: outbound WAN gateway bypass rules were kept.'
      fi
    fi
    if [ $((INFO_IPT & INFO_IPT_WL)) -ne 0 ]; then
      if [ $((INFO_IPT & INFO_IPT_WL_SRC_NEW)) -ne 0 ]
        then echo '- iptables: inbound whitelist rules were set.'
        else echo '- iptables: inbound whitelist rules were kept.'
      fi
      if [ $((INFO_IPT & INFO_IPT_WL_DST_NEW)) -ne 0 ]
        then echo '- iptables: outbound whitelist rules were set.'
        else echo '- iptables: outbound whitelist rules were kept.'
      fi
    fi
    if [ $((INFO_IPT & INFO_IPT_LOG)) -ne 0 ]; then
      if [ $((INFO_IPT & INFO_IPT_LOG_SRC_NEW)) -ne 0 ]
        then echo '- iptables: inbound logging rules were set.'
        else echo '- iptables: inbound logging rules were kept.'
      fi
      if [ $((INFO_IPT & INFO_IPT_LOG_DST_NEW)) -ne 0 ]
        then echo '- iptables: outbound logging rules were set.'
        else echo '- iptables: outbound logging rules were kept.'
      fi
    fi
    
    [ $((INFO_IPT & INFO_IPT_IFO_PBM)) -ne 0 ] && echo '- iptables: some irrelevant IFO rules had to be removed.'
    if [ $((INFO_IPT & INFO_IPT_WAN_PBM)) -eq $INFO_IPT_WAN_PBM ]; then echo '- iptables: WAN interface IFO rules had to be reset.'
    elif [ $((INFO_IPT & INFO_IPT_WAN_NEW)) -ne 0 ]; then echo '- iptables: WAN interface IFO rules were set.'
    elif [ $((INFO_IPT & INFO_IPT_WAN_KEEP)) -ne 0 ]; then echo '- iptables: WAN interface IFO rules were kept.'
    fi
    if [ $((INFO_IPT & INFO_IPT_TUN_PBM)) -eq $INFO_IPT_TUN_PBM ]; then echo '- iptables: VPN tunnel IFO rules had to be reset.'
    elif [ $((INFO_IPT & INFO_IPT_TUN_NEW)) -ne 0 ]; then echo '- iptables: VPN tunnel IFO rules were set.'
    elif [ $((INFO_IPT & INFO_IPT_TUN_KEEP)) -ne 0 ]; then echo '- iptables: VPN tunnel IFO rules were kept.'
    fi
    
    echo -ne "\033[0m"
  else
    echo -e '\n- No status file found.'
  fi
  
  [ "$VERBOSE" -lt 3 ] && return 0
  
  if [ $((_CK+_PB)) -ne 0 ]; then
    echo -e "\033[1;36miptables:\033[0m"
    _IPT="$(iptables -S 2>/dev/null|grep -F -- "$SC_ABR")"
    [ -z "$_IPT" ] && echo "- no $SC_NAME rules are set." || echo "$_IPT"
    ipset -L -n|grep -F -- "$SC_ABR"|while read _SET; do
      case "$_SET" in
        "$IPSET_BL_NAME") _NAME='blocklist' ;;
        "$IPSET_WL_NAME") _NAME='whitelist' ;;
        "$IPSET_WG_NAME") _NAME='wan gateway bypass' ;;
        *) _NAME="$_SET" ;;
      esac
      echo -e "\033[1;36mipset '$_NAME':\033[0m"
      ipset -L -t $_SET|sed 's/^/- /'
    done
  fi
}
#---------------------------- END _STATUS ----------------------------

print_help() {
  echo -e "\033[1;36m$SC_NAME $SC_VERS\033[0m"
  echo -e "Usage: \033[1m$SC_NAME \033[35mCOMMAND \033[36m[OPTION(S)]\033[0m"
  echo -e "\033[7mCOMMANDS (use only one):\033[0m"
  echo -e " \033[1;35mrestart\033[0m    - restarts internal firewall and $SC_NAME engine"
  echo -e " \033[1;35mupdate_set\033[0m - updates set from servers in '$SRC_LIST'"
  echo -e " \033[1;35mload_set\033[0m   - reloads $SC_NAME engine with last generated set"
  echo -e " \033[1;35mupdate\033[0m     - updates set then reloads $SC_NAME engine with it \033[1;36m[probably what you want to use]\033[0m"
  echo -e " \033[1;35mclean\033[0m      - removes $SC_NAME engine from internal firewall and restarts it"
  echo -e " \033[1;35mhelp\033[0m       - displays help (this)"
  echo -e " \033[1;35minfo\033[0m       - displays info on this script"
  echo -e " \033[1;35mstatus\033[0m     - displays status"
  echo -e " \033[1;35mlog\033[0m        - displays log"
  echo -e " \033[1;35mupgrade\033[0m    - downloads and installs latest version"
  echo -e "\033[7mOPTIONS (none, one or more):\033[0m"
  echo -e " \033[1;36m-v\033[0m          - verbose mode"
  echo -e " \033[1;36m-q\033[0m          - quiet mode"
  echo -e " \033[1;36m-html\033[0m       - sends output to router's web: http://routerlogin.net/bolemo/$SC_NAME.htm"
  echo -e " \033[1;36m-log=on\033[0m/\033[1;36moff\033[0m - when used with restart, load_set or update, will enable/disable logging"
  echo -e " \033[1;36m-rm-symlink\033[0m - when used with clean, removes the symlink /usr/bin/$SC_NAME"
}

###############################################
#
#    MAIN ROUTINE
#
###############################################
_RETVAL=0

[ $# = 0 ] && { >&2 echo -e "\033[31m! No parameter!\033[0m"; print_help; exit 1; }
[ "$1" = "_pm" ] && [ "$2" ] && _pm

PARAM="$(echo "$*" | /bin/sed 's/-[[:alpha:]=]*//g')"
case $(echo "$PARAM" | wc -w) in
  0) >&2 echo -e "\033[31m! No parameter!\033[0m"; print_help; exit 1 ;;
  1) PARAM="$(echo "$PARAM" | sed 's/ //g')" ;;
  *) >&2 echo -e "\033[31m! Too many parameters!\033[0m"; print_help; exit 1 ;;
esac

ARGS=" $* "
[ -z "${ARGS##* -v *}" ] && VERBOSE=1
[ -z "${ARGS##* -vv *}" ] && VERBOSE=2
[ -z "${ARGS##* -vvv *}" ] && VERBOSE=3
[ -z "${ARGS##* -q *}" ] && QUIET=1
[ -z "${ARGS##* --devmode *}" ] && DEVMODE=1
[ -z "${ARGS##* -log=on *}" ] && LOG_ACT='ON'
[ -z "${ARGS##* -log=off *}" ] && LOG_ACT='OFF'
[ -z "${ARGS##* -rm-symlink *}" ] && RM_SYMLINK=1
[ -z "${ARGS##* -html *}" ] && _HTML="$WWW_PATH/$SC_NAME.htm"

[ "$QUIET" ] && exec>/dev/null

if [ "$_HTML" ]; then
  echo -e '<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">\n<title>aegis page</title>\n<pre>'>$_HTML
  echo -e "Time: $(/bin/date +'%Y-%m-%d %X')\nCommand: $0 $@\nOutput:\n">>$_HTML
  exec>>$TMP_HTML
fi

pre_init

if [ $DEVMODE ]; then echo -e "\033[7;31m$SC_NAME $SC_VERS - Developer mode\033[0m"; VERBOSE=3
elif [ $VERBOSE ]; then echo -e "\033[7;31m$SC_NAME $SC_VERS - Verbose mode [level $VERBOSE]\033[0m"; fi

case "$PARAM" in
  'restart') init; fw_restart; [ $VERBOSE ] && status_term ;;
  'clean') clean; [ $VERBOSE ] && status_term ;;
  'load_set') init; set_ipset; [ $VERBOSE ] && status_term ;;
  'update_set') update_iplist ;;
  'update') init; update_iplist; set_ipset; [ $VERBOSE ] && status_term ;;
  'status') status_term ;;
  'help') print_help ;;
  'info') info ;;
  'log') print_log ;;
  'upgrade') upgrade ;;
  *) >&2 echo -e "\033[31m! Unknown Parameter $2!\033[0m"; print_help; exit 1 ;;
esac

if [ "$_HTML" ]; then
  sed 's/[[:cntrl:]]\[\([^m]*\)m//g' $TMP_HTML>>$_HTML
  \rm $TMP_HTML 2>/dev/null
fi

exit $_RETVAL
